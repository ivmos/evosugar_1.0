/* soapC.c
   Generated by gSOAP 2.7.9l from sugar.h
   Copyright(C) 2000-2007, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC.c ver 2.7.9l 2010-01-18 12:19:54 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	soap->header = (struct SOAP_ENV__Header*)soap_malloc(soap, sizeof(struct SOAP_ENV__Header));
		soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_ns1__create_USCOREcase:
		return soap_in_ns1__create_USCOREcase(soap, NULL, NULL, "ns1:create_case");
	case SOAP_TYPE_ns1__create_USCOREcaseResponse:
		return soap_in_ns1__create_USCOREcaseResponse(soap, NULL, NULL, "ns1:create_caseResponse");
	case SOAP_TYPE_ns1__create_USCOREopportunity:
		return soap_in_ns1__create_USCOREopportunity(soap, NULL, NULL, "ns1:create_opportunity");
	case SOAP_TYPE_ns1__create_USCOREopportunityResponse:
		return soap_in_ns1__create_USCOREopportunityResponse(soap, NULL, NULL, "ns1:create_opportunityResponse");
	case SOAP_TYPE_ns1__create_USCOREaccount:
		return soap_in_ns1__create_USCOREaccount(soap, NULL, NULL, "ns1:create_account");
	case SOAP_TYPE_ns1__create_USCOREaccountResponse:
		return soap_in_ns1__create_USCOREaccountResponse(soap, NULL, NULL, "ns1:create_accountResponse");
	case SOAP_TYPE_ns1__create_USCORElead:
		return soap_in_ns1__create_USCORElead(soap, NULL, NULL, "ns1:create_lead");
	case SOAP_TYPE_ns1__create_USCOREleadResponse:
		return soap_in_ns1__create_USCOREleadResponse(soap, NULL, NULL, "ns1:create_leadResponse");
	case SOAP_TYPE_ns1__create_USCOREcontact:
		return soap_in_ns1__create_USCOREcontact(soap, NULL, NULL, "ns1:create_contact");
	case SOAP_TYPE_ns1__create_USCOREcontactResponse:
		return soap_in_ns1__create_USCOREcontactResponse(soap, NULL, NULL, "ns1:create_contactResponse");
	case SOAP_TYPE_ns1__track_USCOREemail:
		return soap_in_ns1__track_USCOREemail(soap, NULL, NULL, "ns1:track_email");
	case SOAP_TYPE_ns1__track_USCOREemailResponse:
		return soap_in_ns1__track_USCOREemailResponse(soap, NULL, NULL, "ns1:track_emailResponse");
	case SOAP_TYPE_ns1__search:
		return soap_in_ns1__search(soap, NULL, NULL, "ns1:search");
	case SOAP_TYPE_ns1__searchResponse:
		return soap_in_ns1__searchResponse(soap, NULL, NULL, "ns1:searchResponse");
	case SOAP_TYPE_ns1__user_USCORElist:
		return soap_in_ns1__user_USCORElist(soap, NULL, NULL, "ns1:user_list");
	case SOAP_TYPE_ns1__user_USCORElistResponse:
		return soap_in_ns1__user_USCORElistResponse(soap, NULL, NULL, "ns1:user_listResponse");
	case SOAP_TYPE_ns1__get_USCOREcontact_USCORErelationships:
		return soap_in_ns1__get_USCOREcontact_USCORErelationships(soap, NULL, NULL, "ns1:get_contact_relationships");
	case SOAP_TYPE_ns1__get_USCOREcontact_USCORErelationshipsResponse:
		return soap_in_ns1__get_USCOREcontact_USCORErelationshipsResponse(soap, NULL, NULL, "ns1:get_contact_relationshipsResponse");
	case SOAP_TYPE_ns1__contact_USCOREby_USCOREemail:
		return soap_in_ns1__contact_USCOREby_USCOREemail(soap, NULL, NULL, "ns1:contact_by_email");
	case SOAP_TYPE_ns1__contact_USCOREby_USCOREemailResponse:
		return soap_in_ns1__contact_USCOREby_USCOREemailResponse(soap, NULL, NULL, "ns1:contact_by_emailResponse");
	case SOAP_TYPE_ns1__end_USCOREsession:
		return soap_in_ns1__end_USCOREsession(soap, NULL, NULL, "ns1:end_session");
	case SOAP_TYPE_ns1__end_USCOREsessionResponse:
		return soap_in_ns1__end_USCOREsessionResponse(soap, NULL, NULL, "ns1:end_sessionResponse");
	case SOAP_TYPE_ns1__create_USCOREsession:
		return soap_in_ns1__create_USCOREsession(soap, NULL, NULL, "ns1:create_session");
	case SOAP_TYPE_ns1__create_USCOREsessionResponse:
		return soap_in_ns1__create_USCOREsessionResponse(soap, NULL, NULL, "ns1:create_sessionResponse");
	case SOAP_TYPE_ns1__get_USCOREattendee_USCORElist:
		return soap_in_ns1__get_USCOREattendee_USCORElist(soap, NULL, NULL, "ns1:get_attendee_list");
	case SOAP_TYPE_ns1__get_USCOREattendee_USCORElistResponse:
		return soap_in_ns1__get_USCOREattendee_USCORElistResponse(soap, NULL, NULL, "ns1:get_attendee_listResponse");
	case SOAP_TYPE_ns1__get_USCOREmodified_USCOREentries:
		return soap_in_ns1__get_USCOREmodified_USCOREentries(soap, NULL, NULL, "ns1:get_modified_entries");
	case SOAP_TYPE_ns1__get_USCOREmodified_USCOREentriesResponse:
		return soap_in_ns1__get_USCOREmodified_USCOREentriesResponse(soap, NULL, NULL, "ns1:get_modified_entriesResponse");
	case SOAP_TYPE_ns1__sync_USCOREget_USCOREmodified_USCORErelationships:
		return soap_in_ns1__sync_USCOREget_USCOREmodified_USCORErelationships(soap, NULL, NULL, "ns1:sync_get_modified_relationships");
	case SOAP_TYPE_ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse:
		return soap_in_ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse(soap, NULL, NULL, "ns1:sync_get_modified_relationshipsResponse");
	case SOAP_TYPE_ns1__set_USCOREentries_USCOREdetails:
		return soap_in_ns1__set_USCOREentries_USCOREdetails(soap, NULL, NULL, "ns1:set_entries_details");
	case SOAP_TYPE_ns1__set_USCOREentries_USCOREdetailsResponse:
		return soap_in_ns1__set_USCOREentries_USCOREdetailsResponse(soap, NULL, NULL, "ns1:set_entries_detailsResponse");
	case SOAP_TYPE_ns1__get_USCOREentries_USCOREcount:
		return soap_in_ns1__get_USCOREentries_USCOREcount(soap, NULL, NULL, "ns1:get_entries_count");
	case SOAP_TYPE_ns1__get_USCOREentries_USCOREcountResponse:
		return soap_in_ns1__get_USCOREentries_USCOREcountResponse(soap, NULL, NULL, "ns1:get_entries_countResponse");
	case SOAP_TYPE_ns1__set_USCOREcampaign_USCOREmerge:
		return soap_in_ns1__set_USCOREcampaign_USCOREmerge(soap, NULL, NULL, "ns1:set_campaign_merge");
	case SOAP_TYPE_ns1__set_USCOREcampaign_USCOREmergeResponse:
		return soap_in_ns1__set_USCOREcampaign_USCOREmergeResponse(soap, NULL, NULL, "ns1:set_campaign_mergeResponse");
	case SOAP_TYPE_ns1__get_USCOREdocument_USCORErevision:
		return soap_in_ns1__get_USCOREdocument_USCORErevision(soap, NULL, NULL, "ns1:get_document_revision");
	case SOAP_TYPE_ns1__get_USCOREdocument_USCORErevisionResponse:
		return soap_in_ns1__get_USCOREdocument_USCORErevisionResponse(soap, NULL, NULL, "ns1:get_document_revisionResponse");
	case SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocument2:
		return soap_in_ns1__get_USCOREmailmerge_USCOREdocument2(soap, NULL, NULL, "ns1:get_mailmerge_document2");
	case SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocument2Response:
		return soap_in_ns1__get_USCOREmailmerge_USCOREdocument2Response(soap, NULL, NULL, "ns1:get_mailmerge_document2Response");
	case SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocument:
		return soap_in_ns1__get_USCOREmailmerge_USCOREdocument(soap, NULL, NULL, "ns1:get_mailmerge_document");
	case SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocumentResponse:
		return soap_in_ns1__get_USCOREmailmerge_USCOREdocumentResponse(soap, NULL, NULL, "ns1:get_mailmerge_documentResponse");
	case SOAP_TYPE_ns1__search_USCOREby_USCOREmodule:
		return soap_in_ns1__search_USCOREby_USCOREmodule(soap, NULL, NULL, "ns1:search_by_module");
	case SOAP_TYPE_ns1__search_USCOREby_USCOREmoduleResponse:
		return soap_in_ns1__search_USCOREby_USCOREmoduleResponse(soap, NULL, NULL, "ns1:search_by_moduleResponse");
	case SOAP_TYPE_ns1__set_USCOREdocument_USCORErevision:
		return soap_in_ns1__set_USCOREdocument_USCORErevision(soap, NULL, NULL, "ns1:set_document_revision");
	case SOAP_TYPE_ns1__set_USCOREdocument_USCORErevisionResponse:
		return soap_in_ns1__set_USCOREdocument_USCORErevisionResponse(soap, NULL, NULL, "ns1:set_document_revisionResponse");
	case SOAP_TYPE_ns1__set_USCORErelationships:
		return soap_in_ns1__set_USCORErelationships(soap, NULL, NULL, "ns1:set_relationships");
	case SOAP_TYPE_ns1__set_USCORErelationshipsResponse:
		return soap_in_ns1__set_USCORErelationshipsResponse(soap, NULL, NULL, "ns1:set_relationshipsResponse");
	case SOAP_TYPE_ns1__set_USCORErelationship:
		return soap_in_ns1__set_USCORErelationship(soap, NULL, NULL, "ns1:set_relationship");
	case SOAP_TYPE_ns1__set_USCORErelationshipResponse:
		return soap_in_ns1__set_USCORErelationshipResponse(soap, NULL, NULL, "ns1:set_relationshipResponse");
	case SOAP_TYPE_ns1__get_USCORErelationships:
		return soap_in_ns1__get_USCORErelationships(soap, NULL, NULL, "ns1:get_relationships");
	case SOAP_TYPE_ns1__get_USCORErelationshipsResponse:
		return soap_in_ns1__get_USCORErelationshipsResponse(soap, NULL, NULL, "ns1:get_relationshipsResponse");
	case SOAP_TYPE_ns1__get_USCOREserver_USCOREversion:
		return soap_in_ns1__get_USCOREserver_USCOREversion(soap, NULL, NULL, "ns1:get_server_version");
	case SOAP_TYPE_ns1__get_USCOREserver_USCOREversionResponse:
		return soap_in_ns1__get_USCOREserver_USCOREversionResponse(soap, NULL, NULL, "ns1:get_server_versionResponse");
	case SOAP_TYPE_ns1__get_USCOREsugar_USCOREflavor:
		return soap_in_ns1__get_USCOREsugar_USCOREflavor(soap, NULL, NULL, "ns1:get_sugar_flavor");
	case SOAP_TYPE_ns1__get_USCOREsugar_USCOREflavorResponse:
		return soap_in_ns1__get_USCOREsugar_USCOREflavorResponse(soap, NULL, NULL, "ns1:get_sugar_flavorResponse");
	case SOAP_TYPE_ns1__get_USCOREgmt_USCOREtime:
		return soap_in_ns1__get_USCOREgmt_USCOREtime(soap, NULL, NULL, "ns1:get_gmt_time");
	case SOAP_TYPE_ns1__get_USCOREgmt_USCOREtimeResponse:
		return soap_in_ns1__get_USCOREgmt_USCOREtimeResponse(soap, NULL, NULL, "ns1:get_gmt_timeResponse");
	case SOAP_TYPE_ns1__get_USCOREserver_USCOREtime:
		return soap_in_ns1__get_USCOREserver_USCOREtime(soap, NULL, NULL, "ns1:get_server_time");
	case SOAP_TYPE_ns1__get_USCOREserver_USCOREtimeResponse:
		return soap_in_ns1__get_USCOREserver_USCOREtimeResponse(soap, NULL, NULL, "ns1:get_server_timeResponse");
	case SOAP_TYPE_ns1__get_USCOREuser_USCOREteam_USCOREid:
		return soap_in_ns1__get_USCOREuser_USCOREteam_USCOREid(soap, NULL, NULL, "ns1:get_user_team_id");
	case SOAP_TYPE_ns1__get_USCOREuser_USCOREteam_USCOREidResponse:
		return soap_in_ns1__get_USCOREuser_USCOREteam_USCOREidResponse(soap, NULL, NULL, "ns1:get_user_team_idResponse");
	case SOAP_TYPE_ns1__get_USCOREuser_USCOREid:
		return soap_in_ns1__get_USCOREuser_USCOREid(soap, NULL, NULL, "ns1:get_user_id");
	case SOAP_TYPE_ns1__get_USCOREuser_USCOREidResponse:
		return soap_in_ns1__get_USCOREuser_USCOREidResponse(soap, NULL, NULL, "ns1:get_user_idResponse");
	case SOAP_TYPE_ns1__update_USCOREportal_USCOREuser:
		return soap_in_ns1__update_USCOREportal_USCOREuser(soap, NULL, NULL, "ns1:update_portal_user");
	case SOAP_TYPE_ns1__update_USCOREportal_USCOREuserResponse:
		return soap_in_ns1__update_USCOREportal_USCOREuserResponse(soap, NULL, NULL, "ns1:update_portal_userResponse");
	case SOAP_TYPE_ns1__get_USCOREavailable_USCOREmodules:
		return soap_in_ns1__get_USCOREavailable_USCOREmodules(soap, NULL, NULL, "ns1:get_available_modules");
	case SOAP_TYPE_ns1__get_USCOREavailable_USCOREmodulesResponse:
		return soap_in_ns1__get_USCOREavailable_USCOREmodulesResponse(soap, NULL, NULL, "ns1:get_available_modulesResponse");
	case SOAP_TYPE_ns1__get_USCOREmodule_USCOREfields:
		return soap_in_ns1__get_USCOREmodule_USCOREfields(soap, NULL, NULL, "ns1:get_module_fields");
	case SOAP_TYPE_ns1__get_USCOREmodule_USCOREfieldsResponse:
		return soap_in_ns1__get_USCOREmodule_USCOREfieldsResponse(soap, NULL, NULL, "ns1:get_module_fieldsResponse");
	case SOAP_TYPE_ns1__logout:
		return soap_in_ns1__logout(soap, NULL, NULL, "ns1:logout");
	case SOAP_TYPE_ns1__logoutResponse:
		return soap_in_ns1__logoutResponse(soap, NULL, NULL, "ns1:logoutResponse");
	case SOAP_TYPE_ns1__get_USCORErelated_USCOREnotes:
		return soap_in_ns1__get_USCORErelated_USCOREnotes(soap, NULL, NULL, "ns1:get_related_notes");
	case SOAP_TYPE_ns1__get_USCORErelated_USCOREnotesResponse:
		return soap_in_ns1__get_USCORErelated_USCOREnotesResponse(soap, NULL, NULL, "ns1:get_related_notesResponse");
	case SOAP_TYPE_ns1__relate_USCOREnote_USCOREto_USCOREmodule:
		return soap_in_ns1__relate_USCOREnote_USCOREto_USCOREmodule(soap, NULL, NULL, "ns1:relate_note_to_module");
	case SOAP_TYPE_ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse:
		return soap_in_ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse(soap, NULL, NULL, "ns1:relate_note_to_moduleResponse");
	case SOAP_TYPE_ns1__get_USCOREnote_USCOREattachment:
		return soap_in_ns1__get_USCOREnote_USCOREattachment(soap, NULL, NULL, "ns1:get_note_attachment");
	case SOAP_TYPE_ns1__get_USCOREnote_USCOREattachmentResponse:
		return soap_in_ns1__get_USCOREnote_USCOREattachmentResponse(soap, NULL, NULL, "ns1:get_note_attachmentResponse");
	case SOAP_TYPE_ns1__set_USCOREnote_USCOREattachment:
		return soap_in_ns1__set_USCOREnote_USCOREattachment(soap, NULL, NULL, "ns1:set_note_attachment");
	case SOAP_TYPE_ns1__set_USCOREnote_USCOREattachmentResponse:
		return soap_in_ns1__set_USCOREnote_USCOREattachmentResponse(soap, NULL, NULL, "ns1:set_note_attachmentResponse");
	case SOAP_TYPE_ns1__set_USCOREentries:
		return soap_in_ns1__set_USCOREentries(soap, NULL, NULL, "ns1:set_entries");
	case SOAP_TYPE_ns1__set_USCOREentriesResponse:
		return soap_in_ns1__set_USCOREentriesResponse(soap, NULL, NULL, "ns1:set_entriesResponse");
	case SOAP_TYPE_ns1__set_USCOREentry:
		return soap_in_ns1__set_USCOREentry(soap, NULL, NULL, "ns1:set_entry");
	case SOAP_TYPE_ns1__set_USCOREentryResponse:
		return soap_in_ns1__set_USCOREentryResponse(soap, NULL, NULL, "ns1:set_entryResponse");
	case SOAP_TYPE_ns1__get_USCOREentries:
		return soap_in_ns1__get_USCOREentries(soap, NULL, NULL, "ns1:get_entries");
	case SOAP_TYPE_ns1__get_USCOREentriesResponse:
		return soap_in_ns1__get_USCOREentriesResponse(soap, NULL, NULL, "ns1:get_entriesResponse");
	case SOAP_TYPE_ns1__get_USCOREentry:
		return soap_in_ns1__get_USCOREentry(soap, NULL, NULL, "ns1:get_entry");
	case SOAP_TYPE_ns1__get_USCOREentryResponse:
		return soap_in_ns1__get_USCOREentryResponse(soap, NULL, NULL, "ns1:get_entryResponse");
	case SOAP_TYPE_ns1__get_USCOREentry_USCORElist:
		return soap_in_ns1__get_USCOREentry_USCORElist(soap, NULL, NULL, "ns1:get_entry_list");
	case SOAP_TYPE_ns1__get_USCOREentry_USCORElistResponse:
		return soap_in_ns1__get_USCOREentry_USCORElistResponse(soap, NULL, NULL, "ns1:get_entry_listResponse");
	case SOAP_TYPE_ns1__seamless_USCORElogin:
		return soap_in_ns1__seamless_USCORElogin(soap, NULL, NULL, "ns1:seamless_login");
	case SOAP_TYPE_ns1__seamless_USCOREloginResponse:
		return soap_in_ns1__seamless_USCOREloginResponse(soap, NULL, NULL, "ns1:seamless_loginResponse");
	case SOAP_TYPE_ns1__is_USCOREloopback:
		return soap_in_ns1__is_USCOREloopback(soap, NULL, NULL, "ns1:is_loopback");
	case SOAP_TYPE_ns1__is_USCOREloopbackResponse:
		return soap_in_ns1__is_USCOREloopbackResponse(soap, NULL, NULL, "ns1:is_loopbackResponse");
	case SOAP_TYPE_ns1__login:
		return soap_in_ns1__login(soap, NULL, NULL, "ns1:login");
	case SOAP_TYPE_ns1__loginResponse:
		return soap_in_ns1__loginResponse(soap, NULL, NULL, "ns1:loginResponse");
	case SOAP_TYPE_ns1__is_USCOREuser_USCOREadmin:
		return soap_in_ns1__is_USCOREuser_USCOREadmin(soap, NULL, NULL, "ns1:is_user_admin");
	case SOAP_TYPE_ns1__is_USCOREuser_USCOREadminResponse:
		return soap_in_ns1__is_USCOREuser_USCOREadminResponse(soap, NULL, NULL, "ns1:is_user_adminResponse");
	case SOAP_TYPE_user_USCOREdetail_USCOREarray:
		return soap_in_user_USCOREdetail_USCOREarray(soap, NULL, NULL, "ns1:user_detail");
	case SOAP_TYPE_contact_USCOREdetail_USCOREarray:
		return soap_in_contact_USCOREdetail_USCOREarray(soap, NULL, NULL, "ns1:contact_detail");
	case SOAP_TYPE_str_USCOREarray:
		return soap_in_str_USCOREarray(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_name_USCOREvalue_USCOREoperator_USCORElist:
		return soap_in_name_USCOREvalue_USCOREoperator_USCORElist(soap, NULL, NULL, "ns1:name_value_operator");
	case SOAP_TYPE_new_USCOREset_USCORErelationhip_USCOREids:
		return soap_in_new_USCOREset_USCORErelationhip_USCOREids(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_set_USCORErelationship_USCORElist:
		return soap_in_set_USCORErelationship_USCORElist(soap, NULL, NULL, "ns1:set_relationship_value");
	case SOAP_TYPE_link_USCOREvalue:
		return soap_in_link_USCOREvalue(soap, NULL, NULL, "ns1:name_value");
	case SOAP_TYPE_ns1__user_USCOREdetail:
		return soap_in_ns1__user_USCOREdetail(soap, NULL, NULL, "ns1:user_detail");
	case SOAP_TYPE_ns1__contact_USCOREdetail:
		return soap_in_ns1__contact_USCOREdetail(soap, NULL, NULL, "ns1:contact_detail");
	case SOAP_TYPE_ns1__set_USCOREentries_USCOREdetail_USCOREresult:
		return soap_in_ns1__set_USCOREentries_USCOREdetail_USCOREresult(soap, NULL, NULL, "ns1:set_entries_detail_result");
	case SOAP_TYPE_ns1__get_USCOREentries_USCOREcount_USCOREresult:
		return soap_in_ns1__get_USCOREentries_USCOREcount_USCOREresult(soap, NULL, NULL, "ns1:get_entries_count_result");
	case SOAP_TYPE_name_USCOREvalue_USCORElists:
		return soap_in_name_USCOREvalue_USCORElists(soap, NULL, NULL, "ns1:name_value");
	case SOAP_TYPE_ns1__name_USCOREvalue_USCORElists_USCOREerror:
		return soap_in_ns1__name_USCOREvalue_USCORElists_USCOREerror(soap, NULL, NULL, "ns1:name_value_lists_error");
	case SOAP_TYPE_newsletter_USCORElist:
		return soap_in_newsletter_USCORElist(soap, NULL, NULL, "ns1:newsletter");
	case SOAP_TYPE_ns1__get_USCOREsubscription_USCORElists_USCOREresult:
		return soap_in_ns1__get_USCOREsubscription_USCORElists_USCOREresult(soap, NULL, NULL, "ns1:get_subscription_lists_result");
	case SOAP_TYPE_ns1__newsletter:
		return soap_in_ns1__newsletter(soap, NULL, NULL, "ns1:newsletter");
	case SOAP_TYPE_ns1__name_USCOREvalue_USCOREoperator:
		return soap_in_ns1__name_USCOREvalue_USCOREoperator(soap, NULL, NULL, "ns1:name_value_operator");
	case SOAP_TYPE_ns1__new_USCOREreturn_USCOREdocument_USCORErevision:
		return soap_in_ns1__new_USCOREreturn_USCOREdocument_USCORErevision(soap, NULL, NULL, "ns1:new_return_document_revision");
	case SOAP_TYPE_ns1__return_USCOREdocument_USCORErevision:
		return soap_in_ns1__return_USCOREdocument_USCORErevision(soap, NULL, NULL, "ns1:return_document_revision");
	case SOAP_TYPE_ns1__get_USCOREquick_USCOREsync_USCOREresult_USCOREencoded:
		return soap_in_ns1__get_USCOREquick_USCOREsync_USCOREresult_USCOREencoded(soap, NULL, NULL, "ns1:get_quick_sync_result_encoded");
	case SOAP_TYPE_ns1__get_USCOREsync_USCOREresult_USCOREencoded:
		return soap_in_ns1__get_USCOREsync_USCOREresult_USCOREencoded(soap, NULL, NULL, "ns1:get_sync_result_encoded");
	case SOAP_TYPE_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded:
		return soap_in_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded(soap, NULL, NULL, "ns1:get_entry_list_result_encoded");
	case SOAP_TYPE_ns1__document_USCORErevision:
		return soap_in_ns1__document_USCORErevision(soap, NULL, NULL, "ns1:document_revision");
	case SOAP_TYPE_ns1__set_USCORErelationship_USCORElist_USCOREresult:
		return soap_in_ns1__set_USCORErelationship_USCORElist_USCOREresult(soap, NULL, NULL, "ns1:set_relationship_list_result");
	case SOAP_TYPE_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult:
		return soap_in_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(soap, NULL, NULL, "ns1:new_set_relationship_list_result");
	case SOAP_TYPE_ns1__set_USCORErelationship_USCOREvalue:
		return soap_in_ns1__set_USCORErelationship_USCOREvalue(soap, NULL, NULL, "ns1:set_relationship_value");
	case SOAP_TYPE_ids_USCOREmods:
		return soap_in_ids_USCOREmods(soap, NULL, NULL, "ns1:id_mod");
	case SOAP_TYPE_ns1__get_USCORErelationships_USCOREresult:
		return soap_in_ns1__get_USCORErelationships_USCOREresult(soap, NULL, NULL, "ns1:get_relationships_result");
	case SOAP_TYPE_ns1__id_USCOREmod:
		return soap_in_ns1__id_USCOREmod(soap, NULL, NULL, "ns1:id_mod");
	case SOAP_TYPE_ns1__set_USCOREentries_USCOREresult:
		return soap_in_ns1__set_USCOREentries_USCOREresult(soap, NULL, NULL, "ns1:set_entries_result");
	case SOAP_TYPE_ns1__new_USCOREset_USCOREentries_USCOREresult:
		return soap_in_ns1__new_USCOREset_USCOREentries_USCOREresult(soap, NULL, NULL, "ns1:new_set_entries_result");
	case SOAP_TYPE_ns1__new_USCOREset_USCOREentry_USCOREresult:
		return soap_in_ns1__new_USCOREset_USCOREentry_USCOREresult(soap, NULL, NULL, "ns1:new_set_entry_result");
	case SOAP_TYPE_ns1__set_USCOREentry_USCOREresult:
		return soap_in_ns1__set_USCOREentry_USCOREresult(soap, NULL, NULL, "ns1:set_entry_result");
	case SOAP_TYPE_ns1__get_USCOREserver_USCOREinfo_USCOREresult:
		return soap_in_ns1__get_USCOREserver_USCOREinfo_USCOREresult(soap, NULL, NULL, "ns1:get_server_info_result");
	case SOAP_TYPE_ns1__get_USCOREentry_USCOREresult:
		return soap_in_ns1__get_USCOREentry_USCOREresult(soap, NULL, NULL, "ns1:get_entry_result");
	case SOAP_TYPE_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2:
		return soap_in_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2(soap, NULL, NULL, "ns1:get_entry_list_result_version2");
	case SOAP_TYPE_ns1__get_USCOREentry_USCORElist_USCOREresult:
		return soap_in_ns1__get_USCOREentry_USCORElist_USCOREresult(soap, NULL, NULL, "ns1:get_entry_list_result");
	case SOAP_TYPE_link_USCORElist:
		return soap_in_link_USCORElist(soap, NULL, NULL, "ns1:link_name_value");
	case SOAP_TYPE_ns1__return_USCOREsearch_USCOREresult:
		return soap_in_ns1__return_USCOREsearch_USCOREresult(soap, NULL, NULL, "ns1:return_search_result");
	case SOAP_TYPE_link_USCORElists:
		return soap_in_link_USCORElists(soap, NULL, NULL, "ns1:link_name_value");
	case SOAP_TYPE_entry_USCORElist:
		return soap_in_entry_USCORElist(soap, NULL, NULL, "ns1:entry_value");
	case SOAP_TYPE_ns1__get_USCOREentry_USCOREresult_USCOREversion2:
		return soap_in_ns1__get_USCOREentry_USCOREresult_USCOREversion2(soap, NULL, NULL, "ns1:get_entry_result_version2");
	case SOAP_TYPE_link_USCOREarray_USCORElist:
		return soap_in_link_USCOREarray_USCORElist(soap, NULL, NULL, "ns1:name_value");
	case SOAP_TYPE_ns1__link_USCOREname_USCOREvalue:
		return soap_in_ns1__link_USCOREname_USCOREvalue(soap, NULL, NULL, "ns1:link_name_value");
	case SOAP_TYPE_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray:
		return soap_in_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(soap, NULL, NULL, "ns1:link_name_to_fields_array");
	case SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult:
		return soap_in_ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult(soap, NULL, NULL, "ns1:get_mailmerge_document_result");
	case SOAP_TYPE_ns1__entry_USCOREvalue:
		return soap_in_ns1__entry_USCOREvalue(soap, NULL, NULL, "ns1:entry_value");
	case SOAP_TYPE_select_USCOREfields:
		return soap_in_select_USCOREfields(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ns1__module_USCORElist:
		return soap_in_ns1__module_USCORElist(soap, NULL, NULL, "ns1:module_list");
	case SOAP_TYPE_link_USCOREfield_USCORElist:
		return soap_in_link_USCOREfield_USCORElist(soap, NULL, NULL, "ns1:link_field");
	case SOAP_TYPE_ns1__new_USCOREmodule_USCOREfields:
		return soap_in_ns1__new_USCOREmodule_USCOREfields(soap, NULL, NULL, "ns1:new_module_fields");
	case SOAP_TYPE_field_USCORElist:
		return soap_in_field_USCORElist(soap, NULL, NULL, "ns1:field");
	case SOAP_TYPE_ns1__module_USCOREfields:
		return soap_in_ns1__module_USCOREfields(soap, NULL, NULL, "ns1:module_fields");
	case SOAP_TYPE_ns1__name_USCOREvalue:
		return soap_in_ns1__name_USCOREvalue(soap, NULL, NULL, "ns1:name_value");
	case SOAP_TYPE_ns1__link_USCOREfield:
		return soap_in_ns1__link_USCOREfield(soap, NULL, NULL, "ns1:link_field");
	case SOAP_TYPE_name_USCOREvalue_USCORElist:
		return soap_in_name_USCOREvalue_USCORElist(soap, NULL, NULL, "ns1:name_value");
	case SOAP_TYPE_ns1__field:
		return soap_in_ns1__field(soap, NULL, NULL, "ns1:field");
	case SOAP_TYPE_ns1__user_USCOREauth:
		return soap_in_ns1__user_USCOREauth(soap, NULL, NULL, "ns1:user_auth");
	case SOAP_TYPE_ns1__error_USCOREvalue:
		return soap_in_ns1__error_USCOREvalue(soap, NULL, NULL, "ns1:error_value");
	case SOAP_TYPE_ns1__return_USCOREnote_USCOREattachment:
		return soap_in_ns1__return_USCOREnote_USCOREattachment(soap, NULL, NULL, "ns1:return_note_attachment");
	case SOAP_TYPE_ns1__new_USCOREreturn_USCOREnote_USCOREattachment:
		return soap_in_ns1__new_USCOREreturn_USCOREnote_USCOREattachment(soap, NULL, NULL, "ns1:new_return_note_attachment");
	case SOAP_TYPE_ns1__new_USCOREnote_USCOREattachment:
		return soap_in_ns1__new_USCOREnote_USCOREattachment(soap, NULL, NULL, "ns1:new_note_attachment");
	case SOAP_TYPE_ns1__note_USCOREattachment:
		return soap_in_ns1__note_USCOREattachment(soap, NULL, NULL, "ns1:note_attachment");
	case SOAP_TYPE_PointerTons1__searchResponse:
		return soap_in_PointerTons1__searchResponse(soap, NULL, NULL, "ns1:searchResponse");
	case SOAP_TYPE_PointerTons1__user_USCORElistResponse:
		return soap_in_PointerTons1__user_USCORElistResponse(soap, NULL, NULL, "ns1:user_listResponse");
	case SOAP_TYPE_PointerTouser_USCOREdetail_USCOREarray:
		return soap_in_PointerTouser_USCOREdetail_USCOREarray(soap, NULL, NULL, "ns1:user_detail");
	case SOAP_TYPE_PointerTons1__get_USCOREcontact_USCORErelationshipsResponse:
		return soap_in_PointerTons1__get_USCOREcontact_USCORErelationshipsResponse(soap, NULL, NULL, "ns1:get_contact_relationshipsResponse");
	case SOAP_TYPE_PointerTons1__contact_USCOREby_USCOREemailResponse:
		return soap_in_PointerTons1__contact_USCOREby_USCOREemailResponse(soap, NULL, NULL, "ns1:contact_by_emailResponse");
	case SOAP_TYPE_PointerTocontact_USCOREdetail_USCOREarray:
		return soap_in_PointerTocontact_USCOREdetail_USCOREarray(soap, NULL, NULL, "ns1:contact_detail");
	case SOAP_TYPE_PointerTons1__get_USCOREattendee_USCORElistResponse:
		return soap_in_PointerTons1__get_USCOREattendee_USCORElistResponse(soap, NULL, NULL, "ns1:get_attendee_listResponse");
	case SOAP_TYPE_PointerTons1__get_USCOREmodified_USCOREentriesResponse:
		return soap_in_PointerTons1__get_USCOREmodified_USCOREentriesResponse(soap, NULL, NULL, "ns1:get_modified_entriesResponse");
	case SOAP_TYPE_PointerTons1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse:
		return soap_in_PointerTons1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse(soap, NULL, NULL, "ns1:sync_get_modified_relationshipsResponse");
	case SOAP_TYPE_PointerTons1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded:
		return soap_in_PointerTons1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded(soap, NULL, NULL, "ns1:get_entry_list_result_encoded");
	case SOAP_TYPE_PointerTons1__set_USCOREentries_USCOREdetailsResponse:
		return soap_in_PointerTons1__set_USCOREentries_USCOREdetailsResponse(soap, NULL, NULL, "ns1:set_entries_detailsResponse");
	case SOAP_TYPE_PointerTons1__set_USCOREentries_USCOREdetail_USCOREresult:
		return soap_in_PointerTons1__set_USCOREentries_USCOREdetail_USCOREresult(soap, NULL, NULL, "ns1:set_entries_detail_result");
	case SOAP_TYPE_PointerTons1__get_USCOREentries_USCOREcountResponse:
		return soap_in_PointerTons1__get_USCOREentries_USCOREcountResponse(soap, NULL, NULL, "ns1:get_entries_countResponse");
	case SOAP_TYPE_PointerTons1__get_USCOREentries_USCOREcount_USCOREresult:
		return soap_in_PointerTons1__get_USCOREentries_USCOREcount_USCOREresult(soap, NULL, NULL, "ns1:get_entries_count_result");
	case SOAP_TYPE_PointerTons1__set_USCOREcampaign_USCOREmergeResponse:
		return soap_in_PointerTons1__set_USCOREcampaign_USCOREmergeResponse(soap, NULL, NULL, "ns1:set_campaign_mergeResponse");
	case SOAP_TYPE_PointerTons1__get_USCOREdocument_USCORErevisionResponse:
		return soap_in_PointerTons1__get_USCOREdocument_USCORErevisionResponse(soap, NULL, NULL, "ns1:get_document_revisionResponse");
	case SOAP_TYPE_PointerTons1__return_USCOREdocument_USCORErevision:
		return soap_in_PointerTons1__return_USCOREdocument_USCORErevision(soap, NULL, NULL, "ns1:return_document_revision");
	case SOAP_TYPE_PointerTons1__get_USCOREmailmerge_USCOREdocument2Response:
		return soap_in_PointerTons1__get_USCOREmailmerge_USCOREdocument2Response(soap, NULL, NULL, "ns1:get_mailmerge_document2Response");
	case SOAP_TYPE_PointerTons1__get_USCOREmailmerge_USCOREdocument_USCOREresult:
		return soap_in_PointerTons1__get_USCOREmailmerge_USCOREdocument_USCOREresult(soap, NULL, NULL, "ns1:get_mailmerge_document_result");
	case SOAP_TYPE_PointerTons1__get_USCOREmailmerge_USCOREdocumentResponse:
		return soap_in_PointerTons1__get_USCOREmailmerge_USCOREdocumentResponse(soap, NULL, NULL, "ns1:get_mailmerge_documentResponse");
	case SOAP_TYPE_PointerTons1__get_USCOREsync_USCOREresult_USCOREencoded:
		return soap_in_PointerTons1__get_USCOREsync_USCOREresult_USCOREencoded(soap, NULL, NULL, "ns1:get_sync_result_encoded");
	case SOAP_TYPE_PointerTons1__search_USCOREby_USCOREmoduleResponse:
		return soap_in_PointerTons1__search_USCOREby_USCOREmoduleResponse(soap, NULL, NULL, "ns1:search_by_moduleResponse");
	case SOAP_TYPE_PointerTons1__set_USCOREdocument_USCORErevisionResponse:
		return soap_in_PointerTons1__set_USCOREdocument_USCORErevisionResponse(soap, NULL, NULL, "ns1:set_document_revisionResponse");
	case SOAP_TYPE_PointerTons1__set_USCORErelationshipsResponse:
		return soap_in_PointerTons1__set_USCORErelationshipsResponse(soap, NULL, NULL, "ns1:set_relationshipsResponse");
	case SOAP_TYPE_PointerToset_USCORErelationship_USCORElist:
		return soap_in_PointerToset_USCORErelationship_USCORElist(soap, NULL, NULL, "ns1:set_relationship_value");
	case SOAP_TYPE_PointerTons1__set_USCORErelationship_USCORElist_USCOREresult:
		return soap_in_PointerTons1__set_USCORErelationship_USCORElist_USCOREresult(soap, NULL, NULL, "ns1:set_relationship_list_result");
	case SOAP_TYPE_PointerTons1__set_USCORErelationshipResponse:
		return soap_in_PointerTons1__set_USCORErelationshipResponse(soap, NULL, NULL, "ns1:set_relationshipResponse");
	case SOAP_TYPE_PointerTons1__get_USCORErelationshipsResponse:
		return soap_in_PointerTons1__get_USCORErelationshipsResponse(soap, NULL, NULL, "ns1:get_relationshipsResponse");
	case SOAP_TYPE_PointerTons1__get_USCORErelationships_USCOREresult:
		return soap_in_PointerTons1__get_USCORErelationships_USCOREresult(soap, NULL, NULL, "ns1:get_relationships_result");
	case SOAP_TYPE_PointerTons1__update_USCOREportal_USCOREuserResponse:
		return soap_in_PointerTons1__update_USCOREportal_USCOREuserResponse(soap, NULL, NULL, "ns1:update_portal_userResponse");
	case SOAP_TYPE_PointerTons1__get_USCOREavailable_USCOREmodulesResponse:
		return soap_in_PointerTons1__get_USCOREavailable_USCOREmodulesResponse(soap, NULL, NULL, "ns1:get_available_modulesResponse");
	case SOAP_TYPE_PointerTons1__module_USCORElist:
		return soap_in_PointerTons1__module_USCORElist(soap, NULL, NULL, "ns1:module_list");
	case SOAP_TYPE_PointerTons1__get_USCOREmodule_USCOREfieldsResponse:
		return soap_in_PointerTons1__get_USCOREmodule_USCOREfieldsResponse(soap, NULL, NULL, "ns1:get_module_fieldsResponse");
	case SOAP_TYPE_PointerTons1__module_USCOREfields:
		return soap_in_PointerTons1__module_USCOREfields(soap, NULL, NULL, "ns1:module_fields");
	case SOAP_TYPE_PointerTons1__logoutResponse:
		return soap_in_PointerTons1__logoutResponse(soap, NULL, NULL, "ns1:logoutResponse");
	case SOAP_TYPE_PointerTons1__get_USCORErelated_USCOREnotesResponse:
		return soap_in_PointerTons1__get_USCORErelated_USCOREnotesResponse(soap, NULL, NULL, "ns1:get_related_notesResponse");
	case SOAP_TYPE_PointerTons1__relate_USCOREnote_USCOREto_USCOREmoduleResponse:
		return soap_in_PointerTons1__relate_USCOREnote_USCOREto_USCOREmoduleResponse(soap, NULL, NULL, "ns1:relate_note_to_moduleResponse");
	case SOAP_TYPE_PointerTons1__get_USCOREnote_USCOREattachmentResponse:
		return soap_in_PointerTons1__get_USCOREnote_USCOREattachmentResponse(soap, NULL, NULL, "ns1:get_note_attachmentResponse");
	case SOAP_TYPE_PointerTons1__return_USCOREnote_USCOREattachment:
		return soap_in_PointerTons1__return_USCOREnote_USCOREattachment(soap, NULL, NULL, "ns1:return_note_attachment");
	case SOAP_TYPE_PointerTons1__set_USCOREnote_USCOREattachmentResponse:
		return soap_in_PointerTons1__set_USCOREnote_USCOREattachmentResponse(soap, NULL, NULL, "ns1:set_note_attachmentResponse");
	case SOAP_TYPE_PointerTons1__set_USCOREentriesResponse:
		return soap_in_PointerTons1__set_USCOREentriesResponse(soap, NULL, NULL, "ns1:set_entriesResponse");
	case SOAP_TYPE_PointerTons1__set_USCOREentries_USCOREresult:
		return soap_in_PointerTons1__set_USCOREentries_USCOREresult(soap, NULL, NULL, "ns1:set_entries_result");
	case SOAP_TYPE_PointerTons1__set_USCOREentryResponse:
		return soap_in_PointerTons1__set_USCOREentryResponse(soap, NULL, NULL, "ns1:set_entryResponse");
	case SOAP_TYPE_PointerTons1__get_USCOREentriesResponse:
		return soap_in_PointerTons1__get_USCOREentriesResponse(soap, NULL, NULL, "ns1:get_entriesResponse");
	case SOAP_TYPE_PointerTons1__get_USCOREentryResponse:
		return soap_in_PointerTons1__get_USCOREentryResponse(soap, NULL, NULL, "ns1:get_entryResponse");
	case SOAP_TYPE_PointerTons1__get_USCOREentry_USCOREresult:
		return soap_in_PointerTons1__get_USCOREentry_USCOREresult(soap, NULL, NULL, "ns1:get_entry_result");
	case SOAP_TYPE_PointerTons1__get_USCOREentry_USCORElistResponse:
		return soap_in_PointerTons1__get_USCOREentry_USCORElistResponse(soap, NULL, NULL, "ns1:get_entry_listResponse");
	case SOAP_TYPE_PointerTons1__get_USCOREentry_USCORElist_USCOREresult:
		return soap_in_PointerTons1__get_USCOREentry_USCORElist_USCOREresult(soap, NULL, NULL, "ns1:get_entry_list_result");
	case SOAP_TYPE_PointerTons1__loginResponse:
		return soap_in_PointerTons1__loginResponse(soap, NULL, NULL, "ns1:loginResponse");
	case SOAP_TYPE_PointerTons1__user_USCOREauth:
		return soap_in_PointerTons1__user_USCOREauth(soap, NULL, NULL, "ns1:user_auth");
	case SOAP_TYPE_PointerTons1__set_USCOREentry_USCOREresult:
		return soap_in_PointerTons1__set_USCOREentry_USCOREresult(soap, NULL, NULL, "ns1:set_entry_result");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerToPointerTons1__user_USCOREdetail:
		return soap_in_PointerToPointerTons1__user_USCOREdetail(soap, NULL, NULL, "ns1:user_detail");
	case SOAP_TYPE_PointerTons1__user_USCOREdetail:
		return soap_in_PointerTons1__user_USCOREdetail(soap, NULL, NULL, "ns1:user_detail");
	case SOAP_TYPE_PointerToPointerTons1__contact_USCOREdetail:
		return soap_in_PointerToPointerTons1__contact_USCOREdetail(soap, NULL, NULL, "ns1:contact_detail");
	case SOAP_TYPE_PointerTons1__contact_USCOREdetail:
		return soap_in_PointerTons1__contact_USCOREdetail(soap, NULL, NULL, "ns1:contact_detail");
	case SOAP_TYPE_PointerToPointerTons1__newsletter:
		return soap_in_PointerToPointerTons1__newsletter(soap, NULL, NULL, "ns1:newsletter");
	case SOAP_TYPE_PointerTons1__newsletter:
		return soap_in_PointerTons1__newsletter(soap, NULL, NULL, "ns1:newsletter");
	case SOAP_TYPE_PointerToPointerTons1__name_USCOREvalue_USCOREoperator:
		return soap_in_PointerToPointerTons1__name_USCOREvalue_USCOREoperator(soap, NULL, NULL, "ns1:name_value_operator");
	case SOAP_TYPE_PointerTons1__name_USCOREvalue_USCOREoperator:
		return soap_in_PointerTons1__name_USCOREvalue_USCOREoperator(soap, NULL, NULL, "ns1:name_value_operator");
	case SOAP_TYPE_PointerToPointerToselect_USCOREfields:
		return soap_in_PointerToPointerToselect_USCOREfields(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerToPointerTons1__set_USCORErelationship_USCOREvalue:
		return soap_in_PointerToPointerTons1__set_USCORErelationship_USCOREvalue(soap, NULL, NULL, "ns1:set_relationship_value");
	case SOAP_TYPE_PointerTons1__set_USCORErelationship_USCOREvalue:
		return soap_in_PointerTons1__set_USCORErelationship_USCOREvalue(soap, NULL, NULL, "ns1:set_relationship_value");
	case SOAP_TYPE_PointerToPointerTons1__id_USCOREmod:
		return soap_in_PointerToPointerTons1__id_USCOREmod(soap, NULL, NULL, "ns1:id_mod");
	case SOAP_TYPE_PointerTons1__id_USCOREmod:
		return soap_in_PointerTons1__id_USCOREmod(soap, NULL, NULL, "ns1:id_mod");
	case SOAP_TYPE_PointerToPointerTolink_USCORElist:
		return soap_in_PointerToPointerTolink_USCORElist(soap, NULL, NULL, "ns1:link_name_value");
	case SOAP_TYPE_PointerToPointerTons1__link_USCOREname_USCOREvalue:
		return soap_in_PointerToPointerTons1__link_USCOREname_USCOREvalue(soap, NULL, NULL, "ns1:link_name_value");
	case SOAP_TYPE_PointerTons1__link_USCOREname_USCOREvalue:
		return soap_in_PointerTons1__link_USCOREname_USCOREvalue(soap, NULL, NULL, "ns1:link_name_value");
	case SOAP_TYPE_PointerToPointerTolink_USCOREvalue:
		return soap_in_PointerToPointerTolink_USCOREvalue(soap, NULL, NULL, "ns1:name_value");
	case SOAP_TYPE_PointerTolink_USCOREvalue:
		return soap_in_PointerTolink_USCOREvalue(soap, NULL, NULL, "ns1:name_value");
	case SOAP_TYPE_PointerToPointerTons1__entry_USCOREvalue:
		return soap_in_PointerToPointerTons1__entry_USCOREvalue(soap, NULL, NULL, "ns1:entry_value");
	case SOAP_TYPE_PointerTons1__entry_USCOREvalue:
		return soap_in_PointerTons1__entry_USCOREvalue(soap, NULL, NULL, "ns1:entry_value");
	case SOAP_TYPE_PointerTostring:
		return soap_in_PointerTostring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerToPointerToname_USCOREvalue_USCORElist:
		return soap_in_PointerToPointerToname_USCOREvalue_USCORElist(soap, NULL, NULL, "ns1:name_value");
	case SOAP_TYPE_PointerToPointerTons1__name_USCOREvalue:
		return soap_in_PointerToPointerTons1__name_USCOREvalue(soap, NULL, NULL, "ns1:name_value");
	case SOAP_TYPE_PointerTons1__name_USCOREvalue:
		return soap_in_PointerTons1__name_USCOREvalue(soap, NULL, NULL, "ns1:name_value");
	case SOAP_TYPE_PointerToPointerTons1__link_USCOREfield:
		return soap_in_PointerToPointerTons1__link_USCOREfield(soap, NULL, NULL, "ns1:link_field");
	case SOAP_TYPE_PointerTons1__link_USCOREfield:
		return soap_in_PointerTons1__link_USCOREfield(soap, NULL, NULL, "ns1:link_field");
	case SOAP_TYPE_PointerToPointerTons1__field:
		return soap_in_PointerToPointerTons1__field(soap, NULL, NULL, "ns1:field");
	case SOAP_TYPE_PointerTons1__field:
		return soap_in_PointerTons1__field(soap, NULL, NULL, "ns1:field");
	case SOAP_TYPE_PointerToname_USCOREvalue_USCORElists:
		return soap_in_PointerToname_USCOREvalue_USCORElists(soap, NULL, NULL, "ns1:name_value");
	case SOAP_TYPE_PointerTonewsletter_USCORElist:
		return soap_in_PointerTonewsletter_USCORElist(soap, NULL, NULL, "ns1:newsletter");
	case SOAP_TYPE_PointerTons1__document_USCORErevision:
		return soap_in_PointerTons1__document_USCORErevision(soap, NULL, NULL, "ns1:document_revision");
	case SOAP_TYPE_PointerToids_USCOREmods:
		return soap_in_PointerToids_USCOREmods(soap, NULL, NULL, "ns1:id_mod");
	case SOAP_TYPE_PointerTolink_USCORElist:
		return soap_in_PointerTolink_USCORElist(soap, NULL, NULL, "ns1:link_name_value");
	case SOAP_TYPE_PointerTolink_USCORElists:
		return soap_in_PointerTolink_USCORElists(soap, NULL, NULL, "ns1:link_name_value");
	case SOAP_TYPE_PointerToentry_USCORElist:
		return soap_in_PointerToentry_USCORElist(soap, NULL, NULL, "ns1:entry_value");
	case SOAP_TYPE_PointerTolink_USCOREarray_USCORElist:
		return soap_in_PointerTolink_USCOREarray_USCORElist(soap, NULL, NULL, "ns1:name_value");
	case SOAP_TYPE_PointerToselect_USCOREfields:
		return soap_in_PointerToselect_USCOREfields(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTolink_USCOREfield_USCORElist:
		return soap_in_PointerTolink_USCOREfield_USCORElist(soap, NULL, NULL, "ns1:link_field");
	case SOAP_TYPE_PointerTofield_USCORElist:
		return soap_in_PointerTofield_USCORElist(soap, NULL, NULL, "ns1:field");
	case SOAP_TYPE_PointerToname_USCOREvalue_USCORElist:
		return soap_in_PointerToname_USCOREvalue_USCORElist(soap, NULL, NULL, "ns1:name_value");
	case SOAP_TYPE_PointerTons1__error_USCOREvalue:
		return soap_in_PointerTons1__error_USCOREvalue(soap, NULL, NULL, "ns1:error_value");
	case SOAP_TYPE_PointerTons1__note_USCOREattachment:
		return soap_in_PointerTons1__note_USCOREattachment(soap, NULL, NULL, "ns1:note_attachment");
	case SOAP_TYPE_PointerTons1__new_USCOREnote_USCOREattachment:
		return soap_in_PointerTons1__new_USCOREnote_USCOREattachment(soap, NULL, NULL, "ns1:new_note_attachment");
	case SOAP_TYPE_xsd__date:
	{	char **s;
		s = soap_in_xsd__date(soap, NULL, NULL, "xsd:date");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:create_case"))
		{	*type = SOAP_TYPE_ns1__create_USCOREcase;
			return soap_in_ns1__create_USCOREcase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:create_caseResponse"))
		{	*type = SOAP_TYPE_ns1__create_USCOREcaseResponse;
			return soap_in_ns1__create_USCOREcaseResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:create_opportunity"))
		{	*type = SOAP_TYPE_ns1__create_USCOREopportunity;
			return soap_in_ns1__create_USCOREopportunity(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:create_opportunityResponse"))
		{	*type = SOAP_TYPE_ns1__create_USCOREopportunityResponse;
			return soap_in_ns1__create_USCOREopportunityResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:create_account"))
		{	*type = SOAP_TYPE_ns1__create_USCOREaccount;
			return soap_in_ns1__create_USCOREaccount(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:create_accountResponse"))
		{	*type = SOAP_TYPE_ns1__create_USCOREaccountResponse;
			return soap_in_ns1__create_USCOREaccountResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:create_lead"))
		{	*type = SOAP_TYPE_ns1__create_USCORElead;
			return soap_in_ns1__create_USCORElead(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:create_leadResponse"))
		{	*type = SOAP_TYPE_ns1__create_USCOREleadResponse;
			return soap_in_ns1__create_USCOREleadResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:create_contact"))
		{	*type = SOAP_TYPE_ns1__create_USCOREcontact;
			return soap_in_ns1__create_USCOREcontact(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:create_contactResponse"))
		{	*type = SOAP_TYPE_ns1__create_USCOREcontactResponse;
			return soap_in_ns1__create_USCOREcontactResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:track_email"))
		{	*type = SOAP_TYPE_ns1__track_USCOREemail;
			return soap_in_ns1__track_USCOREemail(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:track_emailResponse"))
		{	*type = SOAP_TYPE_ns1__track_USCOREemailResponse;
			return soap_in_ns1__track_USCOREemailResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:search"))
		{	*type = SOAP_TYPE_ns1__search;
			return soap_in_ns1__search(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:searchResponse"))
		{	*type = SOAP_TYPE_ns1__searchResponse;
			return soap_in_ns1__searchResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:user_list"))
		{	*type = SOAP_TYPE_ns1__user_USCORElist;
			return soap_in_ns1__user_USCORElist(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:user_listResponse"))
		{	*type = SOAP_TYPE_ns1__user_USCORElistResponse;
			return soap_in_ns1__user_USCORElistResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_contact_relationships"))
		{	*type = SOAP_TYPE_ns1__get_USCOREcontact_USCORErelationships;
			return soap_in_ns1__get_USCOREcontact_USCORErelationships(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_contact_relationshipsResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREcontact_USCORErelationshipsResponse;
			return soap_in_ns1__get_USCOREcontact_USCORErelationshipsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:contact_by_email"))
		{	*type = SOAP_TYPE_ns1__contact_USCOREby_USCOREemail;
			return soap_in_ns1__contact_USCOREby_USCOREemail(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:contact_by_emailResponse"))
		{	*type = SOAP_TYPE_ns1__contact_USCOREby_USCOREemailResponse;
			return soap_in_ns1__contact_USCOREby_USCOREemailResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:end_session"))
		{	*type = SOAP_TYPE_ns1__end_USCOREsession;
			return soap_in_ns1__end_USCOREsession(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:end_sessionResponse"))
		{	*type = SOAP_TYPE_ns1__end_USCOREsessionResponse;
			return soap_in_ns1__end_USCOREsessionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:create_session"))
		{	*type = SOAP_TYPE_ns1__create_USCOREsession;
			return soap_in_ns1__create_USCOREsession(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:create_sessionResponse"))
		{	*type = SOAP_TYPE_ns1__create_USCOREsessionResponse;
			return soap_in_ns1__create_USCOREsessionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_attendee_list"))
		{	*type = SOAP_TYPE_ns1__get_USCOREattendee_USCORElist;
			return soap_in_ns1__get_USCOREattendee_USCORElist(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_attendee_listResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREattendee_USCORElistResponse;
			return soap_in_ns1__get_USCOREattendee_USCORElistResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_modified_entries"))
		{	*type = SOAP_TYPE_ns1__get_USCOREmodified_USCOREentries;
			return soap_in_ns1__get_USCOREmodified_USCOREentries(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_modified_entriesResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREmodified_USCOREentriesResponse;
			return soap_in_ns1__get_USCOREmodified_USCOREentriesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:sync_get_modified_relationships"))
		{	*type = SOAP_TYPE_ns1__sync_USCOREget_USCOREmodified_USCORErelationships;
			return soap_in_ns1__sync_USCOREget_USCOREmodified_USCORErelationships(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:sync_get_modified_relationshipsResponse"))
		{	*type = SOAP_TYPE_ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse;
			return soap_in_ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:set_entries_details"))
		{	*type = SOAP_TYPE_ns1__set_USCOREentries_USCOREdetails;
			return soap_in_ns1__set_USCOREentries_USCOREdetails(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:set_entries_detailsResponse"))
		{	*type = SOAP_TYPE_ns1__set_USCOREentries_USCOREdetailsResponse;
			return soap_in_ns1__set_USCOREentries_USCOREdetailsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_entries_count"))
		{	*type = SOAP_TYPE_ns1__get_USCOREentries_USCOREcount;
			return soap_in_ns1__get_USCOREentries_USCOREcount(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_entries_countResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREentries_USCOREcountResponse;
			return soap_in_ns1__get_USCOREentries_USCOREcountResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:set_campaign_merge"))
		{	*type = SOAP_TYPE_ns1__set_USCOREcampaign_USCOREmerge;
			return soap_in_ns1__set_USCOREcampaign_USCOREmerge(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:set_campaign_mergeResponse"))
		{	*type = SOAP_TYPE_ns1__set_USCOREcampaign_USCOREmergeResponse;
			return soap_in_ns1__set_USCOREcampaign_USCOREmergeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_document_revision"))
		{	*type = SOAP_TYPE_ns1__get_USCOREdocument_USCORErevision;
			return soap_in_ns1__get_USCOREdocument_USCORErevision(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_document_revisionResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREdocument_USCORErevisionResponse;
			return soap_in_ns1__get_USCOREdocument_USCORErevisionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_mailmerge_document2"))
		{	*type = SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocument2;
			return soap_in_ns1__get_USCOREmailmerge_USCOREdocument2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_mailmerge_document2Response"))
		{	*type = SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocument2Response;
			return soap_in_ns1__get_USCOREmailmerge_USCOREdocument2Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_mailmerge_document"))
		{	*type = SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocument;
			return soap_in_ns1__get_USCOREmailmerge_USCOREdocument(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_mailmerge_documentResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocumentResponse;
			return soap_in_ns1__get_USCOREmailmerge_USCOREdocumentResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:search_by_module"))
		{	*type = SOAP_TYPE_ns1__search_USCOREby_USCOREmodule;
			return soap_in_ns1__search_USCOREby_USCOREmodule(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:search_by_moduleResponse"))
		{	*type = SOAP_TYPE_ns1__search_USCOREby_USCOREmoduleResponse;
			return soap_in_ns1__search_USCOREby_USCOREmoduleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:set_document_revision"))
		{	*type = SOAP_TYPE_ns1__set_USCOREdocument_USCORErevision;
			return soap_in_ns1__set_USCOREdocument_USCORErevision(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:set_document_revisionResponse"))
		{	*type = SOAP_TYPE_ns1__set_USCOREdocument_USCORErevisionResponse;
			return soap_in_ns1__set_USCOREdocument_USCORErevisionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:set_relationships"))
		{	*type = SOAP_TYPE_ns1__set_USCORErelationships;
			return soap_in_ns1__set_USCORErelationships(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:set_relationshipsResponse"))
		{	*type = SOAP_TYPE_ns1__set_USCORErelationshipsResponse;
			return soap_in_ns1__set_USCORErelationshipsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:set_relationship"))
		{	*type = SOAP_TYPE_ns1__set_USCORErelationship;
			return soap_in_ns1__set_USCORErelationship(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:set_relationshipResponse"))
		{	*type = SOAP_TYPE_ns1__set_USCORErelationshipResponse;
			return soap_in_ns1__set_USCORErelationshipResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_relationships"))
		{	*type = SOAP_TYPE_ns1__get_USCORErelationships;
			return soap_in_ns1__get_USCORErelationships(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_relationshipsResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCORErelationshipsResponse;
			return soap_in_ns1__get_USCORErelationshipsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_server_version"))
		{	*type = SOAP_TYPE_ns1__get_USCOREserver_USCOREversion;
			return soap_in_ns1__get_USCOREserver_USCOREversion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_server_versionResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREserver_USCOREversionResponse;
			return soap_in_ns1__get_USCOREserver_USCOREversionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_sugar_flavor"))
		{	*type = SOAP_TYPE_ns1__get_USCOREsugar_USCOREflavor;
			return soap_in_ns1__get_USCOREsugar_USCOREflavor(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_sugar_flavorResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREsugar_USCOREflavorResponse;
			return soap_in_ns1__get_USCOREsugar_USCOREflavorResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_gmt_time"))
		{	*type = SOAP_TYPE_ns1__get_USCOREgmt_USCOREtime;
			return soap_in_ns1__get_USCOREgmt_USCOREtime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_gmt_timeResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREgmt_USCOREtimeResponse;
			return soap_in_ns1__get_USCOREgmt_USCOREtimeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_server_time"))
		{	*type = SOAP_TYPE_ns1__get_USCOREserver_USCOREtime;
			return soap_in_ns1__get_USCOREserver_USCOREtime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_server_timeResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREserver_USCOREtimeResponse;
			return soap_in_ns1__get_USCOREserver_USCOREtimeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_user_team_id"))
		{	*type = SOAP_TYPE_ns1__get_USCOREuser_USCOREteam_USCOREid;
			return soap_in_ns1__get_USCOREuser_USCOREteam_USCOREid(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_user_team_idResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREuser_USCOREteam_USCOREidResponse;
			return soap_in_ns1__get_USCOREuser_USCOREteam_USCOREidResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_user_id"))
		{	*type = SOAP_TYPE_ns1__get_USCOREuser_USCOREid;
			return soap_in_ns1__get_USCOREuser_USCOREid(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_user_idResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREuser_USCOREidResponse;
			return soap_in_ns1__get_USCOREuser_USCOREidResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:update_portal_user"))
		{	*type = SOAP_TYPE_ns1__update_USCOREportal_USCOREuser;
			return soap_in_ns1__update_USCOREportal_USCOREuser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:update_portal_userResponse"))
		{	*type = SOAP_TYPE_ns1__update_USCOREportal_USCOREuserResponse;
			return soap_in_ns1__update_USCOREportal_USCOREuserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_available_modules"))
		{	*type = SOAP_TYPE_ns1__get_USCOREavailable_USCOREmodules;
			return soap_in_ns1__get_USCOREavailable_USCOREmodules(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_available_modulesResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREavailable_USCOREmodulesResponse;
			return soap_in_ns1__get_USCOREavailable_USCOREmodulesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_module_fields"))
		{	*type = SOAP_TYPE_ns1__get_USCOREmodule_USCOREfields;
			return soap_in_ns1__get_USCOREmodule_USCOREfields(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_module_fieldsResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREmodule_USCOREfieldsResponse;
			return soap_in_ns1__get_USCOREmodule_USCOREfieldsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:logout"))
		{	*type = SOAP_TYPE_ns1__logout;
			return soap_in_ns1__logout(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:logoutResponse"))
		{	*type = SOAP_TYPE_ns1__logoutResponse;
			return soap_in_ns1__logoutResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_related_notes"))
		{	*type = SOAP_TYPE_ns1__get_USCORErelated_USCOREnotes;
			return soap_in_ns1__get_USCORErelated_USCOREnotes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_related_notesResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCORErelated_USCOREnotesResponse;
			return soap_in_ns1__get_USCORErelated_USCOREnotesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:relate_note_to_module"))
		{	*type = SOAP_TYPE_ns1__relate_USCOREnote_USCOREto_USCOREmodule;
			return soap_in_ns1__relate_USCOREnote_USCOREto_USCOREmodule(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:relate_note_to_moduleResponse"))
		{	*type = SOAP_TYPE_ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse;
			return soap_in_ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_note_attachment"))
		{	*type = SOAP_TYPE_ns1__get_USCOREnote_USCOREattachment;
			return soap_in_ns1__get_USCOREnote_USCOREattachment(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_note_attachmentResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREnote_USCOREattachmentResponse;
			return soap_in_ns1__get_USCOREnote_USCOREattachmentResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:set_note_attachment"))
		{	*type = SOAP_TYPE_ns1__set_USCOREnote_USCOREattachment;
			return soap_in_ns1__set_USCOREnote_USCOREattachment(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:set_note_attachmentResponse"))
		{	*type = SOAP_TYPE_ns1__set_USCOREnote_USCOREattachmentResponse;
			return soap_in_ns1__set_USCOREnote_USCOREattachmentResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:set_entries"))
		{	*type = SOAP_TYPE_ns1__set_USCOREentries;
			return soap_in_ns1__set_USCOREentries(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:set_entriesResponse"))
		{	*type = SOAP_TYPE_ns1__set_USCOREentriesResponse;
			return soap_in_ns1__set_USCOREentriesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:set_entry"))
		{	*type = SOAP_TYPE_ns1__set_USCOREentry;
			return soap_in_ns1__set_USCOREentry(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:set_entryResponse"))
		{	*type = SOAP_TYPE_ns1__set_USCOREentryResponse;
			return soap_in_ns1__set_USCOREentryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_entries"))
		{	*type = SOAP_TYPE_ns1__get_USCOREentries;
			return soap_in_ns1__get_USCOREentries(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_entriesResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREentriesResponse;
			return soap_in_ns1__get_USCOREentriesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_entry"))
		{	*type = SOAP_TYPE_ns1__get_USCOREentry;
			return soap_in_ns1__get_USCOREentry(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_entryResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREentryResponse;
			return soap_in_ns1__get_USCOREentryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_entry_list"))
		{	*type = SOAP_TYPE_ns1__get_USCOREentry_USCORElist;
			return soap_in_ns1__get_USCOREentry_USCORElist(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_entry_listResponse"))
		{	*type = SOAP_TYPE_ns1__get_USCOREentry_USCORElistResponse;
			return soap_in_ns1__get_USCOREentry_USCORElistResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:seamless_login"))
		{	*type = SOAP_TYPE_ns1__seamless_USCORElogin;
			return soap_in_ns1__seamless_USCORElogin(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:seamless_loginResponse"))
		{	*type = SOAP_TYPE_ns1__seamless_USCOREloginResponse;
			return soap_in_ns1__seamless_USCOREloginResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:is_loopback"))
		{	*type = SOAP_TYPE_ns1__is_USCOREloopback;
			return soap_in_ns1__is_USCOREloopback(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:is_loopbackResponse"))
		{	*type = SOAP_TYPE_ns1__is_USCOREloopbackResponse;
			return soap_in_ns1__is_USCOREloopbackResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:login"))
		{	*type = SOAP_TYPE_ns1__login;
			return soap_in_ns1__login(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:loginResponse"))
		{	*type = SOAP_TYPE_ns1__loginResponse;
			return soap_in_ns1__loginResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:is_user_admin"))
		{	*type = SOAP_TYPE_ns1__is_USCOREuser_USCOREadmin;
			return soap_in_ns1__is_USCOREuser_USCOREadmin(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:is_user_adminResponse"))
		{	*type = SOAP_TYPE_ns1__is_USCOREuser_USCOREadminResponse;
			return soap_in_ns1__is_USCOREuser_USCOREadminResponse(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:user_detail"))
		{	*type = SOAP_TYPE_user_USCOREdetail_USCOREarray;
			return soap_in_user_USCOREdetail_USCOREarray(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:contact_detail"))
		{	*type = SOAP_TYPE_contact_USCOREdetail_USCOREarray;
			return soap_in_contact_USCOREdetail_USCOREarray(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "xsd:string"))
		{	*type = SOAP_TYPE_str_USCOREarray;
			return soap_in_str_USCOREarray(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:name_value_operator"))
		{	*type = SOAP_TYPE_name_USCOREvalue_USCOREoperator_USCORElist;
			return soap_in_name_USCOREvalue_USCOREoperator_USCORElist(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "xsd:string"))
		{	*type = SOAP_TYPE_new_USCOREset_USCORErelationhip_USCOREids;
			return soap_in_new_USCOREset_USCORErelationhip_USCOREids(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:set_relationship_value"))
		{	*type = SOAP_TYPE_set_USCORErelationship_USCORElist;
			return soap_in_set_USCORErelationship_USCORElist(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:name_value"))
		{	*type = SOAP_TYPE_link_USCOREvalue;
			return soap_in_link_USCOREvalue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:user_detail"))
		{	*type = SOAP_TYPE_ns1__user_USCOREdetail;
			return soap_in_ns1__user_USCOREdetail(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:contact_detail"))
		{	*type = SOAP_TYPE_ns1__contact_USCOREdetail;
			return soap_in_ns1__contact_USCOREdetail(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:set_entries_detail_result"))
		{	*type = SOAP_TYPE_ns1__set_USCOREentries_USCOREdetail_USCOREresult;
			return soap_in_ns1__set_USCOREentries_USCOREdetail_USCOREresult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_entries_count_result"))
		{	*type = SOAP_TYPE_ns1__get_USCOREentries_USCOREcount_USCOREresult;
			return soap_in_ns1__get_USCOREentries_USCOREcount_USCOREresult(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:name_value"))
		{	*type = SOAP_TYPE_name_USCOREvalue_USCORElists;
			return soap_in_name_USCOREvalue_USCORElists(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:name_value_lists_error"))
		{	*type = SOAP_TYPE_ns1__name_USCOREvalue_USCORElists_USCOREerror;
			return soap_in_ns1__name_USCOREvalue_USCORElists_USCOREerror(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:newsletter"))
		{	*type = SOAP_TYPE_newsletter_USCORElist;
			return soap_in_newsletter_USCORElist(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_subscription_lists_result"))
		{	*type = SOAP_TYPE_ns1__get_USCOREsubscription_USCORElists_USCOREresult;
			return soap_in_ns1__get_USCOREsubscription_USCORElists_USCOREresult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:newsletter"))
		{	*type = SOAP_TYPE_ns1__newsletter;
			return soap_in_ns1__newsletter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:name_value_operator"))
		{	*type = SOAP_TYPE_ns1__name_USCOREvalue_USCOREoperator;
			return soap_in_ns1__name_USCOREvalue_USCOREoperator(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:new_return_document_revision"))
		{	*type = SOAP_TYPE_ns1__new_USCOREreturn_USCOREdocument_USCORErevision;
			return soap_in_ns1__new_USCOREreturn_USCOREdocument_USCORErevision(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:return_document_revision"))
		{	*type = SOAP_TYPE_ns1__return_USCOREdocument_USCORErevision;
			return soap_in_ns1__return_USCOREdocument_USCORErevision(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_quick_sync_result_encoded"))
		{	*type = SOAP_TYPE_ns1__get_USCOREquick_USCOREsync_USCOREresult_USCOREencoded;
			return soap_in_ns1__get_USCOREquick_USCOREsync_USCOREresult_USCOREencoded(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_sync_result_encoded"))
		{	*type = SOAP_TYPE_ns1__get_USCOREsync_USCOREresult_USCOREencoded;
			return soap_in_ns1__get_USCOREsync_USCOREresult_USCOREencoded(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_entry_list_result_encoded"))
		{	*type = SOAP_TYPE_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded;
			return soap_in_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:document_revision"))
		{	*type = SOAP_TYPE_ns1__document_USCORErevision;
			return soap_in_ns1__document_USCORErevision(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:set_relationship_list_result"))
		{	*type = SOAP_TYPE_ns1__set_USCORErelationship_USCORElist_USCOREresult;
			return soap_in_ns1__set_USCORErelationship_USCORElist_USCOREresult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:new_set_relationship_list_result"))
		{	*type = SOAP_TYPE_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult;
			return soap_in_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:set_relationship_value"))
		{	*type = SOAP_TYPE_ns1__set_USCORErelationship_USCOREvalue;
			return soap_in_ns1__set_USCORErelationship_USCOREvalue(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:id_mod"))
		{	*type = SOAP_TYPE_ids_USCOREmods;
			return soap_in_ids_USCOREmods(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_relationships_result"))
		{	*type = SOAP_TYPE_ns1__get_USCORErelationships_USCOREresult;
			return soap_in_ns1__get_USCORErelationships_USCOREresult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:id_mod"))
		{	*type = SOAP_TYPE_ns1__id_USCOREmod;
			return soap_in_ns1__id_USCOREmod(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:set_entries_result"))
		{	*type = SOAP_TYPE_ns1__set_USCOREentries_USCOREresult;
			return soap_in_ns1__set_USCOREentries_USCOREresult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:new_set_entries_result"))
		{	*type = SOAP_TYPE_ns1__new_USCOREset_USCOREentries_USCOREresult;
			return soap_in_ns1__new_USCOREset_USCOREentries_USCOREresult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:new_set_entry_result"))
		{	*type = SOAP_TYPE_ns1__new_USCOREset_USCOREentry_USCOREresult;
			return soap_in_ns1__new_USCOREset_USCOREentry_USCOREresult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:set_entry_result"))
		{	*type = SOAP_TYPE_ns1__set_USCOREentry_USCOREresult;
			return soap_in_ns1__set_USCOREentry_USCOREresult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_server_info_result"))
		{	*type = SOAP_TYPE_ns1__get_USCOREserver_USCOREinfo_USCOREresult;
			return soap_in_ns1__get_USCOREserver_USCOREinfo_USCOREresult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_entry_result"))
		{	*type = SOAP_TYPE_ns1__get_USCOREentry_USCOREresult;
			return soap_in_ns1__get_USCOREentry_USCOREresult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_entry_list_result_version2"))
		{	*type = SOAP_TYPE_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2;
			return soap_in_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_entry_list_result"))
		{	*type = SOAP_TYPE_ns1__get_USCOREentry_USCORElist_USCOREresult;
			return soap_in_ns1__get_USCOREentry_USCORElist_USCOREresult(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:link_name_value"))
		{	*type = SOAP_TYPE_link_USCORElist;
			return soap_in_link_USCORElist(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:return_search_result"))
		{	*type = SOAP_TYPE_ns1__return_USCOREsearch_USCOREresult;
			return soap_in_ns1__return_USCOREsearch_USCOREresult(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:link_name_value"))
		{	*type = SOAP_TYPE_link_USCORElists;
			return soap_in_link_USCORElists(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:entry_value"))
		{	*type = SOAP_TYPE_entry_USCORElist;
			return soap_in_entry_USCORElist(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_entry_result_version2"))
		{	*type = SOAP_TYPE_ns1__get_USCOREentry_USCOREresult_USCOREversion2;
			return soap_in_ns1__get_USCOREentry_USCOREresult_USCOREversion2(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:name_value"))
		{	*type = SOAP_TYPE_link_USCOREarray_USCORElist;
			return soap_in_link_USCOREarray_USCORElist(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:link_name_value"))
		{	*type = SOAP_TYPE_ns1__link_USCOREname_USCOREvalue;
			return soap_in_ns1__link_USCOREname_USCOREvalue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:link_name_to_fields_array"))
		{	*type = SOAP_TYPE_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray;
			return soap_in_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:get_mailmerge_document_result"))
		{	*type = SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult;
			return soap_in_ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:entry_value"))
		{	*type = SOAP_TYPE_ns1__entry_USCOREvalue;
			return soap_in_ns1__entry_USCOREvalue(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "xsd:string"))
		{	*type = SOAP_TYPE_select_USCOREfields;
			return soap_in_select_USCOREfields(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:module_list"))
		{	*type = SOAP_TYPE_ns1__module_USCORElist;
			return soap_in_ns1__module_USCORElist(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:link_field"))
		{	*type = SOAP_TYPE_link_USCOREfield_USCORElist;
			return soap_in_link_USCOREfield_USCORElist(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:new_module_fields"))
		{	*type = SOAP_TYPE_ns1__new_USCOREmodule_USCOREfields;
			return soap_in_ns1__new_USCOREmodule_USCOREfields(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:field"))
		{	*type = SOAP_TYPE_field_USCORElist;
			return soap_in_field_USCORElist(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:module_fields"))
		{	*type = SOAP_TYPE_ns1__module_USCOREfields;
			return soap_in_ns1__module_USCOREfields(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:name_value"))
		{	*type = SOAP_TYPE_ns1__name_USCOREvalue;
			return soap_in_ns1__name_USCOREvalue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:link_field"))
		{	*type = SOAP_TYPE_ns1__link_USCOREfield;
			return soap_in_ns1__link_USCOREfield(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:name_value"))
		{	*type = SOAP_TYPE_name_USCOREvalue_USCORElist;
			return soap_in_name_USCOREvalue_USCORElist(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:field"))
		{	*type = SOAP_TYPE_ns1__field;
			return soap_in_ns1__field(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:user_auth"))
		{	*type = SOAP_TYPE_ns1__user_USCOREauth;
			return soap_in_ns1__user_USCOREauth(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:error_value"))
		{	*type = SOAP_TYPE_ns1__error_USCOREvalue;
			return soap_in_ns1__error_USCOREvalue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:return_note_attachment"))
		{	*type = SOAP_TYPE_ns1__return_USCOREnote_USCOREattachment;
			return soap_in_ns1__return_USCOREnote_USCOREattachment(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:new_return_note_attachment"))
		{	*type = SOAP_TYPE_ns1__new_USCOREreturn_USCOREnote_USCOREattachment;
			return soap_in_ns1__new_USCOREreturn_USCOREnote_USCOREattachment(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:new_note_attachment"))
		{	*type = SOAP_TYPE_ns1__new_USCOREnote_USCOREattachment;
			return soap_in_ns1__new_USCOREnote_USCOREattachment(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:note_attachment"))
		{	*type = SOAP_TYPE_ns1__note_USCOREattachment;
			return soap_in_ns1__note_USCOREattachment(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:date"))
		{	char **s;
			*type = SOAP_TYPE_xsd__date;
			s = soap_in_xsd__date(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unknown element '%s' (level=%u, %d)\n", soap->tag, soap->level, soap->body));
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_ns1__create_USCOREcase:
		return soap_out_ns1__create_USCOREcase(soap, tag, id, (const struct ns1__create_USCOREcase *)ptr, "ns1:create_case");
	case SOAP_TYPE_ns1__create_USCOREcaseResponse:
		return soap_out_ns1__create_USCOREcaseResponse(soap, tag, id, (const struct ns1__create_USCOREcaseResponse *)ptr, "ns1:create_caseResponse");
	case SOAP_TYPE_ns1__create_USCOREopportunity:
		return soap_out_ns1__create_USCOREopportunity(soap, tag, id, (const struct ns1__create_USCOREopportunity *)ptr, "ns1:create_opportunity");
	case SOAP_TYPE_ns1__create_USCOREopportunityResponse:
		return soap_out_ns1__create_USCOREopportunityResponse(soap, tag, id, (const struct ns1__create_USCOREopportunityResponse *)ptr, "ns1:create_opportunityResponse");
	case SOAP_TYPE_ns1__create_USCOREaccount:
		return soap_out_ns1__create_USCOREaccount(soap, tag, id, (const struct ns1__create_USCOREaccount *)ptr, "ns1:create_account");
	case SOAP_TYPE_ns1__create_USCOREaccountResponse:
		return soap_out_ns1__create_USCOREaccountResponse(soap, tag, id, (const struct ns1__create_USCOREaccountResponse *)ptr, "ns1:create_accountResponse");
	case SOAP_TYPE_ns1__create_USCORElead:
		return soap_out_ns1__create_USCORElead(soap, tag, id, (const struct ns1__create_USCORElead *)ptr, "ns1:create_lead");
	case SOAP_TYPE_ns1__create_USCOREleadResponse:
		return soap_out_ns1__create_USCOREleadResponse(soap, tag, id, (const struct ns1__create_USCOREleadResponse *)ptr, "ns1:create_leadResponse");
	case SOAP_TYPE_ns1__create_USCOREcontact:
		return soap_out_ns1__create_USCOREcontact(soap, tag, id, (const struct ns1__create_USCOREcontact *)ptr, "ns1:create_contact");
	case SOAP_TYPE_ns1__create_USCOREcontactResponse:
		return soap_out_ns1__create_USCOREcontactResponse(soap, tag, id, (const struct ns1__create_USCOREcontactResponse *)ptr, "ns1:create_contactResponse");
	case SOAP_TYPE_ns1__track_USCOREemail:
		return soap_out_ns1__track_USCOREemail(soap, tag, id, (const struct ns1__track_USCOREemail *)ptr, "ns1:track_email");
	case SOAP_TYPE_ns1__track_USCOREemailResponse:
		return soap_out_ns1__track_USCOREemailResponse(soap, tag, id, (const struct ns1__track_USCOREemailResponse *)ptr, "ns1:track_emailResponse");
	case SOAP_TYPE_ns1__search:
		return soap_out_ns1__search(soap, tag, id, (const struct ns1__search *)ptr, "ns1:search");
	case SOAP_TYPE_ns1__searchResponse:
		return soap_out_ns1__searchResponse(soap, tag, id, (const struct ns1__searchResponse *)ptr, "ns1:searchResponse");
	case SOAP_TYPE_ns1__user_USCORElist:
		return soap_out_ns1__user_USCORElist(soap, tag, id, (const struct ns1__user_USCORElist *)ptr, "ns1:user_list");
	case SOAP_TYPE_ns1__user_USCORElistResponse:
		return soap_out_ns1__user_USCORElistResponse(soap, tag, id, (const struct ns1__user_USCORElistResponse *)ptr, "ns1:user_listResponse");
	case SOAP_TYPE_ns1__get_USCOREcontact_USCORErelationships:
		return soap_out_ns1__get_USCOREcontact_USCORErelationships(soap, tag, id, (const struct ns1__get_USCOREcontact_USCORErelationships *)ptr, "ns1:get_contact_relationships");
	case SOAP_TYPE_ns1__get_USCOREcontact_USCORErelationshipsResponse:
		return soap_out_ns1__get_USCOREcontact_USCORErelationshipsResponse(soap, tag, id, (const struct ns1__get_USCOREcontact_USCORErelationshipsResponse *)ptr, "ns1:get_contact_relationshipsResponse");
	case SOAP_TYPE_ns1__contact_USCOREby_USCOREemail:
		return soap_out_ns1__contact_USCOREby_USCOREemail(soap, tag, id, (const struct ns1__contact_USCOREby_USCOREemail *)ptr, "ns1:contact_by_email");
	case SOAP_TYPE_ns1__contact_USCOREby_USCOREemailResponse:
		return soap_out_ns1__contact_USCOREby_USCOREemailResponse(soap, tag, id, (const struct ns1__contact_USCOREby_USCOREemailResponse *)ptr, "ns1:contact_by_emailResponse");
	case SOAP_TYPE_ns1__end_USCOREsession:
		return soap_out_ns1__end_USCOREsession(soap, tag, id, (const struct ns1__end_USCOREsession *)ptr, "ns1:end_session");
	case SOAP_TYPE_ns1__end_USCOREsessionResponse:
		return soap_out_ns1__end_USCOREsessionResponse(soap, tag, id, (const struct ns1__end_USCOREsessionResponse *)ptr, "ns1:end_sessionResponse");
	case SOAP_TYPE_ns1__create_USCOREsession:
		return soap_out_ns1__create_USCOREsession(soap, tag, id, (const struct ns1__create_USCOREsession *)ptr, "ns1:create_session");
	case SOAP_TYPE_ns1__create_USCOREsessionResponse:
		return soap_out_ns1__create_USCOREsessionResponse(soap, tag, id, (const struct ns1__create_USCOREsessionResponse *)ptr, "ns1:create_sessionResponse");
	case SOAP_TYPE_ns1__get_USCOREattendee_USCORElist:
		return soap_out_ns1__get_USCOREattendee_USCORElist(soap, tag, id, (const struct ns1__get_USCOREattendee_USCORElist *)ptr, "ns1:get_attendee_list");
	case SOAP_TYPE_ns1__get_USCOREattendee_USCORElistResponse:
		return soap_out_ns1__get_USCOREattendee_USCORElistResponse(soap, tag, id, (const struct ns1__get_USCOREattendee_USCORElistResponse *)ptr, "ns1:get_attendee_listResponse");
	case SOAP_TYPE_ns1__get_USCOREmodified_USCOREentries:
		return soap_out_ns1__get_USCOREmodified_USCOREentries(soap, tag, id, (const struct ns1__get_USCOREmodified_USCOREentries *)ptr, "ns1:get_modified_entries");
	case SOAP_TYPE_ns1__get_USCOREmodified_USCOREentriesResponse:
		return soap_out_ns1__get_USCOREmodified_USCOREentriesResponse(soap, tag, id, (const struct ns1__get_USCOREmodified_USCOREentriesResponse *)ptr, "ns1:get_modified_entriesResponse");
	case SOAP_TYPE_ns1__sync_USCOREget_USCOREmodified_USCORErelationships:
		return soap_out_ns1__sync_USCOREget_USCOREmodified_USCORErelationships(soap, tag, id, (const struct ns1__sync_USCOREget_USCOREmodified_USCORErelationships *)ptr, "ns1:sync_get_modified_relationships");
	case SOAP_TYPE_ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse:
		return soap_out_ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse(soap, tag, id, (const struct ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse *)ptr, "ns1:sync_get_modified_relationshipsResponse");
	case SOAP_TYPE_ns1__set_USCOREentries_USCOREdetails:
		return soap_out_ns1__set_USCOREentries_USCOREdetails(soap, tag, id, (const struct ns1__set_USCOREentries_USCOREdetails *)ptr, "ns1:set_entries_details");
	case SOAP_TYPE_ns1__set_USCOREentries_USCOREdetailsResponse:
		return soap_out_ns1__set_USCOREentries_USCOREdetailsResponse(soap, tag, id, (const struct ns1__set_USCOREentries_USCOREdetailsResponse *)ptr, "ns1:set_entries_detailsResponse");
	case SOAP_TYPE_ns1__get_USCOREentries_USCOREcount:
		return soap_out_ns1__get_USCOREentries_USCOREcount(soap, tag, id, (const struct ns1__get_USCOREentries_USCOREcount *)ptr, "ns1:get_entries_count");
	case SOAP_TYPE_ns1__get_USCOREentries_USCOREcountResponse:
		return soap_out_ns1__get_USCOREentries_USCOREcountResponse(soap, tag, id, (const struct ns1__get_USCOREentries_USCOREcountResponse *)ptr, "ns1:get_entries_countResponse");
	case SOAP_TYPE_ns1__set_USCOREcampaign_USCOREmerge:
		return soap_out_ns1__set_USCOREcampaign_USCOREmerge(soap, tag, id, (const struct ns1__set_USCOREcampaign_USCOREmerge *)ptr, "ns1:set_campaign_merge");
	case SOAP_TYPE_ns1__set_USCOREcampaign_USCOREmergeResponse:
		return soap_out_ns1__set_USCOREcampaign_USCOREmergeResponse(soap, tag, id, (const struct ns1__set_USCOREcampaign_USCOREmergeResponse *)ptr, "ns1:set_campaign_mergeResponse");
	case SOAP_TYPE_ns1__get_USCOREdocument_USCORErevision:
		return soap_out_ns1__get_USCOREdocument_USCORErevision(soap, tag, id, (const struct ns1__get_USCOREdocument_USCORErevision *)ptr, "ns1:get_document_revision");
	case SOAP_TYPE_ns1__get_USCOREdocument_USCORErevisionResponse:
		return soap_out_ns1__get_USCOREdocument_USCORErevisionResponse(soap, tag, id, (const struct ns1__get_USCOREdocument_USCORErevisionResponse *)ptr, "ns1:get_document_revisionResponse");
	case SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocument2:
		return soap_out_ns1__get_USCOREmailmerge_USCOREdocument2(soap, tag, id, (const struct ns1__get_USCOREmailmerge_USCOREdocument2 *)ptr, "ns1:get_mailmerge_document2");
	case SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocument2Response:
		return soap_out_ns1__get_USCOREmailmerge_USCOREdocument2Response(soap, tag, id, (const struct ns1__get_USCOREmailmerge_USCOREdocument2Response *)ptr, "ns1:get_mailmerge_document2Response");
	case SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocument:
		return soap_out_ns1__get_USCOREmailmerge_USCOREdocument(soap, tag, id, (const struct ns1__get_USCOREmailmerge_USCOREdocument *)ptr, "ns1:get_mailmerge_document");
	case SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocumentResponse:
		return soap_out_ns1__get_USCOREmailmerge_USCOREdocumentResponse(soap, tag, id, (const struct ns1__get_USCOREmailmerge_USCOREdocumentResponse *)ptr, "ns1:get_mailmerge_documentResponse");
	case SOAP_TYPE_ns1__search_USCOREby_USCOREmodule:
		return soap_out_ns1__search_USCOREby_USCOREmodule(soap, tag, id, (const struct ns1__search_USCOREby_USCOREmodule *)ptr, "ns1:search_by_module");
	case SOAP_TYPE_ns1__search_USCOREby_USCOREmoduleResponse:
		return soap_out_ns1__search_USCOREby_USCOREmoduleResponse(soap, tag, id, (const struct ns1__search_USCOREby_USCOREmoduleResponse *)ptr, "ns1:search_by_moduleResponse");
	case SOAP_TYPE_ns1__set_USCOREdocument_USCORErevision:
		return soap_out_ns1__set_USCOREdocument_USCORErevision(soap, tag, id, (const struct ns1__set_USCOREdocument_USCORErevision *)ptr, "ns1:set_document_revision");
	case SOAP_TYPE_ns1__set_USCOREdocument_USCORErevisionResponse:
		return soap_out_ns1__set_USCOREdocument_USCORErevisionResponse(soap, tag, id, (const struct ns1__set_USCOREdocument_USCORErevisionResponse *)ptr, "ns1:set_document_revisionResponse");
	case SOAP_TYPE_ns1__set_USCORErelationships:
		return soap_out_ns1__set_USCORErelationships(soap, tag, id, (const struct ns1__set_USCORErelationships *)ptr, "ns1:set_relationships");
	case SOAP_TYPE_ns1__set_USCORErelationshipsResponse:
		return soap_out_ns1__set_USCORErelationshipsResponse(soap, tag, id, (const struct ns1__set_USCORErelationshipsResponse *)ptr, "ns1:set_relationshipsResponse");
	case SOAP_TYPE_ns1__set_USCORErelationship:
		return soap_out_ns1__set_USCORErelationship(soap, tag, id, (const struct ns1__set_USCORErelationship *)ptr, "ns1:set_relationship");
	case SOAP_TYPE_ns1__set_USCORErelationshipResponse:
		return soap_out_ns1__set_USCORErelationshipResponse(soap, tag, id, (const struct ns1__set_USCORErelationshipResponse *)ptr, "ns1:set_relationshipResponse");
	case SOAP_TYPE_ns1__get_USCORErelationships:
		return soap_out_ns1__get_USCORErelationships(soap, tag, id, (const struct ns1__get_USCORErelationships *)ptr, "ns1:get_relationships");
	case SOAP_TYPE_ns1__get_USCORErelationshipsResponse:
		return soap_out_ns1__get_USCORErelationshipsResponse(soap, tag, id, (const struct ns1__get_USCORErelationshipsResponse *)ptr, "ns1:get_relationshipsResponse");
	case SOAP_TYPE_ns1__get_USCOREserver_USCOREversion:
		return soap_out_ns1__get_USCOREserver_USCOREversion(soap, tag, id, (const struct ns1__get_USCOREserver_USCOREversion *)ptr, "ns1:get_server_version");
	case SOAP_TYPE_ns1__get_USCOREserver_USCOREversionResponse:
		return soap_out_ns1__get_USCOREserver_USCOREversionResponse(soap, tag, id, (const struct ns1__get_USCOREserver_USCOREversionResponse *)ptr, "ns1:get_server_versionResponse");
	case SOAP_TYPE_ns1__get_USCOREsugar_USCOREflavor:
		return soap_out_ns1__get_USCOREsugar_USCOREflavor(soap, tag, id, (const struct ns1__get_USCOREsugar_USCOREflavor *)ptr, "ns1:get_sugar_flavor");
	case SOAP_TYPE_ns1__get_USCOREsugar_USCOREflavorResponse:
		return soap_out_ns1__get_USCOREsugar_USCOREflavorResponse(soap, tag, id, (const struct ns1__get_USCOREsugar_USCOREflavorResponse *)ptr, "ns1:get_sugar_flavorResponse");
	case SOAP_TYPE_ns1__get_USCOREgmt_USCOREtime:
		return soap_out_ns1__get_USCOREgmt_USCOREtime(soap, tag, id, (const struct ns1__get_USCOREgmt_USCOREtime *)ptr, "ns1:get_gmt_time");
	case SOAP_TYPE_ns1__get_USCOREgmt_USCOREtimeResponse:
		return soap_out_ns1__get_USCOREgmt_USCOREtimeResponse(soap, tag, id, (const struct ns1__get_USCOREgmt_USCOREtimeResponse *)ptr, "ns1:get_gmt_timeResponse");
	case SOAP_TYPE_ns1__get_USCOREserver_USCOREtime:
		return soap_out_ns1__get_USCOREserver_USCOREtime(soap, tag, id, (const struct ns1__get_USCOREserver_USCOREtime *)ptr, "ns1:get_server_time");
	case SOAP_TYPE_ns1__get_USCOREserver_USCOREtimeResponse:
		return soap_out_ns1__get_USCOREserver_USCOREtimeResponse(soap, tag, id, (const struct ns1__get_USCOREserver_USCOREtimeResponse *)ptr, "ns1:get_server_timeResponse");
	case SOAP_TYPE_ns1__get_USCOREuser_USCOREteam_USCOREid:
		return soap_out_ns1__get_USCOREuser_USCOREteam_USCOREid(soap, tag, id, (const struct ns1__get_USCOREuser_USCOREteam_USCOREid *)ptr, "ns1:get_user_team_id");
	case SOAP_TYPE_ns1__get_USCOREuser_USCOREteam_USCOREidResponse:
		return soap_out_ns1__get_USCOREuser_USCOREteam_USCOREidResponse(soap, tag, id, (const struct ns1__get_USCOREuser_USCOREteam_USCOREidResponse *)ptr, "ns1:get_user_team_idResponse");
	case SOAP_TYPE_ns1__get_USCOREuser_USCOREid:
		return soap_out_ns1__get_USCOREuser_USCOREid(soap, tag, id, (const struct ns1__get_USCOREuser_USCOREid *)ptr, "ns1:get_user_id");
	case SOAP_TYPE_ns1__get_USCOREuser_USCOREidResponse:
		return soap_out_ns1__get_USCOREuser_USCOREidResponse(soap, tag, id, (const struct ns1__get_USCOREuser_USCOREidResponse *)ptr, "ns1:get_user_idResponse");
	case SOAP_TYPE_ns1__update_USCOREportal_USCOREuser:
		return soap_out_ns1__update_USCOREportal_USCOREuser(soap, tag, id, (const struct ns1__update_USCOREportal_USCOREuser *)ptr, "ns1:update_portal_user");
	case SOAP_TYPE_ns1__update_USCOREportal_USCOREuserResponse:
		return soap_out_ns1__update_USCOREportal_USCOREuserResponse(soap, tag, id, (const struct ns1__update_USCOREportal_USCOREuserResponse *)ptr, "ns1:update_portal_userResponse");
	case SOAP_TYPE_ns1__get_USCOREavailable_USCOREmodules:
		return soap_out_ns1__get_USCOREavailable_USCOREmodules(soap, tag, id, (const struct ns1__get_USCOREavailable_USCOREmodules *)ptr, "ns1:get_available_modules");
	case SOAP_TYPE_ns1__get_USCOREavailable_USCOREmodulesResponse:
		return soap_out_ns1__get_USCOREavailable_USCOREmodulesResponse(soap, tag, id, (const struct ns1__get_USCOREavailable_USCOREmodulesResponse *)ptr, "ns1:get_available_modulesResponse");
	case SOAP_TYPE_ns1__get_USCOREmodule_USCOREfields:
		return soap_out_ns1__get_USCOREmodule_USCOREfields(soap, tag, id, (const struct ns1__get_USCOREmodule_USCOREfields *)ptr, "ns1:get_module_fields");
	case SOAP_TYPE_ns1__get_USCOREmodule_USCOREfieldsResponse:
		return soap_out_ns1__get_USCOREmodule_USCOREfieldsResponse(soap, tag, id, (const struct ns1__get_USCOREmodule_USCOREfieldsResponse *)ptr, "ns1:get_module_fieldsResponse");
	case SOAP_TYPE_ns1__logout:
		return soap_out_ns1__logout(soap, tag, id, (const struct ns1__logout *)ptr, "ns1:logout");
	case SOAP_TYPE_ns1__logoutResponse:
		return soap_out_ns1__logoutResponse(soap, tag, id, (const struct ns1__logoutResponse *)ptr, "ns1:logoutResponse");
	case SOAP_TYPE_ns1__get_USCORErelated_USCOREnotes:
		return soap_out_ns1__get_USCORErelated_USCOREnotes(soap, tag, id, (const struct ns1__get_USCORErelated_USCOREnotes *)ptr, "ns1:get_related_notes");
	case SOAP_TYPE_ns1__get_USCORErelated_USCOREnotesResponse:
		return soap_out_ns1__get_USCORErelated_USCOREnotesResponse(soap, tag, id, (const struct ns1__get_USCORErelated_USCOREnotesResponse *)ptr, "ns1:get_related_notesResponse");
	case SOAP_TYPE_ns1__relate_USCOREnote_USCOREto_USCOREmodule:
		return soap_out_ns1__relate_USCOREnote_USCOREto_USCOREmodule(soap, tag, id, (const struct ns1__relate_USCOREnote_USCOREto_USCOREmodule *)ptr, "ns1:relate_note_to_module");
	case SOAP_TYPE_ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse:
		return soap_out_ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse(soap, tag, id, (const struct ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse *)ptr, "ns1:relate_note_to_moduleResponse");
	case SOAP_TYPE_ns1__get_USCOREnote_USCOREattachment:
		return soap_out_ns1__get_USCOREnote_USCOREattachment(soap, tag, id, (const struct ns1__get_USCOREnote_USCOREattachment *)ptr, "ns1:get_note_attachment");
	case SOAP_TYPE_ns1__get_USCOREnote_USCOREattachmentResponse:
		return soap_out_ns1__get_USCOREnote_USCOREattachmentResponse(soap, tag, id, (const struct ns1__get_USCOREnote_USCOREattachmentResponse *)ptr, "ns1:get_note_attachmentResponse");
	case SOAP_TYPE_ns1__set_USCOREnote_USCOREattachment:
		return soap_out_ns1__set_USCOREnote_USCOREattachment(soap, tag, id, (const struct ns1__set_USCOREnote_USCOREattachment *)ptr, "ns1:set_note_attachment");
	case SOAP_TYPE_ns1__set_USCOREnote_USCOREattachmentResponse:
		return soap_out_ns1__set_USCOREnote_USCOREattachmentResponse(soap, tag, id, (const struct ns1__set_USCOREnote_USCOREattachmentResponse *)ptr, "ns1:set_note_attachmentResponse");
	case SOAP_TYPE_ns1__set_USCOREentries:
		return soap_out_ns1__set_USCOREentries(soap, tag, id, (const struct ns1__set_USCOREentries *)ptr, "ns1:set_entries");
	case SOAP_TYPE_ns1__set_USCOREentriesResponse:
		return soap_out_ns1__set_USCOREentriesResponse(soap, tag, id, (const struct ns1__set_USCOREentriesResponse *)ptr, "ns1:set_entriesResponse");
	case SOAP_TYPE_ns1__set_USCOREentry:
		return soap_out_ns1__set_USCOREentry(soap, tag, id, (const struct ns1__set_USCOREentry *)ptr, "ns1:set_entry");
	case SOAP_TYPE_ns1__set_USCOREentryResponse:
		return soap_out_ns1__set_USCOREentryResponse(soap, tag, id, (const struct ns1__set_USCOREentryResponse *)ptr, "ns1:set_entryResponse");
	case SOAP_TYPE_ns1__get_USCOREentries:
		return soap_out_ns1__get_USCOREentries(soap, tag, id, (const struct ns1__get_USCOREentries *)ptr, "ns1:get_entries");
	case SOAP_TYPE_ns1__get_USCOREentriesResponse:
		return soap_out_ns1__get_USCOREentriesResponse(soap, tag, id, (const struct ns1__get_USCOREentriesResponse *)ptr, "ns1:get_entriesResponse");
	case SOAP_TYPE_ns1__get_USCOREentry:
		return soap_out_ns1__get_USCOREentry(soap, tag, id, (const struct ns1__get_USCOREentry *)ptr, "ns1:get_entry");
	case SOAP_TYPE_ns1__get_USCOREentryResponse:
		return soap_out_ns1__get_USCOREentryResponse(soap, tag, id, (const struct ns1__get_USCOREentryResponse *)ptr, "ns1:get_entryResponse");
	case SOAP_TYPE_ns1__get_USCOREentry_USCORElist:
		return soap_out_ns1__get_USCOREentry_USCORElist(soap, tag, id, (const struct ns1__get_USCOREentry_USCORElist *)ptr, "ns1:get_entry_list");
	case SOAP_TYPE_ns1__get_USCOREentry_USCORElistResponse:
		return soap_out_ns1__get_USCOREentry_USCORElistResponse(soap, tag, id, (const struct ns1__get_USCOREentry_USCORElistResponse *)ptr, "ns1:get_entry_listResponse");
	case SOAP_TYPE_ns1__seamless_USCORElogin:
		return soap_out_ns1__seamless_USCORElogin(soap, tag, id, (const struct ns1__seamless_USCORElogin *)ptr, "ns1:seamless_login");
	case SOAP_TYPE_ns1__seamless_USCOREloginResponse:
		return soap_out_ns1__seamless_USCOREloginResponse(soap, tag, id, (const struct ns1__seamless_USCOREloginResponse *)ptr, "ns1:seamless_loginResponse");
	case SOAP_TYPE_ns1__is_USCOREloopback:
		return soap_out_ns1__is_USCOREloopback(soap, tag, id, (const struct ns1__is_USCOREloopback *)ptr, "ns1:is_loopback");
	case SOAP_TYPE_ns1__is_USCOREloopbackResponse:
		return soap_out_ns1__is_USCOREloopbackResponse(soap, tag, id, (const struct ns1__is_USCOREloopbackResponse *)ptr, "ns1:is_loopbackResponse");
	case SOAP_TYPE_ns1__login:
		return soap_out_ns1__login(soap, tag, id, (const struct ns1__login *)ptr, "ns1:login");
	case SOAP_TYPE_ns1__loginResponse:
		return soap_out_ns1__loginResponse(soap, tag, id, (const struct ns1__loginResponse *)ptr, "ns1:loginResponse");
	case SOAP_TYPE_ns1__is_USCOREuser_USCOREadmin:
		return soap_out_ns1__is_USCOREuser_USCOREadmin(soap, tag, id, (const struct ns1__is_USCOREuser_USCOREadmin *)ptr, "ns1:is_user_admin");
	case SOAP_TYPE_ns1__is_USCOREuser_USCOREadminResponse:
		return soap_out_ns1__is_USCOREuser_USCOREadminResponse(soap, tag, id, (const struct ns1__is_USCOREuser_USCOREadminResponse *)ptr, "ns1:is_user_adminResponse");
	case SOAP_TYPE_user_USCOREdetail_USCOREarray:
		return soap_out_user_USCOREdetail_USCOREarray(soap, tag, id, (const struct user_USCOREdetail_USCOREarray *)ptr, "ns1:user_detail");
	case SOAP_TYPE_contact_USCOREdetail_USCOREarray:
		return soap_out_contact_USCOREdetail_USCOREarray(soap, tag, id, (const struct contact_USCOREdetail_USCOREarray *)ptr, "ns1:contact_detail");
	case SOAP_TYPE_str_USCOREarray:
		return soap_out_str_USCOREarray(soap, tag, id, (const struct str_USCOREarray *)ptr, "xsd:string");
	case SOAP_TYPE_name_USCOREvalue_USCOREoperator_USCORElist:
		return soap_out_name_USCOREvalue_USCOREoperator_USCORElist(soap, tag, id, (const struct name_USCOREvalue_USCOREoperator_USCORElist *)ptr, "ns1:name_value_operator");
	case SOAP_TYPE_new_USCOREset_USCORErelationhip_USCOREids:
		return soap_out_new_USCOREset_USCORErelationhip_USCOREids(soap, tag, id, (const struct new_USCOREset_USCORErelationhip_USCOREids *)ptr, "xsd:string");
	case SOAP_TYPE_set_USCORErelationship_USCORElist:
		return soap_out_set_USCORErelationship_USCORElist(soap, tag, id, (const struct set_USCORErelationship_USCORElist *)ptr, "ns1:set_relationship_value");
	case SOAP_TYPE_link_USCOREvalue:
		return soap_out_link_USCOREvalue(soap, tag, id, (const struct link_USCOREvalue *)ptr, "ns1:name_value");
	case SOAP_TYPE_ns1__user_USCOREdetail:
		return soap_out_ns1__user_USCOREdetail(soap, tag, id, (const struct ns1__user_USCOREdetail *)ptr, "ns1:user_detail");
	case SOAP_TYPE_ns1__contact_USCOREdetail:
		return soap_out_ns1__contact_USCOREdetail(soap, tag, id, (const struct ns1__contact_USCOREdetail *)ptr, "ns1:contact_detail");
	case SOAP_TYPE_ns1__set_USCOREentries_USCOREdetail_USCOREresult:
		return soap_out_ns1__set_USCOREentries_USCOREdetail_USCOREresult(soap, tag, id, (const struct ns1__set_USCOREentries_USCOREdetail_USCOREresult *)ptr, "ns1:set_entries_detail_result");
	case SOAP_TYPE_ns1__get_USCOREentries_USCOREcount_USCOREresult:
		return soap_out_ns1__get_USCOREentries_USCOREcount_USCOREresult(soap, tag, id, (const struct ns1__get_USCOREentries_USCOREcount_USCOREresult *)ptr, "ns1:get_entries_count_result");
	case SOAP_TYPE_name_USCOREvalue_USCORElists:
		return soap_out_name_USCOREvalue_USCORElists(soap, tag, id, (const struct name_USCOREvalue_USCORElists *)ptr, "ns1:name_value");
	case SOAP_TYPE_ns1__name_USCOREvalue_USCORElists_USCOREerror:
		return soap_out_ns1__name_USCOREvalue_USCORElists_USCOREerror(soap, tag, id, (const struct ns1__name_USCOREvalue_USCORElists_USCOREerror *)ptr, "ns1:name_value_lists_error");
	case SOAP_TYPE_newsletter_USCORElist:
		return soap_out_newsletter_USCORElist(soap, tag, id, (const struct newsletter_USCORElist *)ptr, "ns1:newsletter");
	case SOAP_TYPE_ns1__get_USCOREsubscription_USCORElists_USCOREresult:
		return soap_out_ns1__get_USCOREsubscription_USCORElists_USCOREresult(soap, tag, id, (const struct ns1__get_USCOREsubscription_USCORElists_USCOREresult *)ptr, "ns1:get_subscription_lists_result");
	case SOAP_TYPE_ns1__newsletter:
		return soap_out_ns1__newsletter(soap, tag, id, (const struct ns1__newsletter *)ptr, "ns1:newsletter");
	case SOAP_TYPE_ns1__name_USCOREvalue_USCOREoperator:
		return soap_out_ns1__name_USCOREvalue_USCOREoperator(soap, tag, id, (const struct ns1__name_USCOREvalue_USCOREoperator *)ptr, "ns1:name_value_operator");
	case SOAP_TYPE_ns1__new_USCOREreturn_USCOREdocument_USCORErevision:
		return soap_out_ns1__new_USCOREreturn_USCOREdocument_USCORErevision(soap, tag, id, (const struct ns1__new_USCOREreturn_USCOREdocument_USCORErevision *)ptr, "ns1:new_return_document_revision");
	case SOAP_TYPE_ns1__return_USCOREdocument_USCORErevision:
		return soap_out_ns1__return_USCOREdocument_USCORErevision(soap, tag, id, (const struct ns1__return_USCOREdocument_USCORErevision *)ptr, "ns1:return_document_revision");
	case SOAP_TYPE_ns1__get_USCOREquick_USCOREsync_USCOREresult_USCOREencoded:
		return soap_out_ns1__get_USCOREquick_USCOREsync_USCOREresult_USCOREencoded(soap, tag, id, (const struct ns1__get_USCOREquick_USCOREsync_USCOREresult_USCOREencoded *)ptr, "ns1:get_quick_sync_result_encoded");
	case SOAP_TYPE_ns1__get_USCOREsync_USCOREresult_USCOREencoded:
		return soap_out_ns1__get_USCOREsync_USCOREresult_USCOREencoded(soap, tag, id, (const struct ns1__get_USCOREsync_USCOREresult_USCOREencoded *)ptr, "ns1:get_sync_result_encoded");
	case SOAP_TYPE_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded:
		return soap_out_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded(soap, tag, id, (const struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded *)ptr, "ns1:get_entry_list_result_encoded");
	case SOAP_TYPE_ns1__document_USCORErevision:
		return soap_out_ns1__document_USCORErevision(soap, tag, id, (const struct ns1__document_USCORErevision *)ptr, "ns1:document_revision");
	case SOAP_TYPE_ns1__set_USCORErelationship_USCORElist_USCOREresult:
		return soap_out_ns1__set_USCORErelationship_USCORElist_USCOREresult(soap, tag, id, (const struct ns1__set_USCORErelationship_USCORElist_USCOREresult *)ptr, "ns1:set_relationship_list_result");
	case SOAP_TYPE_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult:
		return soap_out_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(soap, tag, id, (const struct ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult *)ptr, "ns1:new_set_relationship_list_result");
	case SOAP_TYPE_ns1__set_USCORErelationship_USCOREvalue:
		return soap_out_ns1__set_USCORErelationship_USCOREvalue(soap, tag, id, (const struct ns1__set_USCORErelationship_USCOREvalue *)ptr, "ns1:set_relationship_value");
	case SOAP_TYPE_ids_USCOREmods:
		return soap_out_ids_USCOREmods(soap, tag, id, (const struct ids_USCOREmods *)ptr, "ns1:id_mod");
	case SOAP_TYPE_ns1__get_USCORErelationships_USCOREresult:
		return soap_out_ns1__get_USCORErelationships_USCOREresult(soap, tag, id, (const struct ns1__get_USCORErelationships_USCOREresult *)ptr, "ns1:get_relationships_result");
	case SOAP_TYPE_ns1__id_USCOREmod:
		return soap_out_ns1__id_USCOREmod(soap, tag, id, (const struct ns1__id_USCOREmod *)ptr, "ns1:id_mod");
	case SOAP_TYPE_ns1__set_USCOREentries_USCOREresult:
		return soap_out_ns1__set_USCOREentries_USCOREresult(soap, tag, id, (const struct ns1__set_USCOREentries_USCOREresult *)ptr, "ns1:set_entries_result");
	case SOAP_TYPE_ns1__new_USCOREset_USCOREentries_USCOREresult:
		return soap_out_ns1__new_USCOREset_USCOREentries_USCOREresult(soap, tag, id, (const struct ns1__new_USCOREset_USCOREentries_USCOREresult *)ptr, "ns1:new_set_entries_result");
	case SOAP_TYPE_ns1__new_USCOREset_USCOREentry_USCOREresult:
		return soap_out_ns1__new_USCOREset_USCOREentry_USCOREresult(soap, tag, id, (const struct ns1__new_USCOREset_USCOREentry_USCOREresult *)ptr, "ns1:new_set_entry_result");
	case SOAP_TYPE_ns1__set_USCOREentry_USCOREresult:
		return soap_out_ns1__set_USCOREentry_USCOREresult(soap, tag, id, (const struct ns1__set_USCOREentry_USCOREresult *)ptr, "ns1:set_entry_result");
	case SOAP_TYPE_ns1__get_USCOREserver_USCOREinfo_USCOREresult:
		return soap_out_ns1__get_USCOREserver_USCOREinfo_USCOREresult(soap, tag, id, (const struct ns1__get_USCOREserver_USCOREinfo_USCOREresult *)ptr, "ns1:get_server_info_result");
	case SOAP_TYPE_ns1__get_USCOREentry_USCOREresult:
		return soap_out_ns1__get_USCOREentry_USCOREresult(soap, tag, id, (const struct ns1__get_USCOREentry_USCOREresult *)ptr, "ns1:get_entry_result");
	case SOAP_TYPE_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2:
		return soap_out_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2(soap, tag, id, (const struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2 *)ptr, "ns1:get_entry_list_result_version2");
	case SOAP_TYPE_ns1__get_USCOREentry_USCORElist_USCOREresult:
		return soap_out_ns1__get_USCOREentry_USCORElist_USCOREresult(soap, tag, id, (const struct ns1__get_USCOREentry_USCORElist_USCOREresult *)ptr, "ns1:get_entry_list_result");
	case SOAP_TYPE_link_USCORElist:
		return soap_out_link_USCORElist(soap, tag, id, (const struct link_USCORElist *)ptr, "ns1:link_name_value");
	case SOAP_TYPE_ns1__return_USCOREsearch_USCOREresult:
		return soap_out_ns1__return_USCOREsearch_USCOREresult(soap, tag, id, (const struct ns1__return_USCOREsearch_USCOREresult *)ptr, "ns1:return_search_result");
	case SOAP_TYPE_link_USCORElists:
		return soap_out_link_USCORElists(soap, tag, id, (const struct link_USCORElists *)ptr, "ns1:link_name_value");
	case SOAP_TYPE_entry_USCORElist:
		return soap_out_entry_USCORElist(soap, tag, id, (const struct entry_USCORElist *)ptr, "ns1:entry_value");
	case SOAP_TYPE_ns1__get_USCOREentry_USCOREresult_USCOREversion2:
		return soap_out_ns1__get_USCOREentry_USCOREresult_USCOREversion2(soap, tag, id, (const struct ns1__get_USCOREentry_USCOREresult_USCOREversion2 *)ptr, "ns1:get_entry_result_version2");
	case SOAP_TYPE_link_USCOREarray_USCORElist:
		return soap_out_link_USCOREarray_USCORElist(soap, tag, id, (const struct link_USCOREarray_USCORElist *)ptr, "ns1:name_value");
	case SOAP_TYPE_ns1__link_USCOREname_USCOREvalue:
		return soap_out_ns1__link_USCOREname_USCOREvalue(soap, tag, id, (const struct ns1__link_USCOREname_USCOREvalue *)ptr, "ns1:link_name_value");
	case SOAP_TYPE_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray:
		return soap_out_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(soap, tag, id, (const struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray *)ptr, "ns1:link_name_to_fields_array");
	case SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult:
		return soap_out_ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult(soap, tag, id, (const struct ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult *)ptr, "ns1:get_mailmerge_document_result");
	case SOAP_TYPE_ns1__entry_USCOREvalue:
		return soap_out_ns1__entry_USCOREvalue(soap, tag, id, (const struct ns1__entry_USCOREvalue *)ptr, "ns1:entry_value");
	case SOAP_TYPE_select_USCOREfields:
		return soap_out_select_USCOREfields(soap, tag, id, (const struct select_USCOREfields *)ptr, "xsd:string");
	case SOAP_TYPE_ns1__module_USCORElist:
		return soap_out_ns1__module_USCORElist(soap, tag, id, (const struct ns1__module_USCORElist *)ptr, "ns1:module_list");
	case SOAP_TYPE_link_USCOREfield_USCORElist:
		return soap_out_link_USCOREfield_USCORElist(soap, tag, id, (const struct link_USCOREfield_USCORElist *)ptr, "ns1:link_field");
	case SOAP_TYPE_ns1__new_USCOREmodule_USCOREfields:
		return soap_out_ns1__new_USCOREmodule_USCOREfields(soap, tag, id, (const struct ns1__new_USCOREmodule_USCOREfields *)ptr, "ns1:new_module_fields");
	case SOAP_TYPE_field_USCORElist:
		return soap_out_field_USCORElist(soap, tag, id, (const struct field_USCORElist *)ptr, "ns1:field");
	case SOAP_TYPE_ns1__module_USCOREfields:
		return soap_out_ns1__module_USCOREfields(soap, tag, id, (const struct ns1__module_USCOREfields *)ptr, "ns1:module_fields");
	case SOAP_TYPE_ns1__name_USCOREvalue:
		return soap_out_ns1__name_USCOREvalue(soap, tag, id, (const struct ns1__name_USCOREvalue *)ptr, "ns1:name_value");
	case SOAP_TYPE_ns1__link_USCOREfield:
		return soap_out_ns1__link_USCOREfield(soap, tag, id, (const struct ns1__link_USCOREfield *)ptr, "ns1:link_field");
	case SOAP_TYPE_name_USCOREvalue_USCORElist:
		return soap_out_name_USCOREvalue_USCORElist(soap, tag, id, (const struct name_USCOREvalue_USCORElist *)ptr, "ns1:name_value");
	case SOAP_TYPE_ns1__field:
		return soap_out_ns1__field(soap, tag, id, (const struct ns1__field *)ptr, "ns1:field");
	case SOAP_TYPE_ns1__user_USCOREauth:
		return soap_out_ns1__user_USCOREauth(soap, tag, id, (const struct ns1__user_USCOREauth *)ptr, "ns1:user_auth");
	case SOAP_TYPE_ns1__error_USCOREvalue:
		return soap_out_ns1__error_USCOREvalue(soap, tag, id, (const struct ns1__error_USCOREvalue *)ptr, "ns1:error_value");
	case SOAP_TYPE_ns1__return_USCOREnote_USCOREattachment:
		return soap_out_ns1__return_USCOREnote_USCOREattachment(soap, tag, id, (const struct ns1__return_USCOREnote_USCOREattachment *)ptr, "ns1:return_note_attachment");
	case SOAP_TYPE_ns1__new_USCOREreturn_USCOREnote_USCOREattachment:
		return soap_out_ns1__new_USCOREreturn_USCOREnote_USCOREattachment(soap, tag, id, (const struct ns1__new_USCOREreturn_USCOREnote_USCOREattachment *)ptr, "ns1:new_return_note_attachment");
	case SOAP_TYPE_ns1__new_USCOREnote_USCOREattachment:
		return soap_out_ns1__new_USCOREnote_USCOREattachment(soap, tag, id, (const struct ns1__new_USCOREnote_USCOREattachment *)ptr, "ns1:new_note_attachment");
	case SOAP_TYPE_ns1__note_USCOREattachment:
		return soap_out_ns1__note_USCOREattachment(soap, tag, id, (const struct ns1__note_USCOREattachment *)ptr, "ns1:note_attachment");
	case SOAP_TYPE_PointerTons1__searchResponse:
		return soap_out_PointerTons1__searchResponse(soap, tag, id, (struct ns1__searchResponse *const*)ptr, "ns1:searchResponse");
	case SOAP_TYPE_PointerTons1__user_USCORElistResponse:
		return soap_out_PointerTons1__user_USCORElistResponse(soap, tag, id, (struct ns1__user_USCORElistResponse *const*)ptr, "ns1:user_listResponse");
	case SOAP_TYPE_PointerTouser_USCOREdetail_USCOREarray:
		return soap_out_PointerTouser_USCOREdetail_USCOREarray(soap, tag, id, (struct user_USCOREdetail_USCOREarray *const*)ptr, "ns1:user_detail");
	case SOAP_TYPE_PointerTons1__get_USCOREcontact_USCORErelationshipsResponse:
		return soap_out_PointerTons1__get_USCOREcontact_USCORErelationshipsResponse(soap, tag, id, (struct ns1__get_USCOREcontact_USCORErelationshipsResponse *const*)ptr, "ns1:get_contact_relationshipsResponse");
	case SOAP_TYPE_PointerTons1__contact_USCOREby_USCOREemailResponse:
		return soap_out_PointerTons1__contact_USCOREby_USCOREemailResponse(soap, tag, id, (struct ns1__contact_USCOREby_USCOREemailResponse *const*)ptr, "ns1:contact_by_emailResponse");
	case SOAP_TYPE_PointerTocontact_USCOREdetail_USCOREarray:
		return soap_out_PointerTocontact_USCOREdetail_USCOREarray(soap, tag, id, (struct contact_USCOREdetail_USCOREarray *const*)ptr, "ns1:contact_detail");
	case SOAP_TYPE_PointerTons1__get_USCOREattendee_USCORElistResponse:
		return soap_out_PointerTons1__get_USCOREattendee_USCORElistResponse(soap, tag, id, (struct ns1__get_USCOREattendee_USCORElistResponse *const*)ptr, "ns1:get_attendee_listResponse");
	case SOAP_TYPE_PointerTons1__get_USCOREmodified_USCOREentriesResponse:
		return soap_out_PointerTons1__get_USCOREmodified_USCOREentriesResponse(soap, tag, id, (struct ns1__get_USCOREmodified_USCOREentriesResponse *const*)ptr, "ns1:get_modified_entriesResponse");
	case SOAP_TYPE_PointerTons1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse:
		return soap_out_PointerTons1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse(soap, tag, id, (struct ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse *const*)ptr, "ns1:sync_get_modified_relationshipsResponse");
	case SOAP_TYPE_PointerTons1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded:
		return soap_out_PointerTons1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded(soap, tag, id, (struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded *const*)ptr, "ns1:get_entry_list_result_encoded");
	case SOAP_TYPE_PointerTons1__set_USCOREentries_USCOREdetailsResponse:
		return soap_out_PointerTons1__set_USCOREentries_USCOREdetailsResponse(soap, tag, id, (struct ns1__set_USCOREentries_USCOREdetailsResponse *const*)ptr, "ns1:set_entries_detailsResponse");
	case SOAP_TYPE_PointerTons1__set_USCOREentries_USCOREdetail_USCOREresult:
		return soap_out_PointerTons1__set_USCOREentries_USCOREdetail_USCOREresult(soap, tag, id, (struct ns1__set_USCOREentries_USCOREdetail_USCOREresult *const*)ptr, "ns1:set_entries_detail_result");
	case SOAP_TYPE_PointerTons1__get_USCOREentries_USCOREcountResponse:
		return soap_out_PointerTons1__get_USCOREentries_USCOREcountResponse(soap, tag, id, (struct ns1__get_USCOREentries_USCOREcountResponse *const*)ptr, "ns1:get_entries_countResponse");
	case SOAP_TYPE_PointerTons1__get_USCOREentries_USCOREcount_USCOREresult:
		return soap_out_PointerTons1__get_USCOREentries_USCOREcount_USCOREresult(soap, tag, id, (struct ns1__get_USCOREentries_USCOREcount_USCOREresult *const*)ptr, "ns1:get_entries_count_result");
	case SOAP_TYPE_PointerTons1__set_USCOREcampaign_USCOREmergeResponse:
		return soap_out_PointerTons1__set_USCOREcampaign_USCOREmergeResponse(soap, tag, id, (struct ns1__set_USCOREcampaign_USCOREmergeResponse *const*)ptr, "ns1:set_campaign_mergeResponse");
	case SOAP_TYPE_PointerTons1__get_USCOREdocument_USCORErevisionResponse:
		return soap_out_PointerTons1__get_USCOREdocument_USCORErevisionResponse(soap, tag, id, (struct ns1__get_USCOREdocument_USCORErevisionResponse *const*)ptr, "ns1:get_document_revisionResponse");
	case SOAP_TYPE_PointerTons1__return_USCOREdocument_USCORErevision:
		return soap_out_PointerTons1__return_USCOREdocument_USCORErevision(soap, tag, id, (struct ns1__return_USCOREdocument_USCORErevision *const*)ptr, "ns1:return_document_revision");
	case SOAP_TYPE_PointerTons1__get_USCOREmailmerge_USCOREdocument2Response:
		return soap_out_PointerTons1__get_USCOREmailmerge_USCOREdocument2Response(soap, tag, id, (struct ns1__get_USCOREmailmerge_USCOREdocument2Response *const*)ptr, "ns1:get_mailmerge_document2Response");
	case SOAP_TYPE_PointerTons1__get_USCOREmailmerge_USCOREdocument_USCOREresult:
		return soap_out_PointerTons1__get_USCOREmailmerge_USCOREdocument_USCOREresult(soap, tag, id, (struct ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult *const*)ptr, "ns1:get_mailmerge_document_result");
	case SOAP_TYPE_PointerTons1__get_USCOREmailmerge_USCOREdocumentResponse:
		return soap_out_PointerTons1__get_USCOREmailmerge_USCOREdocumentResponse(soap, tag, id, (struct ns1__get_USCOREmailmerge_USCOREdocumentResponse *const*)ptr, "ns1:get_mailmerge_documentResponse");
	case SOAP_TYPE_PointerTons1__get_USCOREsync_USCOREresult_USCOREencoded:
		return soap_out_PointerTons1__get_USCOREsync_USCOREresult_USCOREencoded(soap, tag, id, (struct ns1__get_USCOREsync_USCOREresult_USCOREencoded *const*)ptr, "ns1:get_sync_result_encoded");
	case SOAP_TYPE_PointerTons1__search_USCOREby_USCOREmoduleResponse:
		return soap_out_PointerTons1__search_USCOREby_USCOREmoduleResponse(soap, tag, id, (struct ns1__search_USCOREby_USCOREmoduleResponse *const*)ptr, "ns1:search_by_moduleResponse");
	case SOAP_TYPE_PointerTons1__set_USCOREdocument_USCORErevisionResponse:
		return soap_out_PointerTons1__set_USCOREdocument_USCORErevisionResponse(soap, tag, id, (struct ns1__set_USCOREdocument_USCORErevisionResponse *const*)ptr, "ns1:set_document_revisionResponse");
	case SOAP_TYPE_PointerTons1__set_USCORErelationshipsResponse:
		return soap_out_PointerTons1__set_USCORErelationshipsResponse(soap, tag, id, (struct ns1__set_USCORErelationshipsResponse *const*)ptr, "ns1:set_relationshipsResponse");
	case SOAP_TYPE_PointerToset_USCORErelationship_USCORElist:
		return soap_out_PointerToset_USCORErelationship_USCORElist(soap, tag, id, (struct set_USCORErelationship_USCORElist *const*)ptr, "ns1:set_relationship_value");
	case SOAP_TYPE_PointerTons1__set_USCORErelationship_USCORElist_USCOREresult:
		return soap_out_PointerTons1__set_USCORErelationship_USCORElist_USCOREresult(soap, tag, id, (struct ns1__set_USCORErelationship_USCORElist_USCOREresult *const*)ptr, "ns1:set_relationship_list_result");
	case SOAP_TYPE_PointerTons1__set_USCORErelationshipResponse:
		return soap_out_PointerTons1__set_USCORErelationshipResponse(soap, tag, id, (struct ns1__set_USCORErelationshipResponse *const*)ptr, "ns1:set_relationshipResponse");
	case SOAP_TYPE_PointerTons1__get_USCORErelationshipsResponse:
		return soap_out_PointerTons1__get_USCORErelationshipsResponse(soap, tag, id, (struct ns1__get_USCORErelationshipsResponse *const*)ptr, "ns1:get_relationshipsResponse");
	case SOAP_TYPE_PointerTons1__get_USCORErelationships_USCOREresult:
		return soap_out_PointerTons1__get_USCORErelationships_USCOREresult(soap, tag, id, (struct ns1__get_USCORErelationships_USCOREresult *const*)ptr, "ns1:get_relationships_result");
	case SOAP_TYPE_PointerTons1__update_USCOREportal_USCOREuserResponse:
		return soap_out_PointerTons1__update_USCOREportal_USCOREuserResponse(soap, tag, id, (struct ns1__update_USCOREportal_USCOREuserResponse *const*)ptr, "ns1:update_portal_userResponse");
	case SOAP_TYPE_PointerTons1__get_USCOREavailable_USCOREmodulesResponse:
		return soap_out_PointerTons1__get_USCOREavailable_USCOREmodulesResponse(soap, tag, id, (struct ns1__get_USCOREavailable_USCOREmodulesResponse *const*)ptr, "ns1:get_available_modulesResponse");
	case SOAP_TYPE_PointerTons1__module_USCORElist:
		return soap_out_PointerTons1__module_USCORElist(soap, tag, id, (struct ns1__module_USCORElist *const*)ptr, "ns1:module_list");
	case SOAP_TYPE_PointerTons1__get_USCOREmodule_USCOREfieldsResponse:
		return soap_out_PointerTons1__get_USCOREmodule_USCOREfieldsResponse(soap, tag, id, (struct ns1__get_USCOREmodule_USCOREfieldsResponse *const*)ptr, "ns1:get_module_fieldsResponse");
	case SOAP_TYPE_PointerTons1__module_USCOREfields:
		return soap_out_PointerTons1__module_USCOREfields(soap, tag, id, (struct ns1__module_USCOREfields *const*)ptr, "ns1:module_fields");
	case SOAP_TYPE_PointerTons1__logoutResponse:
		return soap_out_PointerTons1__logoutResponse(soap, tag, id, (struct ns1__logoutResponse *const*)ptr, "ns1:logoutResponse");
	case SOAP_TYPE_PointerTons1__get_USCORErelated_USCOREnotesResponse:
		return soap_out_PointerTons1__get_USCORErelated_USCOREnotesResponse(soap, tag, id, (struct ns1__get_USCORErelated_USCOREnotesResponse *const*)ptr, "ns1:get_related_notesResponse");
	case SOAP_TYPE_PointerTons1__relate_USCOREnote_USCOREto_USCOREmoduleResponse:
		return soap_out_PointerTons1__relate_USCOREnote_USCOREto_USCOREmoduleResponse(soap, tag, id, (struct ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse *const*)ptr, "ns1:relate_note_to_moduleResponse");
	case SOAP_TYPE_PointerTons1__get_USCOREnote_USCOREattachmentResponse:
		return soap_out_PointerTons1__get_USCOREnote_USCOREattachmentResponse(soap, tag, id, (struct ns1__get_USCOREnote_USCOREattachmentResponse *const*)ptr, "ns1:get_note_attachmentResponse");
	case SOAP_TYPE_PointerTons1__return_USCOREnote_USCOREattachment:
		return soap_out_PointerTons1__return_USCOREnote_USCOREattachment(soap, tag, id, (struct ns1__return_USCOREnote_USCOREattachment *const*)ptr, "ns1:return_note_attachment");
	case SOAP_TYPE_PointerTons1__set_USCOREnote_USCOREattachmentResponse:
		return soap_out_PointerTons1__set_USCOREnote_USCOREattachmentResponse(soap, tag, id, (struct ns1__set_USCOREnote_USCOREattachmentResponse *const*)ptr, "ns1:set_note_attachmentResponse");
	case SOAP_TYPE_PointerTons1__set_USCOREentriesResponse:
		return soap_out_PointerTons1__set_USCOREentriesResponse(soap, tag, id, (struct ns1__set_USCOREentriesResponse *const*)ptr, "ns1:set_entriesResponse");
	case SOAP_TYPE_PointerTons1__set_USCOREentries_USCOREresult:
		return soap_out_PointerTons1__set_USCOREentries_USCOREresult(soap, tag, id, (struct ns1__set_USCOREentries_USCOREresult *const*)ptr, "ns1:set_entries_result");
	case SOAP_TYPE_PointerTons1__set_USCOREentryResponse:
		return soap_out_PointerTons1__set_USCOREentryResponse(soap, tag, id, (struct ns1__set_USCOREentryResponse *const*)ptr, "ns1:set_entryResponse");
	case SOAP_TYPE_PointerTons1__get_USCOREentriesResponse:
		return soap_out_PointerTons1__get_USCOREentriesResponse(soap, tag, id, (struct ns1__get_USCOREentriesResponse *const*)ptr, "ns1:get_entriesResponse");
	case SOAP_TYPE_PointerTons1__get_USCOREentryResponse:
		return soap_out_PointerTons1__get_USCOREentryResponse(soap, tag, id, (struct ns1__get_USCOREentryResponse *const*)ptr, "ns1:get_entryResponse");
	case SOAP_TYPE_PointerTons1__get_USCOREentry_USCOREresult:
		return soap_out_PointerTons1__get_USCOREentry_USCOREresult(soap, tag, id, (struct ns1__get_USCOREentry_USCOREresult *const*)ptr, "ns1:get_entry_result");
	case SOAP_TYPE_PointerTons1__get_USCOREentry_USCORElistResponse:
		return soap_out_PointerTons1__get_USCOREentry_USCORElistResponse(soap, tag, id, (struct ns1__get_USCOREentry_USCORElistResponse *const*)ptr, "ns1:get_entry_listResponse");
	case SOAP_TYPE_PointerTons1__get_USCOREentry_USCORElist_USCOREresult:
		return soap_out_PointerTons1__get_USCOREentry_USCORElist_USCOREresult(soap, tag, id, (struct ns1__get_USCOREentry_USCORElist_USCOREresult *const*)ptr, "ns1:get_entry_list_result");
	case SOAP_TYPE_PointerTons1__loginResponse:
		return soap_out_PointerTons1__loginResponse(soap, tag, id, (struct ns1__loginResponse *const*)ptr, "ns1:loginResponse");
	case SOAP_TYPE_PointerTons1__user_USCOREauth:
		return soap_out_PointerTons1__user_USCOREauth(soap, tag, id, (struct ns1__user_USCOREauth *const*)ptr, "ns1:user_auth");
	case SOAP_TYPE_PointerTons1__set_USCOREentry_USCOREresult:
		return soap_out_PointerTons1__set_USCOREentry_USCOREresult(soap, tag, id, (struct ns1__set_USCOREentry_USCOREresult *const*)ptr, "ns1:set_entry_result");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerToPointerTons1__user_USCOREdetail:
		return soap_out_PointerToPointerTons1__user_USCOREdetail(soap, tag, id, (struct ns1__user_USCOREdetail **const*)ptr, "ns1:user_detail");
	case SOAP_TYPE_PointerTons1__user_USCOREdetail:
		return soap_out_PointerTons1__user_USCOREdetail(soap, tag, id, (struct ns1__user_USCOREdetail *const*)ptr, "ns1:user_detail");
	case SOAP_TYPE_PointerToPointerTons1__contact_USCOREdetail:
		return soap_out_PointerToPointerTons1__contact_USCOREdetail(soap, tag, id, (struct ns1__contact_USCOREdetail **const*)ptr, "ns1:contact_detail");
	case SOAP_TYPE_PointerTons1__contact_USCOREdetail:
		return soap_out_PointerTons1__contact_USCOREdetail(soap, tag, id, (struct ns1__contact_USCOREdetail *const*)ptr, "ns1:contact_detail");
	case SOAP_TYPE_PointerToPointerTons1__newsletter:
		return soap_out_PointerToPointerTons1__newsletter(soap, tag, id, (struct ns1__newsletter **const*)ptr, "ns1:newsletter");
	case SOAP_TYPE_PointerTons1__newsletter:
		return soap_out_PointerTons1__newsletter(soap, tag, id, (struct ns1__newsletter *const*)ptr, "ns1:newsletter");
	case SOAP_TYPE_PointerToPointerTons1__name_USCOREvalue_USCOREoperator:
		return soap_out_PointerToPointerTons1__name_USCOREvalue_USCOREoperator(soap, tag, id, (struct ns1__name_USCOREvalue_USCOREoperator **const*)ptr, "ns1:name_value_operator");
	case SOAP_TYPE_PointerTons1__name_USCOREvalue_USCOREoperator:
		return soap_out_PointerTons1__name_USCOREvalue_USCOREoperator(soap, tag, id, (struct ns1__name_USCOREvalue_USCOREoperator *const*)ptr, "ns1:name_value_operator");
	case SOAP_TYPE_PointerToPointerToselect_USCOREfields:
		return soap_out_PointerToPointerToselect_USCOREfields(soap, tag, id, (struct select_USCOREfields **const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToPointerTons1__set_USCORErelationship_USCOREvalue:
		return soap_out_PointerToPointerTons1__set_USCORErelationship_USCOREvalue(soap, tag, id, (struct ns1__set_USCORErelationship_USCOREvalue **const*)ptr, "ns1:set_relationship_value");
	case SOAP_TYPE_PointerTons1__set_USCORErelationship_USCOREvalue:
		return soap_out_PointerTons1__set_USCORErelationship_USCOREvalue(soap, tag, id, (struct ns1__set_USCORErelationship_USCOREvalue *const*)ptr, "ns1:set_relationship_value");
	case SOAP_TYPE_PointerToPointerTons1__id_USCOREmod:
		return soap_out_PointerToPointerTons1__id_USCOREmod(soap, tag, id, (struct ns1__id_USCOREmod **const*)ptr, "ns1:id_mod");
	case SOAP_TYPE_PointerTons1__id_USCOREmod:
		return soap_out_PointerTons1__id_USCOREmod(soap, tag, id, (struct ns1__id_USCOREmod *const*)ptr, "ns1:id_mod");
	case SOAP_TYPE_PointerToPointerTolink_USCORElist:
		return soap_out_PointerToPointerTolink_USCORElist(soap, tag, id, (struct link_USCORElist **const*)ptr, "ns1:link_name_value");
	case SOAP_TYPE_PointerToPointerTons1__link_USCOREname_USCOREvalue:
		return soap_out_PointerToPointerTons1__link_USCOREname_USCOREvalue(soap, tag, id, (struct ns1__link_USCOREname_USCOREvalue **const*)ptr, "ns1:link_name_value");
	case SOAP_TYPE_PointerTons1__link_USCOREname_USCOREvalue:
		return soap_out_PointerTons1__link_USCOREname_USCOREvalue(soap, tag, id, (struct ns1__link_USCOREname_USCOREvalue *const*)ptr, "ns1:link_name_value");
	case SOAP_TYPE_PointerToPointerTolink_USCOREvalue:
		return soap_out_PointerToPointerTolink_USCOREvalue(soap, tag, id, (struct link_USCOREvalue **const*)ptr, "ns1:name_value");
	case SOAP_TYPE_PointerTolink_USCOREvalue:
		return soap_out_PointerTolink_USCOREvalue(soap, tag, id, (struct link_USCOREvalue *const*)ptr, "ns1:name_value");
	case SOAP_TYPE_PointerToPointerTons1__entry_USCOREvalue:
		return soap_out_PointerToPointerTons1__entry_USCOREvalue(soap, tag, id, (struct ns1__entry_USCOREvalue **const*)ptr, "ns1:entry_value");
	case SOAP_TYPE_PointerTons1__entry_USCOREvalue:
		return soap_out_PointerTons1__entry_USCOREvalue(soap, tag, id, (struct ns1__entry_USCOREvalue *const*)ptr, "ns1:entry_value");
	case SOAP_TYPE_PointerTostring:
		return soap_out_PointerTostring(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToPointerToname_USCOREvalue_USCORElist:
		return soap_out_PointerToPointerToname_USCOREvalue_USCORElist(soap, tag, id, (struct name_USCOREvalue_USCORElist **const*)ptr, "ns1:name_value");
	case SOAP_TYPE_PointerToPointerTons1__name_USCOREvalue:
		return soap_out_PointerToPointerTons1__name_USCOREvalue(soap, tag, id, (struct ns1__name_USCOREvalue **const*)ptr, "ns1:name_value");
	case SOAP_TYPE_PointerTons1__name_USCOREvalue:
		return soap_out_PointerTons1__name_USCOREvalue(soap, tag, id, (struct ns1__name_USCOREvalue *const*)ptr, "ns1:name_value");
	case SOAP_TYPE_PointerToPointerTons1__link_USCOREfield:
		return soap_out_PointerToPointerTons1__link_USCOREfield(soap, tag, id, (struct ns1__link_USCOREfield **const*)ptr, "ns1:link_field");
	case SOAP_TYPE_PointerTons1__link_USCOREfield:
		return soap_out_PointerTons1__link_USCOREfield(soap, tag, id, (struct ns1__link_USCOREfield *const*)ptr, "ns1:link_field");
	case SOAP_TYPE_PointerToPointerTons1__field:
		return soap_out_PointerToPointerTons1__field(soap, tag, id, (struct ns1__field **const*)ptr, "ns1:field");
	case SOAP_TYPE_PointerTons1__field:
		return soap_out_PointerTons1__field(soap, tag, id, (struct ns1__field *const*)ptr, "ns1:field");
	case SOAP_TYPE_PointerToname_USCOREvalue_USCORElists:
		return soap_out_PointerToname_USCOREvalue_USCORElists(soap, tag, id, (struct name_USCOREvalue_USCORElists *const*)ptr, "ns1:name_value");
	case SOAP_TYPE_PointerTonewsletter_USCORElist:
		return soap_out_PointerTonewsletter_USCORElist(soap, tag, id, (struct newsletter_USCORElist *const*)ptr, "ns1:newsletter");
	case SOAP_TYPE_PointerTons1__document_USCORErevision:
		return soap_out_PointerTons1__document_USCORErevision(soap, tag, id, (struct ns1__document_USCORErevision *const*)ptr, "ns1:document_revision");
	case SOAP_TYPE_PointerToids_USCOREmods:
		return soap_out_PointerToids_USCOREmods(soap, tag, id, (struct ids_USCOREmods *const*)ptr, "ns1:id_mod");
	case SOAP_TYPE_PointerTolink_USCORElist:
		return soap_out_PointerTolink_USCORElist(soap, tag, id, (struct link_USCORElist *const*)ptr, "ns1:link_name_value");
	case SOAP_TYPE_PointerTolink_USCORElists:
		return soap_out_PointerTolink_USCORElists(soap, tag, id, (struct link_USCORElists *const*)ptr, "ns1:link_name_value");
	case SOAP_TYPE_PointerToentry_USCORElist:
		return soap_out_PointerToentry_USCORElist(soap, tag, id, (struct entry_USCORElist *const*)ptr, "ns1:entry_value");
	case SOAP_TYPE_PointerTolink_USCOREarray_USCORElist:
		return soap_out_PointerTolink_USCOREarray_USCORElist(soap, tag, id, (struct link_USCOREarray_USCORElist *const*)ptr, "ns1:name_value");
	case SOAP_TYPE_PointerToselect_USCOREfields:
		return soap_out_PointerToselect_USCOREfields(soap, tag, id, (struct select_USCOREfields *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTolink_USCOREfield_USCORElist:
		return soap_out_PointerTolink_USCOREfield_USCORElist(soap, tag, id, (struct link_USCOREfield_USCORElist *const*)ptr, "ns1:link_field");
	case SOAP_TYPE_PointerTofield_USCORElist:
		return soap_out_PointerTofield_USCORElist(soap, tag, id, (struct field_USCORElist *const*)ptr, "ns1:field");
	case SOAP_TYPE_PointerToname_USCOREvalue_USCORElist:
		return soap_out_PointerToname_USCOREvalue_USCORElist(soap, tag, id, (struct name_USCOREvalue_USCORElist *const*)ptr, "ns1:name_value");
	case SOAP_TYPE_PointerTons1__error_USCOREvalue:
		return soap_out_PointerTons1__error_USCOREvalue(soap, tag, id, (struct ns1__error_USCOREvalue *const*)ptr, "ns1:error_value");
	case SOAP_TYPE_PointerTons1__note_USCOREattachment:
		return soap_out_PointerTons1__note_USCOREattachment(soap, tag, id, (struct ns1__note_USCOREattachment *const*)ptr, "ns1:note_attachment");
	case SOAP_TYPE_PointerTons1__new_USCOREnote_USCOREattachment:
		return soap_out_PointerTons1__new_USCOREnote_USCOREattachment(soap, tag, id, (struct ns1__new_USCOREnote_USCOREattachment *const*)ptr, "ns1:new_note_attachment");
	case SOAP_TYPE_xsd__date:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:date");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, "xsd:QName", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_ns1__create_USCOREcase:
		soap_serialize_ns1__create_USCOREcase(soap, (const struct ns1__create_USCOREcase *)ptr);
		break;
	case SOAP_TYPE_ns1__create_USCOREcaseResponse:
		soap_serialize_ns1__create_USCOREcaseResponse(soap, (const struct ns1__create_USCOREcaseResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__create_USCOREopportunity:
		soap_serialize_ns1__create_USCOREopportunity(soap, (const struct ns1__create_USCOREopportunity *)ptr);
		break;
	case SOAP_TYPE_ns1__create_USCOREopportunityResponse:
		soap_serialize_ns1__create_USCOREopportunityResponse(soap, (const struct ns1__create_USCOREopportunityResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__create_USCOREaccount:
		soap_serialize_ns1__create_USCOREaccount(soap, (const struct ns1__create_USCOREaccount *)ptr);
		break;
	case SOAP_TYPE_ns1__create_USCOREaccountResponse:
		soap_serialize_ns1__create_USCOREaccountResponse(soap, (const struct ns1__create_USCOREaccountResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__create_USCORElead:
		soap_serialize_ns1__create_USCORElead(soap, (const struct ns1__create_USCORElead *)ptr);
		break;
	case SOAP_TYPE_ns1__create_USCOREleadResponse:
		soap_serialize_ns1__create_USCOREleadResponse(soap, (const struct ns1__create_USCOREleadResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__create_USCOREcontact:
		soap_serialize_ns1__create_USCOREcontact(soap, (const struct ns1__create_USCOREcontact *)ptr);
		break;
	case SOAP_TYPE_ns1__create_USCOREcontactResponse:
		soap_serialize_ns1__create_USCOREcontactResponse(soap, (const struct ns1__create_USCOREcontactResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__track_USCOREemail:
		soap_serialize_ns1__track_USCOREemail(soap, (const struct ns1__track_USCOREemail *)ptr);
		break;
	case SOAP_TYPE_ns1__track_USCOREemailResponse:
		soap_serialize_ns1__track_USCOREemailResponse(soap, (const struct ns1__track_USCOREemailResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__search:
		soap_serialize_ns1__search(soap, (const struct ns1__search *)ptr);
		break;
	case SOAP_TYPE_ns1__searchResponse:
		soap_serialize_ns1__searchResponse(soap, (const struct ns1__searchResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__user_USCORElist:
		soap_serialize_ns1__user_USCORElist(soap, (const struct ns1__user_USCORElist *)ptr);
		break;
	case SOAP_TYPE_ns1__user_USCORElistResponse:
		soap_serialize_ns1__user_USCORElistResponse(soap, (const struct ns1__user_USCORElistResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREcontact_USCORErelationships:
		soap_serialize_ns1__get_USCOREcontact_USCORErelationships(soap, (const struct ns1__get_USCOREcontact_USCORErelationships *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREcontact_USCORErelationshipsResponse:
		soap_serialize_ns1__get_USCOREcontact_USCORErelationshipsResponse(soap, (const struct ns1__get_USCOREcontact_USCORErelationshipsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__contact_USCOREby_USCOREemail:
		soap_serialize_ns1__contact_USCOREby_USCOREemail(soap, (const struct ns1__contact_USCOREby_USCOREemail *)ptr);
		break;
	case SOAP_TYPE_ns1__contact_USCOREby_USCOREemailResponse:
		soap_serialize_ns1__contact_USCOREby_USCOREemailResponse(soap, (const struct ns1__contact_USCOREby_USCOREemailResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__end_USCOREsession:
		soap_serialize_ns1__end_USCOREsession(soap, (const struct ns1__end_USCOREsession *)ptr);
		break;
	case SOAP_TYPE_ns1__end_USCOREsessionResponse:
		soap_serialize_ns1__end_USCOREsessionResponse(soap, (const struct ns1__end_USCOREsessionResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__create_USCOREsession:
		soap_serialize_ns1__create_USCOREsession(soap, (const struct ns1__create_USCOREsession *)ptr);
		break;
	case SOAP_TYPE_ns1__create_USCOREsessionResponse:
		soap_serialize_ns1__create_USCOREsessionResponse(soap, (const struct ns1__create_USCOREsessionResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREattendee_USCORElist:
		soap_serialize_ns1__get_USCOREattendee_USCORElist(soap, (const struct ns1__get_USCOREattendee_USCORElist *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREattendee_USCORElistResponse:
		soap_serialize_ns1__get_USCOREattendee_USCORElistResponse(soap, (const struct ns1__get_USCOREattendee_USCORElistResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREmodified_USCOREentries:
		soap_serialize_ns1__get_USCOREmodified_USCOREentries(soap, (const struct ns1__get_USCOREmodified_USCOREentries *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREmodified_USCOREentriesResponse:
		soap_serialize_ns1__get_USCOREmodified_USCOREentriesResponse(soap, (const struct ns1__get_USCOREmodified_USCOREentriesResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__sync_USCOREget_USCOREmodified_USCORErelationships:
		soap_serialize_ns1__sync_USCOREget_USCOREmodified_USCORErelationships(soap, (const struct ns1__sync_USCOREget_USCOREmodified_USCORErelationships *)ptr);
		break;
	case SOAP_TYPE_ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse:
		soap_serialize_ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse(soap, (const struct ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__set_USCOREentries_USCOREdetails:
		soap_serialize_ns1__set_USCOREentries_USCOREdetails(soap, (const struct ns1__set_USCOREentries_USCOREdetails *)ptr);
		break;
	case SOAP_TYPE_ns1__set_USCOREentries_USCOREdetailsResponse:
		soap_serialize_ns1__set_USCOREentries_USCOREdetailsResponse(soap, (const struct ns1__set_USCOREentries_USCOREdetailsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREentries_USCOREcount:
		soap_serialize_ns1__get_USCOREentries_USCOREcount(soap, (const struct ns1__get_USCOREentries_USCOREcount *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREentries_USCOREcountResponse:
		soap_serialize_ns1__get_USCOREentries_USCOREcountResponse(soap, (const struct ns1__get_USCOREentries_USCOREcountResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__set_USCOREcampaign_USCOREmerge:
		soap_serialize_ns1__set_USCOREcampaign_USCOREmerge(soap, (const struct ns1__set_USCOREcampaign_USCOREmerge *)ptr);
		break;
	case SOAP_TYPE_ns1__set_USCOREcampaign_USCOREmergeResponse:
		soap_serialize_ns1__set_USCOREcampaign_USCOREmergeResponse(soap, (const struct ns1__set_USCOREcampaign_USCOREmergeResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREdocument_USCORErevision:
		soap_serialize_ns1__get_USCOREdocument_USCORErevision(soap, (const struct ns1__get_USCOREdocument_USCORErevision *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREdocument_USCORErevisionResponse:
		soap_serialize_ns1__get_USCOREdocument_USCORErevisionResponse(soap, (const struct ns1__get_USCOREdocument_USCORErevisionResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocument2:
		soap_serialize_ns1__get_USCOREmailmerge_USCOREdocument2(soap, (const struct ns1__get_USCOREmailmerge_USCOREdocument2 *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocument2Response:
		soap_serialize_ns1__get_USCOREmailmerge_USCOREdocument2Response(soap, (const struct ns1__get_USCOREmailmerge_USCOREdocument2Response *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocument:
		soap_serialize_ns1__get_USCOREmailmerge_USCOREdocument(soap, (const struct ns1__get_USCOREmailmerge_USCOREdocument *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocumentResponse:
		soap_serialize_ns1__get_USCOREmailmerge_USCOREdocumentResponse(soap, (const struct ns1__get_USCOREmailmerge_USCOREdocumentResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__search_USCOREby_USCOREmodule:
		soap_serialize_ns1__search_USCOREby_USCOREmodule(soap, (const struct ns1__search_USCOREby_USCOREmodule *)ptr);
		break;
	case SOAP_TYPE_ns1__search_USCOREby_USCOREmoduleResponse:
		soap_serialize_ns1__search_USCOREby_USCOREmoduleResponse(soap, (const struct ns1__search_USCOREby_USCOREmoduleResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__set_USCOREdocument_USCORErevision:
		soap_serialize_ns1__set_USCOREdocument_USCORErevision(soap, (const struct ns1__set_USCOREdocument_USCORErevision *)ptr);
		break;
	case SOAP_TYPE_ns1__set_USCOREdocument_USCORErevisionResponse:
		soap_serialize_ns1__set_USCOREdocument_USCORErevisionResponse(soap, (const struct ns1__set_USCOREdocument_USCORErevisionResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__set_USCORErelationships:
		soap_serialize_ns1__set_USCORErelationships(soap, (const struct ns1__set_USCORErelationships *)ptr);
		break;
	case SOAP_TYPE_ns1__set_USCORErelationshipsResponse:
		soap_serialize_ns1__set_USCORErelationshipsResponse(soap, (const struct ns1__set_USCORErelationshipsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__set_USCORErelationship:
		soap_serialize_ns1__set_USCORErelationship(soap, (const struct ns1__set_USCORErelationship *)ptr);
		break;
	case SOAP_TYPE_ns1__set_USCORErelationshipResponse:
		soap_serialize_ns1__set_USCORErelationshipResponse(soap, (const struct ns1__set_USCORErelationshipResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCORErelationships:
		soap_serialize_ns1__get_USCORErelationships(soap, (const struct ns1__get_USCORErelationships *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCORErelationshipsResponse:
		soap_serialize_ns1__get_USCORErelationshipsResponse(soap, (const struct ns1__get_USCORErelationshipsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREserver_USCOREversion:
		soap_serialize_ns1__get_USCOREserver_USCOREversion(soap, (const struct ns1__get_USCOREserver_USCOREversion *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREserver_USCOREversionResponse:
		soap_serialize_ns1__get_USCOREserver_USCOREversionResponse(soap, (const struct ns1__get_USCOREserver_USCOREversionResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREsugar_USCOREflavor:
		soap_serialize_ns1__get_USCOREsugar_USCOREflavor(soap, (const struct ns1__get_USCOREsugar_USCOREflavor *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREsugar_USCOREflavorResponse:
		soap_serialize_ns1__get_USCOREsugar_USCOREflavorResponse(soap, (const struct ns1__get_USCOREsugar_USCOREflavorResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREgmt_USCOREtime:
		soap_serialize_ns1__get_USCOREgmt_USCOREtime(soap, (const struct ns1__get_USCOREgmt_USCOREtime *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREgmt_USCOREtimeResponse:
		soap_serialize_ns1__get_USCOREgmt_USCOREtimeResponse(soap, (const struct ns1__get_USCOREgmt_USCOREtimeResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREserver_USCOREtime:
		soap_serialize_ns1__get_USCOREserver_USCOREtime(soap, (const struct ns1__get_USCOREserver_USCOREtime *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREserver_USCOREtimeResponse:
		soap_serialize_ns1__get_USCOREserver_USCOREtimeResponse(soap, (const struct ns1__get_USCOREserver_USCOREtimeResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREuser_USCOREteam_USCOREid:
		soap_serialize_ns1__get_USCOREuser_USCOREteam_USCOREid(soap, (const struct ns1__get_USCOREuser_USCOREteam_USCOREid *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREuser_USCOREteam_USCOREidResponse:
		soap_serialize_ns1__get_USCOREuser_USCOREteam_USCOREidResponse(soap, (const struct ns1__get_USCOREuser_USCOREteam_USCOREidResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREuser_USCOREid:
		soap_serialize_ns1__get_USCOREuser_USCOREid(soap, (const struct ns1__get_USCOREuser_USCOREid *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREuser_USCOREidResponse:
		soap_serialize_ns1__get_USCOREuser_USCOREidResponse(soap, (const struct ns1__get_USCOREuser_USCOREidResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__update_USCOREportal_USCOREuser:
		soap_serialize_ns1__update_USCOREportal_USCOREuser(soap, (const struct ns1__update_USCOREportal_USCOREuser *)ptr);
		break;
	case SOAP_TYPE_ns1__update_USCOREportal_USCOREuserResponse:
		soap_serialize_ns1__update_USCOREportal_USCOREuserResponse(soap, (const struct ns1__update_USCOREportal_USCOREuserResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREavailable_USCOREmodules:
		soap_serialize_ns1__get_USCOREavailable_USCOREmodules(soap, (const struct ns1__get_USCOREavailable_USCOREmodules *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREavailable_USCOREmodulesResponse:
		soap_serialize_ns1__get_USCOREavailable_USCOREmodulesResponse(soap, (const struct ns1__get_USCOREavailable_USCOREmodulesResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREmodule_USCOREfields:
		soap_serialize_ns1__get_USCOREmodule_USCOREfields(soap, (const struct ns1__get_USCOREmodule_USCOREfields *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREmodule_USCOREfieldsResponse:
		soap_serialize_ns1__get_USCOREmodule_USCOREfieldsResponse(soap, (const struct ns1__get_USCOREmodule_USCOREfieldsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__logout:
		soap_serialize_ns1__logout(soap, (const struct ns1__logout *)ptr);
		break;
	case SOAP_TYPE_ns1__logoutResponse:
		soap_serialize_ns1__logoutResponse(soap, (const struct ns1__logoutResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCORErelated_USCOREnotes:
		soap_serialize_ns1__get_USCORErelated_USCOREnotes(soap, (const struct ns1__get_USCORErelated_USCOREnotes *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCORErelated_USCOREnotesResponse:
		soap_serialize_ns1__get_USCORErelated_USCOREnotesResponse(soap, (const struct ns1__get_USCORErelated_USCOREnotesResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__relate_USCOREnote_USCOREto_USCOREmodule:
		soap_serialize_ns1__relate_USCOREnote_USCOREto_USCOREmodule(soap, (const struct ns1__relate_USCOREnote_USCOREto_USCOREmodule *)ptr);
		break;
	case SOAP_TYPE_ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse:
		soap_serialize_ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse(soap, (const struct ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREnote_USCOREattachment:
		soap_serialize_ns1__get_USCOREnote_USCOREattachment(soap, (const struct ns1__get_USCOREnote_USCOREattachment *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREnote_USCOREattachmentResponse:
		soap_serialize_ns1__get_USCOREnote_USCOREattachmentResponse(soap, (const struct ns1__get_USCOREnote_USCOREattachmentResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__set_USCOREnote_USCOREattachment:
		soap_serialize_ns1__set_USCOREnote_USCOREattachment(soap, (const struct ns1__set_USCOREnote_USCOREattachment *)ptr);
		break;
	case SOAP_TYPE_ns1__set_USCOREnote_USCOREattachmentResponse:
		soap_serialize_ns1__set_USCOREnote_USCOREattachmentResponse(soap, (const struct ns1__set_USCOREnote_USCOREattachmentResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__set_USCOREentries:
		soap_serialize_ns1__set_USCOREentries(soap, (const struct ns1__set_USCOREentries *)ptr);
		break;
	case SOAP_TYPE_ns1__set_USCOREentriesResponse:
		soap_serialize_ns1__set_USCOREentriesResponse(soap, (const struct ns1__set_USCOREentriesResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__set_USCOREentry:
		soap_serialize_ns1__set_USCOREentry(soap, (const struct ns1__set_USCOREentry *)ptr);
		break;
	case SOAP_TYPE_ns1__set_USCOREentryResponse:
		soap_serialize_ns1__set_USCOREentryResponse(soap, (const struct ns1__set_USCOREentryResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREentries:
		soap_serialize_ns1__get_USCOREentries(soap, (const struct ns1__get_USCOREentries *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREentriesResponse:
		soap_serialize_ns1__get_USCOREentriesResponse(soap, (const struct ns1__get_USCOREentriesResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREentry:
		soap_serialize_ns1__get_USCOREentry(soap, (const struct ns1__get_USCOREentry *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREentryResponse:
		soap_serialize_ns1__get_USCOREentryResponse(soap, (const struct ns1__get_USCOREentryResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREentry_USCORElist:
		soap_serialize_ns1__get_USCOREentry_USCORElist(soap, (const struct ns1__get_USCOREentry_USCORElist *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREentry_USCORElistResponse:
		soap_serialize_ns1__get_USCOREentry_USCORElistResponse(soap, (const struct ns1__get_USCOREentry_USCORElistResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__seamless_USCORElogin:
		soap_serialize_ns1__seamless_USCORElogin(soap, (const struct ns1__seamless_USCORElogin *)ptr);
		break;
	case SOAP_TYPE_ns1__seamless_USCOREloginResponse:
		soap_serialize_ns1__seamless_USCOREloginResponse(soap, (const struct ns1__seamless_USCOREloginResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__is_USCOREloopback:
		soap_serialize_ns1__is_USCOREloopback(soap, (const struct ns1__is_USCOREloopback *)ptr);
		break;
	case SOAP_TYPE_ns1__is_USCOREloopbackResponse:
		soap_serialize_ns1__is_USCOREloopbackResponse(soap, (const struct ns1__is_USCOREloopbackResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__login:
		soap_serialize_ns1__login(soap, (const struct ns1__login *)ptr);
		break;
	case SOAP_TYPE_ns1__loginResponse:
		soap_serialize_ns1__loginResponse(soap, (const struct ns1__loginResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__is_USCOREuser_USCOREadmin:
		soap_serialize_ns1__is_USCOREuser_USCOREadmin(soap, (const struct ns1__is_USCOREuser_USCOREadmin *)ptr);
		break;
	case SOAP_TYPE_ns1__is_USCOREuser_USCOREadminResponse:
		soap_serialize_ns1__is_USCOREuser_USCOREadminResponse(soap, (const struct ns1__is_USCOREuser_USCOREadminResponse *)ptr);
		break;
	case SOAP_TYPE_user_USCOREdetail_USCOREarray:
		soap_serialize_user_USCOREdetail_USCOREarray(soap, (const struct user_USCOREdetail_USCOREarray *)ptr);
		break;
	case SOAP_TYPE_contact_USCOREdetail_USCOREarray:
		soap_serialize_contact_USCOREdetail_USCOREarray(soap, (const struct contact_USCOREdetail_USCOREarray *)ptr);
		break;
	case SOAP_TYPE_str_USCOREarray:
		soap_serialize_str_USCOREarray(soap, (const struct str_USCOREarray *)ptr);
		break;
	case SOAP_TYPE_name_USCOREvalue_USCOREoperator_USCORElist:
		soap_serialize_name_USCOREvalue_USCOREoperator_USCORElist(soap, (const struct name_USCOREvalue_USCOREoperator_USCORElist *)ptr);
		break;
	case SOAP_TYPE_new_USCOREset_USCORErelationhip_USCOREids:
		soap_serialize_new_USCOREset_USCORErelationhip_USCOREids(soap, (const struct new_USCOREset_USCORErelationhip_USCOREids *)ptr);
		break;
	case SOAP_TYPE_set_USCORErelationship_USCORElist:
		soap_serialize_set_USCORErelationship_USCORElist(soap, (const struct set_USCORErelationship_USCORElist *)ptr);
		break;
	case SOAP_TYPE_link_USCOREvalue:
		soap_serialize_link_USCOREvalue(soap, (const struct link_USCOREvalue *)ptr);
		break;
	case SOAP_TYPE_ns1__user_USCOREdetail:
		soap_serialize_ns1__user_USCOREdetail(soap, (const struct ns1__user_USCOREdetail *)ptr);
		break;
	case SOAP_TYPE_ns1__contact_USCOREdetail:
		soap_serialize_ns1__contact_USCOREdetail(soap, (const struct ns1__contact_USCOREdetail *)ptr);
		break;
	case SOAP_TYPE_ns1__set_USCOREentries_USCOREdetail_USCOREresult:
		soap_serialize_ns1__set_USCOREentries_USCOREdetail_USCOREresult(soap, (const struct ns1__set_USCOREentries_USCOREdetail_USCOREresult *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREentries_USCOREcount_USCOREresult:
		soap_serialize_ns1__get_USCOREentries_USCOREcount_USCOREresult(soap, (const struct ns1__get_USCOREentries_USCOREcount_USCOREresult *)ptr);
		break;
	case SOAP_TYPE_name_USCOREvalue_USCORElists:
		soap_serialize_name_USCOREvalue_USCORElists(soap, (const struct name_USCOREvalue_USCORElists *)ptr);
		break;
	case SOAP_TYPE_ns1__name_USCOREvalue_USCORElists_USCOREerror:
		soap_serialize_ns1__name_USCOREvalue_USCORElists_USCOREerror(soap, (const struct ns1__name_USCOREvalue_USCORElists_USCOREerror *)ptr);
		break;
	case SOAP_TYPE_newsletter_USCORElist:
		soap_serialize_newsletter_USCORElist(soap, (const struct newsletter_USCORElist *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREsubscription_USCORElists_USCOREresult:
		soap_serialize_ns1__get_USCOREsubscription_USCORElists_USCOREresult(soap, (const struct ns1__get_USCOREsubscription_USCORElists_USCOREresult *)ptr);
		break;
	case SOAP_TYPE_ns1__newsletter:
		soap_serialize_ns1__newsletter(soap, (const struct ns1__newsletter *)ptr);
		break;
	case SOAP_TYPE_ns1__name_USCOREvalue_USCOREoperator:
		soap_serialize_ns1__name_USCOREvalue_USCOREoperator(soap, (const struct ns1__name_USCOREvalue_USCOREoperator *)ptr);
		break;
	case SOAP_TYPE_ns1__new_USCOREreturn_USCOREdocument_USCORErevision:
		soap_serialize_ns1__new_USCOREreturn_USCOREdocument_USCORErevision(soap, (const struct ns1__new_USCOREreturn_USCOREdocument_USCORErevision *)ptr);
		break;
	case SOAP_TYPE_ns1__return_USCOREdocument_USCORErevision:
		soap_serialize_ns1__return_USCOREdocument_USCORErevision(soap, (const struct ns1__return_USCOREdocument_USCORErevision *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREquick_USCOREsync_USCOREresult_USCOREencoded:
		soap_serialize_ns1__get_USCOREquick_USCOREsync_USCOREresult_USCOREencoded(soap, (const struct ns1__get_USCOREquick_USCOREsync_USCOREresult_USCOREencoded *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREsync_USCOREresult_USCOREencoded:
		soap_serialize_ns1__get_USCOREsync_USCOREresult_USCOREencoded(soap, (const struct ns1__get_USCOREsync_USCOREresult_USCOREencoded *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded:
		soap_serialize_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded(soap, (const struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded *)ptr);
		break;
	case SOAP_TYPE_ns1__document_USCORErevision:
		soap_serialize_ns1__document_USCORErevision(soap, (const struct ns1__document_USCORErevision *)ptr);
		break;
	case SOAP_TYPE_ns1__set_USCORErelationship_USCORElist_USCOREresult:
		soap_serialize_ns1__set_USCORErelationship_USCORElist_USCOREresult(soap, (const struct ns1__set_USCORErelationship_USCORElist_USCOREresult *)ptr);
		break;
	case SOAP_TYPE_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult:
		soap_serialize_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(soap, (const struct ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult *)ptr);
		break;
	case SOAP_TYPE_ns1__set_USCORErelationship_USCOREvalue:
		soap_serialize_ns1__set_USCORErelationship_USCOREvalue(soap, (const struct ns1__set_USCORErelationship_USCOREvalue *)ptr);
		break;
	case SOAP_TYPE_ids_USCOREmods:
		soap_serialize_ids_USCOREmods(soap, (const struct ids_USCOREmods *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCORErelationships_USCOREresult:
		soap_serialize_ns1__get_USCORErelationships_USCOREresult(soap, (const struct ns1__get_USCORErelationships_USCOREresult *)ptr);
		break;
	case SOAP_TYPE_ns1__id_USCOREmod:
		soap_serialize_ns1__id_USCOREmod(soap, (const struct ns1__id_USCOREmod *)ptr);
		break;
	case SOAP_TYPE_ns1__set_USCOREentries_USCOREresult:
		soap_serialize_ns1__set_USCOREentries_USCOREresult(soap, (const struct ns1__set_USCOREentries_USCOREresult *)ptr);
		break;
	case SOAP_TYPE_ns1__new_USCOREset_USCOREentries_USCOREresult:
		soap_serialize_ns1__new_USCOREset_USCOREentries_USCOREresult(soap, (const struct ns1__new_USCOREset_USCOREentries_USCOREresult *)ptr);
		break;
	case SOAP_TYPE_ns1__new_USCOREset_USCOREentry_USCOREresult:
		soap_serialize_ns1__new_USCOREset_USCOREentry_USCOREresult(soap, (const struct ns1__new_USCOREset_USCOREentry_USCOREresult *)ptr);
		break;
	case SOAP_TYPE_ns1__set_USCOREentry_USCOREresult:
		soap_serialize_ns1__set_USCOREentry_USCOREresult(soap, (const struct ns1__set_USCOREentry_USCOREresult *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREserver_USCOREinfo_USCOREresult:
		soap_serialize_ns1__get_USCOREserver_USCOREinfo_USCOREresult(soap, (const struct ns1__get_USCOREserver_USCOREinfo_USCOREresult *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREentry_USCOREresult:
		soap_serialize_ns1__get_USCOREentry_USCOREresult(soap, (const struct ns1__get_USCOREentry_USCOREresult *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2:
		soap_serialize_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2(soap, (const struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2 *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREentry_USCORElist_USCOREresult:
		soap_serialize_ns1__get_USCOREentry_USCORElist_USCOREresult(soap, (const struct ns1__get_USCOREentry_USCORElist_USCOREresult *)ptr);
		break;
	case SOAP_TYPE_link_USCORElist:
		soap_serialize_link_USCORElist(soap, (const struct link_USCORElist *)ptr);
		break;
	case SOAP_TYPE_ns1__return_USCOREsearch_USCOREresult:
		soap_serialize_ns1__return_USCOREsearch_USCOREresult(soap, (const struct ns1__return_USCOREsearch_USCOREresult *)ptr);
		break;
	case SOAP_TYPE_link_USCORElists:
		soap_serialize_link_USCORElists(soap, (const struct link_USCORElists *)ptr);
		break;
	case SOAP_TYPE_entry_USCORElist:
		soap_serialize_entry_USCORElist(soap, (const struct entry_USCORElist *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREentry_USCOREresult_USCOREversion2:
		soap_serialize_ns1__get_USCOREentry_USCOREresult_USCOREversion2(soap, (const struct ns1__get_USCOREentry_USCOREresult_USCOREversion2 *)ptr);
		break;
	case SOAP_TYPE_link_USCOREarray_USCORElist:
		soap_serialize_link_USCOREarray_USCORElist(soap, (const struct link_USCOREarray_USCORElist *)ptr);
		break;
	case SOAP_TYPE_ns1__link_USCOREname_USCOREvalue:
		soap_serialize_ns1__link_USCOREname_USCOREvalue(soap, (const struct ns1__link_USCOREname_USCOREvalue *)ptr);
		break;
	case SOAP_TYPE_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray:
		soap_serialize_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(soap, (const struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray *)ptr);
		break;
	case SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult:
		soap_serialize_ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult(soap, (const struct ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult *)ptr);
		break;
	case SOAP_TYPE_ns1__entry_USCOREvalue:
		soap_serialize_ns1__entry_USCOREvalue(soap, (const struct ns1__entry_USCOREvalue *)ptr);
		break;
	case SOAP_TYPE_select_USCOREfields:
		soap_serialize_select_USCOREfields(soap, (const struct select_USCOREfields *)ptr);
		break;
	case SOAP_TYPE_ns1__module_USCORElist:
		soap_serialize_ns1__module_USCORElist(soap, (const struct ns1__module_USCORElist *)ptr);
		break;
	case SOAP_TYPE_link_USCOREfield_USCORElist:
		soap_serialize_link_USCOREfield_USCORElist(soap, (const struct link_USCOREfield_USCORElist *)ptr);
		break;
	case SOAP_TYPE_ns1__new_USCOREmodule_USCOREfields:
		soap_serialize_ns1__new_USCOREmodule_USCOREfields(soap, (const struct ns1__new_USCOREmodule_USCOREfields *)ptr);
		break;
	case SOAP_TYPE_field_USCORElist:
		soap_serialize_field_USCORElist(soap, (const struct field_USCORElist *)ptr);
		break;
	case SOAP_TYPE_ns1__module_USCOREfields:
		soap_serialize_ns1__module_USCOREfields(soap, (const struct ns1__module_USCOREfields *)ptr);
		break;
	case SOAP_TYPE_ns1__name_USCOREvalue:
		soap_serialize_ns1__name_USCOREvalue(soap, (const struct ns1__name_USCOREvalue *)ptr);
		break;
	case SOAP_TYPE_ns1__link_USCOREfield:
		soap_serialize_ns1__link_USCOREfield(soap, (const struct ns1__link_USCOREfield *)ptr);
		break;
	case SOAP_TYPE_name_USCOREvalue_USCORElist:
		soap_serialize_name_USCOREvalue_USCORElist(soap, (const struct name_USCOREvalue_USCORElist *)ptr);
		break;
	case SOAP_TYPE_ns1__field:
		soap_serialize_ns1__field(soap, (const struct ns1__field *)ptr);
		break;
	case SOAP_TYPE_ns1__user_USCOREauth:
		soap_serialize_ns1__user_USCOREauth(soap, (const struct ns1__user_USCOREauth *)ptr);
		break;
	case SOAP_TYPE_ns1__error_USCOREvalue:
		soap_serialize_ns1__error_USCOREvalue(soap, (const struct ns1__error_USCOREvalue *)ptr);
		break;
	case SOAP_TYPE_ns1__return_USCOREnote_USCOREattachment:
		soap_serialize_ns1__return_USCOREnote_USCOREattachment(soap, (const struct ns1__return_USCOREnote_USCOREattachment *)ptr);
		break;
	case SOAP_TYPE_ns1__new_USCOREreturn_USCOREnote_USCOREattachment:
		soap_serialize_ns1__new_USCOREreturn_USCOREnote_USCOREattachment(soap, (const struct ns1__new_USCOREreturn_USCOREnote_USCOREattachment *)ptr);
		break;
	case SOAP_TYPE_ns1__new_USCOREnote_USCOREattachment:
		soap_serialize_ns1__new_USCOREnote_USCOREattachment(soap, (const struct ns1__new_USCOREnote_USCOREattachment *)ptr);
		break;
	case SOAP_TYPE_ns1__note_USCOREattachment:
		soap_serialize_ns1__note_USCOREattachment(soap, (const struct ns1__note_USCOREattachment *)ptr);
		break;
	case SOAP_TYPE_PointerTons1__searchResponse:
		soap_serialize_PointerTons1__searchResponse(soap, (struct ns1__searchResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__user_USCORElistResponse:
		soap_serialize_PointerTons1__user_USCORElistResponse(soap, (struct ns1__user_USCORElistResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTouser_USCOREdetail_USCOREarray:
		soap_serialize_PointerTouser_USCOREdetail_USCOREarray(soap, (struct user_USCOREdetail_USCOREarray *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__get_USCOREcontact_USCORErelationshipsResponse:
		soap_serialize_PointerTons1__get_USCOREcontact_USCORErelationshipsResponse(soap, (struct ns1__get_USCOREcontact_USCORErelationshipsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__contact_USCOREby_USCOREemailResponse:
		soap_serialize_PointerTons1__contact_USCOREby_USCOREemailResponse(soap, (struct ns1__contact_USCOREby_USCOREemailResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTocontact_USCOREdetail_USCOREarray:
		soap_serialize_PointerTocontact_USCOREdetail_USCOREarray(soap, (struct contact_USCOREdetail_USCOREarray *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__get_USCOREattendee_USCORElistResponse:
		soap_serialize_PointerTons1__get_USCOREattendee_USCORElistResponse(soap, (struct ns1__get_USCOREattendee_USCORElistResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__get_USCOREmodified_USCOREentriesResponse:
		soap_serialize_PointerTons1__get_USCOREmodified_USCOREentriesResponse(soap, (struct ns1__get_USCOREmodified_USCOREentriesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse:
		soap_serialize_PointerTons1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse(soap, (struct ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded:
		soap_serialize_PointerTons1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded(soap, (struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__set_USCOREentries_USCOREdetailsResponse:
		soap_serialize_PointerTons1__set_USCOREentries_USCOREdetailsResponse(soap, (struct ns1__set_USCOREentries_USCOREdetailsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__set_USCOREentries_USCOREdetail_USCOREresult:
		soap_serialize_PointerTons1__set_USCOREentries_USCOREdetail_USCOREresult(soap, (struct ns1__set_USCOREentries_USCOREdetail_USCOREresult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__get_USCOREentries_USCOREcountResponse:
		soap_serialize_PointerTons1__get_USCOREentries_USCOREcountResponse(soap, (struct ns1__get_USCOREentries_USCOREcountResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__get_USCOREentries_USCOREcount_USCOREresult:
		soap_serialize_PointerTons1__get_USCOREentries_USCOREcount_USCOREresult(soap, (struct ns1__get_USCOREentries_USCOREcount_USCOREresult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__set_USCOREcampaign_USCOREmergeResponse:
		soap_serialize_PointerTons1__set_USCOREcampaign_USCOREmergeResponse(soap, (struct ns1__set_USCOREcampaign_USCOREmergeResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__get_USCOREdocument_USCORErevisionResponse:
		soap_serialize_PointerTons1__get_USCOREdocument_USCORErevisionResponse(soap, (struct ns1__get_USCOREdocument_USCORErevisionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__return_USCOREdocument_USCORErevision:
		soap_serialize_PointerTons1__return_USCOREdocument_USCORErevision(soap, (struct ns1__return_USCOREdocument_USCORErevision *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__get_USCOREmailmerge_USCOREdocument2Response:
		soap_serialize_PointerTons1__get_USCOREmailmerge_USCOREdocument2Response(soap, (struct ns1__get_USCOREmailmerge_USCOREdocument2Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__get_USCOREmailmerge_USCOREdocument_USCOREresult:
		soap_serialize_PointerTons1__get_USCOREmailmerge_USCOREdocument_USCOREresult(soap, (struct ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__get_USCOREmailmerge_USCOREdocumentResponse:
		soap_serialize_PointerTons1__get_USCOREmailmerge_USCOREdocumentResponse(soap, (struct ns1__get_USCOREmailmerge_USCOREdocumentResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__get_USCOREsync_USCOREresult_USCOREencoded:
		soap_serialize_PointerTons1__get_USCOREsync_USCOREresult_USCOREencoded(soap, (struct ns1__get_USCOREsync_USCOREresult_USCOREencoded *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__search_USCOREby_USCOREmoduleResponse:
		soap_serialize_PointerTons1__search_USCOREby_USCOREmoduleResponse(soap, (struct ns1__search_USCOREby_USCOREmoduleResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__set_USCOREdocument_USCORErevisionResponse:
		soap_serialize_PointerTons1__set_USCOREdocument_USCORErevisionResponse(soap, (struct ns1__set_USCOREdocument_USCORErevisionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__set_USCORErelationshipsResponse:
		soap_serialize_PointerTons1__set_USCORErelationshipsResponse(soap, (struct ns1__set_USCORErelationshipsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToset_USCORErelationship_USCORElist:
		soap_serialize_PointerToset_USCORErelationship_USCORElist(soap, (struct set_USCORErelationship_USCORElist *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__set_USCORErelationship_USCORElist_USCOREresult:
		soap_serialize_PointerTons1__set_USCORErelationship_USCORElist_USCOREresult(soap, (struct ns1__set_USCORErelationship_USCORElist_USCOREresult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__set_USCORErelationshipResponse:
		soap_serialize_PointerTons1__set_USCORErelationshipResponse(soap, (struct ns1__set_USCORErelationshipResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__get_USCORErelationshipsResponse:
		soap_serialize_PointerTons1__get_USCORErelationshipsResponse(soap, (struct ns1__get_USCORErelationshipsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__get_USCORErelationships_USCOREresult:
		soap_serialize_PointerTons1__get_USCORErelationships_USCOREresult(soap, (struct ns1__get_USCORErelationships_USCOREresult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__update_USCOREportal_USCOREuserResponse:
		soap_serialize_PointerTons1__update_USCOREportal_USCOREuserResponse(soap, (struct ns1__update_USCOREportal_USCOREuserResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__get_USCOREavailable_USCOREmodulesResponse:
		soap_serialize_PointerTons1__get_USCOREavailable_USCOREmodulesResponse(soap, (struct ns1__get_USCOREavailable_USCOREmodulesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__module_USCORElist:
		soap_serialize_PointerTons1__module_USCORElist(soap, (struct ns1__module_USCORElist *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__get_USCOREmodule_USCOREfieldsResponse:
		soap_serialize_PointerTons1__get_USCOREmodule_USCOREfieldsResponse(soap, (struct ns1__get_USCOREmodule_USCOREfieldsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__module_USCOREfields:
		soap_serialize_PointerTons1__module_USCOREfields(soap, (struct ns1__module_USCOREfields *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__logoutResponse:
		soap_serialize_PointerTons1__logoutResponse(soap, (struct ns1__logoutResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__get_USCORErelated_USCOREnotesResponse:
		soap_serialize_PointerTons1__get_USCORErelated_USCOREnotesResponse(soap, (struct ns1__get_USCORErelated_USCOREnotesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__relate_USCOREnote_USCOREto_USCOREmoduleResponse:
		soap_serialize_PointerTons1__relate_USCOREnote_USCOREto_USCOREmoduleResponse(soap, (struct ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__get_USCOREnote_USCOREattachmentResponse:
		soap_serialize_PointerTons1__get_USCOREnote_USCOREattachmentResponse(soap, (struct ns1__get_USCOREnote_USCOREattachmentResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__return_USCOREnote_USCOREattachment:
		soap_serialize_PointerTons1__return_USCOREnote_USCOREattachment(soap, (struct ns1__return_USCOREnote_USCOREattachment *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__set_USCOREnote_USCOREattachmentResponse:
		soap_serialize_PointerTons1__set_USCOREnote_USCOREattachmentResponse(soap, (struct ns1__set_USCOREnote_USCOREattachmentResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__set_USCOREentriesResponse:
		soap_serialize_PointerTons1__set_USCOREentriesResponse(soap, (struct ns1__set_USCOREentriesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__set_USCOREentries_USCOREresult:
		soap_serialize_PointerTons1__set_USCOREentries_USCOREresult(soap, (struct ns1__set_USCOREentries_USCOREresult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__set_USCOREentryResponse:
		soap_serialize_PointerTons1__set_USCOREentryResponse(soap, (struct ns1__set_USCOREentryResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__get_USCOREentriesResponse:
		soap_serialize_PointerTons1__get_USCOREentriesResponse(soap, (struct ns1__get_USCOREentriesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__get_USCOREentryResponse:
		soap_serialize_PointerTons1__get_USCOREentryResponse(soap, (struct ns1__get_USCOREentryResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__get_USCOREentry_USCOREresult:
		soap_serialize_PointerTons1__get_USCOREentry_USCOREresult(soap, (struct ns1__get_USCOREentry_USCOREresult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__get_USCOREentry_USCORElistResponse:
		soap_serialize_PointerTons1__get_USCOREentry_USCORElistResponse(soap, (struct ns1__get_USCOREentry_USCORElistResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__get_USCOREentry_USCORElist_USCOREresult:
		soap_serialize_PointerTons1__get_USCOREentry_USCORElist_USCOREresult(soap, (struct ns1__get_USCOREentry_USCORElist_USCOREresult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__loginResponse:
		soap_serialize_PointerTons1__loginResponse(soap, (struct ns1__loginResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__user_USCOREauth:
		soap_serialize_PointerTons1__user_USCOREauth(soap, (struct ns1__user_USCOREauth *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__set_USCOREentry_USCOREresult:
		soap_serialize_PointerTons1__set_USCOREentry_USCOREresult(soap, (struct ns1__set_USCOREentry_USCOREresult *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__user_USCOREdetail:
		soap_serialize_PointerToPointerTons1__user_USCOREdetail(soap, (struct ns1__user_USCOREdetail **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__user_USCOREdetail:
		soap_serialize_PointerTons1__user_USCOREdetail(soap, (struct ns1__user_USCOREdetail *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__contact_USCOREdetail:
		soap_serialize_PointerToPointerTons1__contact_USCOREdetail(soap, (struct ns1__contact_USCOREdetail **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__contact_USCOREdetail:
		soap_serialize_PointerTons1__contact_USCOREdetail(soap, (struct ns1__contact_USCOREdetail *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__newsletter:
		soap_serialize_PointerToPointerTons1__newsletter(soap, (struct ns1__newsletter **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__newsletter:
		soap_serialize_PointerTons1__newsletter(soap, (struct ns1__newsletter *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__name_USCOREvalue_USCOREoperator:
		soap_serialize_PointerToPointerTons1__name_USCOREvalue_USCOREoperator(soap, (struct ns1__name_USCOREvalue_USCOREoperator **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__name_USCOREvalue_USCOREoperator:
		soap_serialize_PointerTons1__name_USCOREvalue_USCOREoperator(soap, (struct ns1__name_USCOREvalue_USCOREoperator *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerToselect_USCOREfields:
		soap_serialize_PointerToPointerToselect_USCOREfields(soap, (struct select_USCOREfields **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__set_USCORErelationship_USCOREvalue:
		soap_serialize_PointerToPointerTons1__set_USCORErelationship_USCOREvalue(soap, (struct ns1__set_USCORErelationship_USCOREvalue **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__set_USCORErelationship_USCOREvalue:
		soap_serialize_PointerTons1__set_USCORErelationship_USCOREvalue(soap, (struct ns1__set_USCORErelationship_USCOREvalue *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__id_USCOREmod:
		soap_serialize_PointerToPointerTons1__id_USCOREmod(soap, (struct ns1__id_USCOREmod **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__id_USCOREmod:
		soap_serialize_PointerTons1__id_USCOREmod(soap, (struct ns1__id_USCOREmod *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTolink_USCORElist:
		soap_serialize_PointerToPointerTolink_USCORElist(soap, (struct link_USCORElist **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__link_USCOREname_USCOREvalue:
		soap_serialize_PointerToPointerTons1__link_USCOREname_USCOREvalue(soap, (struct ns1__link_USCOREname_USCOREvalue **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__link_USCOREname_USCOREvalue:
		soap_serialize_PointerTons1__link_USCOREname_USCOREvalue(soap, (struct ns1__link_USCOREname_USCOREvalue *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTolink_USCOREvalue:
		soap_serialize_PointerToPointerTolink_USCOREvalue(soap, (struct link_USCOREvalue **const*)ptr);
		break;
	case SOAP_TYPE_PointerTolink_USCOREvalue:
		soap_serialize_PointerTolink_USCOREvalue(soap, (struct link_USCOREvalue *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__entry_USCOREvalue:
		soap_serialize_PointerToPointerTons1__entry_USCOREvalue(soap, (struct ns1__entry_USCOREvalue **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__entry_USCOREvalue:
		soap_serialize_PointerTons1__entry_USCOREvalue(soap, (struct ns1__entry_USCOREvalue *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostring:
		soap_serialize_PointerTostring(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerToname_USCOREvalue_USCORElist:
		soap_serialize_PointerToPointerToname_USCOREvalue_USCORElist(soap, (struct name_USCOREvalue_USCORElist **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__name_USCOREvalue:
		soap_serialize_PointerToPointerTons1__name_USCOREvalue(soap, (struct ns1__name_USCOREvalue **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__name_USCOREvalue:
		soap_serialize_PointerTons1__name_USCOREvalue(soap, (struct ns1__name_USCOREvalue *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__link_USCOREfield:
		soap_serialize_PointerToPointerTons1__link_USCOREfield(soap, (struct ns1__link_USCOREfield **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__link_USCOREfield:
		soap_serialize_PointerTons1__link_USCOREfield(soap, (struct ns1__link_USCOREfield *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__field:
		soap_serialize_PointerToPointerTons1__field(soap, (struct ns1__field **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__field:
		soap_serialize_PointerTons1__field(soap, (struct ns1__field *const*)ptr);
		break;
	case SOAP_TYPE_PointerToname_USCOREvalue_USCORElists:
		soap_serialize_PointerToname_USCOREvalue_USCORElists(soap, (struct name_USCOREvalue_USCORElists *const*)ptr);
		break;
	case SOAP_TYPE_PointerTonewsletter_USCORElist:
		soap_serialize_PointerTonewsletter_USCORElist(soap, (struct newsletter_USCORElist *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__document_USCORErevision:
		soap_serialize_PointerTons1__document_USCORErevision(soap, (struct ns1__document_USCORErevision *const*)ptr);
		break;
	case SOAP_TYPE_PointerToids_USCOREmods:
		soap_serialize_PointerToids_USCOREmods(soap, (struct ids_USCOREmods *const*)ptr);
		break;
	case SOAP_TYPE_PointerTolink_USCORElist:
		soap_serialize_PointerTolink_USCORElist(soap, (struct link_USCORElist *const*)ptr);
		break;
	case SOAP_TYPE_PointerTolink_USCORElists:
		soap_serialize_PointerTolink_USCORElists(soap, (struct link_USCORElists *const*)ptr);
		break;
	case SOAP_TYPE_PointerToentry_USCORElist:
		soap_serialize_PointerToentry_USCORElist(soap, (struct entry_USCORElist *const*)ptr);
		break;
	case SOAP_TYPE_PointerTolink_USCOREarray_USCORElist:
		soap_serialize_PointerTolink_USCOREarray_USCORElist(soap, (struct link_USCOREarray_USCORElist *const*)ptr);
		break;
	case SOAP_TYPE_PointerToselect_USCOREfields:
		soap_serialize_PointerToselect_USCOREfields(soap, (struct select_USCOREfields *const*)ptr);
		break;
	case SOAP_TYPE_PointerTolink_USCOREfield_USCORElist:
		soap_serialize_PointerTolink_USCOREfield_USCORElist(soap, (struct link_USCOREfield_USCORElist *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofield_USCORElist:
		soap_serialize_PointerTofield_USCORElist(soap, (struct field_USCORElist *const*)ptr);
		break;
	case SOAP_TYPE_PointerToname_USCOREvalue_USCORElist:
		soap_serialize_PointerToname_USCOREvalue_USCORElist(soap, (struct name_USCOREvalue_USCORElist *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__error_USCOREvalue:
		soap_serialize_PointerTons1__error_USCOREvalue(soap, (struct ns1__error_USCOREvalue *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__note_USCOREattachment:
		soap_serialize_PointerTons1__note_USCOREattachment(soap, (struct ns1__note_USCOREattachment *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__new_USCOREnote_USCOREattachment:
		soap_serialize_PointerTons1__new_USCOREnote_USCOREattachment(soap, (struct ns1__new_USCOREnote_USCOREattachment *const*)ptr);
		break;
	case SOAP_TYPE_xsd__date:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	short soap_flag_faultcode = 1, soap_flag_faultstring = 1, soap_flag_faultactor = 1, soap_flag_detail = 1, soap_flag_SOAP_ENV__Code = 1, soap_flag_SOAP_ENV__Reason = 1, soap_flag_SOAP_ENV__Node = 1, soap_flag_SOAP_ENV__Role = 1, soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	short soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	short soap_flag_fault = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	short soap_flag_SOAP_ENV__Value = 1, soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__create_USCOREcase(struct soap *soap, struct ns1__create_USCOREcase *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->user_USCOREname);
	soap_default_string(soap, &a->password);
	soap_default_string(soap, &a->name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__create_USCOREcase(struct soap *soap, const struct ns1__create_USCOREcase *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->user_USCOREname);
	soap_serialize_string(soap, &a->password);
	soap_serialize_string(soap, &a->name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__create_USCOREcase(struct soap *soap, const struct ns1__create_USCOREcase *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__create_USCOREcase);
	if (soap_out_ns1__create_USCOREcase(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__create_USCOREcase(struct soap *soap, const char *tag, int id, const struct ns1__create_USCOREcase *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__create_USCOREcase), type))
		return soap->error;
	if (soap_out_string(soap, "user_name", -1, &a->user_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__create_USCOREcase * SOAP_FMAC4 soap_get_ns1__create_USCOREcase(struct soap *soap, struct ns1__create_USCOREcase *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__create_USCOREcase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__create_USCOREcase * SOAP_FMAC4 soap_in_ns1__create_USCOREcase(struct soap *soap, const char *tag, struct ns1__create_USCOREcase *a, const char *type)
{
	short soap_flag_user_USCOREname = 1, soap_flag_password = 1, soap_flag_name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__create_USCOREcase *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__create_USCOREcase, sizeof(struct ns1__create_USCOREcase), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__create_USCOREcase(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_user_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "user_name", &a->user_USCOREname, "xsd:string"))
				{	soap_flag_user_USCOREname--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__create_USCOREcase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__create_USCOREcase, 0, sizeof(struct ns1__create_USCOREcase), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__create_USCOREcaseResponse(struct soap *soap, struct ns1__create_USCOREcaseResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__create_USCOREcaseResponse(struct soap *soap, const struct ns1__create_USCOREcaseResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__create_USCOREcaseResponse(struct soap *soap, const struct ns1__create_USCOREcaseResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__create_USCOREcaseResponse);
	if (soap_out_ns1__create_USCOREcaseResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__create_USCOREcaseResponse(struct soap *soap, const char *tag, int id, const struct ns1__create_USCOREcaseResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__create_USCOREcaseResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__create_USCOREcaseResponse * SOAP_FMAC4 soap_get_ns1__create_USCOREcaseResponse(struct soap *soap, struct ns1__create_USCOREcaseResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__create_USCOREcaseResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__create_USCOREcaseResponse * SOAP_FMAC4 soap_in_ns1__create_USCOREcaseResponse(struct soap *soap, const char *tag, struct ns1__create_USCOREcaseResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__create_USCOREcaseResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__create_USCOREcaseResponse, sizeof(struct ns1__create_USCOREcaseResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__create_USCOREcaseResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__create_USCOREcaseResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__create_USCOREcaseResponse, 0, sizeof(struct ns1__create_USCOREcaseResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__create_USCOREopportunity(struct soap *soap, struct ns1__create_USCOREopportunity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->user_USCOREname);
	soap_default_string(soap, &a->password);
	soap_default_string(soap, &a->name);
	soap_default_string(soap, &a->amount);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__create_USCOREopportunity(struct soap *soap, const struct ns1__create_USCOREopportunity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->user_USCOREname);
	soap_serialize_string(soap, &a->password);
	soap_serialize_string(soap, &a->name);
	soap_serialize_string(soap, &a->amount);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__create_USCOREopportunity(struct soap *soap, const struct ns1__create_USCOREopportunity *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__create_USCOREopportunity);
	if (soap_out_ns1__create_USCOREopportunity(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__create_USCOREopportunity(struct soap *soap, const char *tag, int id, const struct ns1__create_USCOREopportunity *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__create_USCOREopportunity), type))
		return soap->error;
	if (soap_out_string(soap, "user_name", -1, &a->user_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->name, ""))
		return soap->error;
	if (soap_out_string(soap, "amount", -1, &a->amount, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__create_USCOREopportunity * SOAP_FMAC4 soap_get_ns1__create_USCOREopportunity(struct soap *soap, struct ns1__create_USCOREopportunity *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__create_USCOREopportunity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__create_USCOREopportunity * SOAP_FMAC4 soap_in_ns1__create_USCOREopportunity(struct soap *soap, const char *tag, struct ns1__create_USCOREopportunity *a, const char *type)
{
	short soap_flag_user_USCOREname = 1, soap_flag_password = 1, soap_flag_name = 1, soap_flag_amount = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__create_USCOREopportunity *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__create_USCOREopportunity, sizeof(struct ns1__create_USCOREopportunity), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__create_USCOREopportunity(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_user_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "user_name", &a->user_USCOREname, "xsd:string"))
				{	soap_flag_user_USCOREname--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_amount && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "amount", &a->amount, "xsd:string"))
				{	soap_flag_amount--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__create_USCOREopportunity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__create_USCOREopportunity, 0, sizeof(struct ns1__create_USCOREopportunity), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__create_USCOREopportunityResponse(struct soap *soap, struct ns1__create_USCOREopportunityResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__create_USCOREopportunityResponse(struct soap *soap, const struct ns1__create_USCOREopportunityResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__create_USCOREopportunityResponse(struct soap *soap, const struct ns1__create_USCOREopportunityResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__create_USCOREopportunityResponse);
	if (soap_out_ns1__create_USCOREopportunityResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__create_USCOREopportunityResponse(struct soap *soap, const char *tag, int id, const struct ns1__create_USCOREopportunityResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__create_USCOREopportunityResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__create_USCOREopportunityResponse * SOAP_FMAC4 soap_get_ns1__create_USCOREopportunityResponse(struct soap *soap, struct ns1__create_USCOREopportunityResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__create_USCOREopportunityResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__create_USCOREopportunityResponse * SOAP_FMAC4 soap_in_ns1__create_USCOREopportunityResponse(struct soap *soap, const char *tag, struct ns1__create_USCOREopportunityResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__create_USCOREopportunityResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__create_USCOREopportunityResponse, sizeof(struct ns1__create_USCOREopportunityResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__create_USCOREopportunityResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__create_USCOREopportunityResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__create_USCOREopportunityResponse, 0, sizeof(struct ns1__create_USCOREopportunityResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__create_USCOREaccount(struct soap *soap, struct ns1__create_USCOREaccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->user_USCOREname);
	soap_default_string(soap, &a->password);
	soap_default_string(soap, &a->name);
	soap_default_string(soap, &a->phone);
	soap_default_string(soap, &a->website);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__create_USCOREaccount(struct soap *soap, const struct ns1__create_USCOREaccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->user_USCOREname);
	soap_serialize_string(soap, &a->password);
	soap_serialize_string(soap, &a->name);
	soap_serialize_string(soap, &a->phone);
	soap_serialize_string(soap, &a->website);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__create_USCOREaccount(struct soap *soap, const struct ns1__create_USCOREaccount *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__create_USCOREaccount);
	if (soap_out_ns1__create_USCOREaccount(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__create_USCOREaccount(struct soap *soap, const char *tag, int id, const struct ns1__create_USCOREaccount *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__create_USCOREaccount), type))
		return soap->error;
	if (soap_out_string(soap, "user_name", -1, &a->user_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->name, ""))
		return soap->error;
	if (soap_out_string(soap, "phone", -1, &a->phone, ""))
		return soap->error;
	if (soap_out_string(soap, "website", -1, &a->website, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__create_USCOREaccount * SOAP_FMAC4 soap_get_ns1__create_USCOREaccount(struct soap *soap, struct ns1__create_USCOREaccount *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__create_USCOREaccount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__create_USCOREaccount * SOAP_FMAC4 soap_in_ns1__create_USCOREaccount(struct soap *soap, const char *tag, struct ns1__create_USCOREaccount *a, const char *type)
{
	short soap_flag_user_USCOREname = 1, soap_flag_password = 1, soap_flag_name = 1, soap_flag_phone = 1, soap_flag_website = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__create_USCOREaccount *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__create_USCOREaccount, sizeof(struct ns1__create_USCOREaccount), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__create_USCOREaccount(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_user_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "user_name", &a->user_USCOREname, "xsd:string"))
				{	soap_flag_user_USCOREname--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_phone && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "phone", &a->phone, "xsd:string"))
				{	soap_flag_phone--;
					continue;
				}
			if (soap_flag_website && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "website", &a->website, "xsd:string"))
				{	soap_flag_website--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__create_USCOREaccount *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__create_USCOREaccount, 0, sizeof(struct ns1__create_USCOREaccount), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__create_USCOREaccountResponse(struct soap *soap, struct ns1__create_USCOREaccountResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__create_USCOREaccountResponse(struct soap *soap, const struct ns1__create_USCOREaccountResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__create_USCOREaccountResponse(struct soap *soap, const struct ns1__create_USCOREaccountResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__create_USCOREaccountResponse);
	if (soap_out_ns1__create_USCOREaccountResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__create_USCOREaccountResponse(struct soap *soap, const char *tag, int id, const struct ns1__create_USCOREaccountResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__create_USCOREaccountResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__create_USCOREaccountResponse * SOAP_FMAC4 soap_get_ns1__create_USCOREaccountResponse(struct soap *soap, struct ns1__create_USCOREaccountResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__create_USCOREaccountResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__create_USCOREaccountResponse * SOAP_FMAC4 soap_in_ns1__create_USCOREaccountResponse(struct soap *soap, const char *tag, struct ns1__create_USCOREaccountResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__create_USCOREaccountResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__create_USCOREaccountResponse, sizeof(struct ns1__create_USCOREaccountResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__create_USCOREaccountResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__create_USCOREaccountResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__create_USCOREaccountResponse, 0, sizeof(struct ns1__create_USCOREaccountResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__create_USCORElead(struct soap *soap, struct ns1__create_USCORElead *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->user_USCOREname);
	soap_default_string(soap, &a->password);
	soap_default_string(soap, &a->first_USCOREname);
	soap_default_string(soap, &a->last_USCOREname);
	soap_default_string(soap, &a->email_USCOREaddress);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__create_USCORElead(struct soap *soap, const struct ns1__create_USCORElead *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->user_USCOREname);
	soap_serialize_string(soap, &a->password);
	soap_serialize_string(soap, &a->first_USCOREname);
	soap_serialize_string(soap, &a->last_USCOREname);
	soap_serialize_string(soap, &a->email_USCOREaddress);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__create_USCORElead(struct soap *soap, const struct ns1__create_USCORElead *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__create_USCORElead);
	if (soap_out_ns1__create_USCORElead(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__create_USCORElead(struct soap *soap, const char *tag, int id, const struct ns1__create_USCORElead *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__create_USCORElead), type))
		return soap->error;
	if (soap_out_string(soap, "user_name", -1, &a->user_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_string(soap, "first_name", -1, &a->first_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "last_name", -1, &a->last_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "email_address", -1, &a->email_USCOREaddress, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__create_USCORElead * SOAP_FMAC4 soap_get_ns1__create_USCORElead(struct soap *soap, struct ns1__create_USCORElead *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__create_USCORElead(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__create_USCORElead * SOAP_FMAC4 soap_in_ns1__create_USCORElead(struct soap *soap, const char *tag, struct ns1__create_USCORElead *a, const char *type)
{
	short soap_flag_user_USCOREname = 1, soap_flag_password = 1, soap_flag_first_USCOREname = 1, soap_flag_last_USCOREname = 1, soap_flag_email_USCOREaddress = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__create_USCORElead *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__create_USCORElead, sizeof(struct ns1__create_USCORElead), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__create_USCORElead(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_user_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "user_name", &a->user_USCOREname, "xsd:string"))
				{	soap_flag_user_USCOREname--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_first_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "first_name", &a->first_USCOREname, "xsd:string"))
				{	soap_flag_first_USCOREname--;
					continue;
				}
			if (soap_flag_last_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "last_name", &a->last_USCOREname, "xsd:string"))
				{	soap_flag_last_USCOREname--;
					continue;
				}
			if (soap_flag_email_USCOREaddress && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "email_address", &a->email_USCOREaddress, "xsd:string"))
				{	soap_flag_email_USCOREaddress--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__create_USCORElead *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__create_USCORElead, 0, sizeof(struct ns1__create_USCORElead), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__create_USCOREleadResponse(struct soap *soap, struct ns1__create_USCOREleadResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__create_USCOREleadResponse(struct soap *soap, const struct ns1__create_USCOREleadResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__create_USCOREleadResponse(struct soap *soap, const struct ns1__create_USCOREleadResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__create_USCOREleadResponse);
	if (soap_out_ns1__create_USCOREleadResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__create_USCOREleadResponse(struct soap *soap, const char *tag, int id, const struct ns1__create_USCOREleadResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__create_USCOREleadResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__create_USCOREleadResponse * SOAP_FMAC4 soap_get_ns1__create_USCOREleadResponse(struct soap *soap, struct ns1__create_USCOREleadResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__create_USCOREleadResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__create_USCOREleadResponse * SOAP_FMAC4 soap_in_ns1__create_USCOREleadResponse(struct soap *soap, const char *tag, struct ns1__create_USCOREleadResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__create_USCOREleadResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__create_USCOREleadResponse, sizeof(struct ns1__create_USCOREleadResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__create_USCOREleadResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__create_USCOREleadResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__create_USCOREleadResponse, 0, sizeof(struct ns1__create_USCOREleadResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__create_USCOREcontact(struct soap *soap, struct ns1__create_USCOREcontact *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->user_USCOREname);
	soap_default_string(soap, &a->password);
	soap_default_string(soap, &a->first_USCOREname);
	soap_default_string(soap, &a->last_USCOREname);
	soap_default_string(soap, &a->email_USCOREaddress);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__create_USCOREcontact(struct soap *soap, const struct ns1__create_USCOREcontact *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->user_USCOREname);
	soap_serialize_string(soap, &a->password);
	soap_serialize_string(soap, &a->first_USCOREname);
	soap_serialize_string(soap, &a->last_USCOREname);
	soap_serialize_string(soap, &a->email_USCOREaddress);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__create_USCOREcontact(struct soap *soap, const struct ns1__create_USCOREcontact *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__create_USCOREcontact);
	if (soap_out_ns1__create_USCOREcontact(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__create_USCOREcontact(struct soap *soap, const char *tag, int id, const struct ns1__create_USCOREcontact *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__create_USCOREcontact), type))
		return soap->error;
	if (soap_out_string(soap, "user_name", -1, &a->user_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_string(soap, "first_name", -1, &a->first_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "last_name", -1, &a->last_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "email_address", -1, &a->email_USCOREaddress, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__create_USCOREcontact * SOAP_FMAC4 soap_get_ns1__create_USCOREcontact(struct soap *soap, struct ns1__create_USCOREcontact *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__create_USCOREcontact(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__create_USCOREcontact * SOAP_FMAC4 soap_in_ns1__create_USCOREcontact(struct soap *soap, const char *tag, struct ns1__create_USCOREcontact *a, const char *type)
{
	short soap_flag_user_USCOREname = 1, soap_flag_password = 1, soap_flag_first_USCOREname = 1, soap_flag_last_USCOREname = 1, soap_flag_email_USCOREaddress = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__create_USCOREcontact *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__create_USCOREcontact, sizeof(struct ns1__create_USCOREcontact), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__create_USCOREcontact(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_user_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "user_name", &a->user_USCOREname, "xsd:string"))
				{	soap_flag_user_USCOREname--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_first_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "first_name", &a->first_USCOREname, "xsd:string"))
				{	soap_flag_first_USCOREname--;
					continue;
				}
			if (soap_flag_last_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "last_name", &a->last_USCOREname, "xsd:string"))
				{	soap_flag_last_USCOREname--;
					continue;
				}
			if (soap_flag_email_USCOREaddress && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "email_address", &a->email_USCOREaddress, "xsd:string"))
				{	soap_flag_email_USCOREaddress--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__create_USCOREcontact *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__create_USCOREcontact, 0, sizeof(struct ns1__create_USCOREcontact), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__create_USCOREcontactResponse(struct soap *soap, struct ns1__create_USCOREcontactResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__create_USCOREcontactResponse(struct soap *soap, const struct ns1__create_USCOREcontactResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__create_USCOREcontactResponse(struct soap *soap, const struct ns1__create_USCOREcontactResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__create_USCOREcontactResponse);
	if (soap_out_ns1__create_USCOREcontactResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__create_USCOREcontactResponse(struct soap *soap, const char *tag, int id, const struct ns1__create_USCOREcontactResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__create_USCOREcontactResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__create_USCOREcontactResponse * SOAP_FMAC4 soap_get_ns1__create_USCOREcontactResponse(struct soap *soap, struct ns1__create_USCOREcontactResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__create_USCOREcontactResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__create_USCOREcontactResponse * SOAP_FMAC4 soap_in_ns1__create_USCOREcontactResponse(struct soap *soap, const char *tag, struct ns1__create_USCOREcontactResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__create_USCOREcontactResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__create_USCOREcontactResponse, sizeof(struct ns1__create_USCOREcontactResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__create_USCOREcontactResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__create_USCOREcontactResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__create_USCOREcontactResponse, 0, sizeof(struct ns1__create_USCOREcontactResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__track_USCOREemail(struct soap *soap, struct ns1__track_USCOREemail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->user_USCOREname);
	soap_default_string(soap, &a->password);
	soap_default_string(soap, &a->parent_USCOREid);
	soap_default_string(soap, &a->contact_USCOREids);
	soap_default_xsd__date(soap, &a->date_USCOREsent);
	soap_default_string(soap, &a->email_USCOREsubject);
	soap_default_string(soap, &a->email_USCOREbody);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__track_USCOREemail(struct soap *soap, const struct ns1__track_USCOREemail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->user_USCOREname);
	soap_serialize_string(soap, &a->password);
	soap_serialize_string(soap, &a->parent_USCOREid);
	soap_serialize_string(soap, &a->contact_USCOREids);
	soap_serialize_xsd__date(soap, &a->date_USCOREsent);
	soap_serialize_string(soap, &a->email_USCOREsubject);
	soap_serialize_string(soap, &a->email_USCOREbody);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__track_USCOREemail(struct soap *soap, const struct ns1__track_USCOREemail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__track_USCOREemail);
	if (soap_out_ns1__track_USCOREemail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__track_USCOREemail(struct soap *soap, const char *tag, int id, const struct ns1__track_USCOREemail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__track_USCOREemail), type))
		return soap->error;
	if (soap_out_string(soap, "user_name", -1, &a->user_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_string(soap, "parent_id", -1, &a->parent_USCOREid, ""))
		return soap->error;
	if (soap_out_string(soap, "contact_ids", -1, &a->contact_USCOREids, ""))
		return soap->error;
	if (soap_out_xsd__date(soap, "date_sent", -1, &a->date_USCOREsent, ""))
		return soap->error;
	if (soap_out_string(soap, "email_subject", -1, &a->email_USCOREsubject, ""))
		return soap->error;
	if (soap_out_string(soap, "email_body", -1, &a->email_USCOREbody, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__track_USCOREemail * SOAP_FMAC4 soap_get_ns1__track_USCOREemail(struct soap *soap, struct ns1__track_USCOREemail *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__track_USCOREemail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__track_USCOREemail * SOAP_FMAC4 soap_in_ns1__track_USCOREemail(struct soap *soap, const char *tag, struct ns1__track_USCOREemail *a, const char *type)
{
	short soap_flag_user_USCOREname = 1, soap_flag_password = 1, soap_flag_parent_USCOREid = 1, soap_flag_contact_USCOREids = 1, soap_flag_date_USCOREsent = 1, soap_flag_email_USCOREsubject = 1, soap_flag_email_USCOREbody = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__track_USCOREemail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__track_USCOREemail, sizeof(struct ns1__track_USCOREemail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__track_USCOREemail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_user_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "user_name", &a->user_USCOREname, "xsd:string"))
				{	soap_flag_user_USCOREname--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_parent_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "parent_id", &a->parent_USCOREid, "xsd:string"))
				{	soap_flag_parent_USCOREid--;
					continue;
				}
			if (soap_flag_contact_USCOREids && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "contact_ids", &a->contact_USCOREids, "xsd:string"))
				{	soap_flag_contact_USCOREids--;
					continue;
				}
			if (soap_flag_date_USCOREsent && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__date(soap, "date_sent", &a->date_USCOREsent, "xsd:date"))
				{	soap_flag_date_USCOREsent--;
					continue;
				}
			if (soap_flag_email_USCOREsubject && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "email_subject", &a->email_USCOREsubject, "xsd:string"))
				{	soap_flag_email_USCOREsubject--;
					continue;
				}
			if (soap_flag_email_USCOREbody && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "email_body", &a->email_USCOREbody, "xsd:string"))
				{	soap_flag_email_USCOREbody--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__track_USCOREemail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__track_USCOREemail, 0, sizeof(struct ns1__track_USCOREemail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__track_USCOREemailResponse(struct soap *soap, struct ns1__track_USCOREemailResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__track_USCOREemailResponse(struct soap *soap, const struct ns1__track_USCOREemailResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__track_USCOREemailResponse(struct soap *soap, const struct ns1__track_USCOREemailResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__track_USCOREemailResponse);
	if (soap_out_ns1__track_USCOREemailResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__track_USCOREemailResponse(struct soap *soap, const char *tag, int id, const struct ns1__track_USCOREemailResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__track_USCOREemailResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__track_USCOREemailResponse * SOAP_FMAC4 soap_get_ns1__track_USCOREemailResponse(struct soap *soap, struct ns1__track_USCOREemailResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__track_USCOREemailResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__track_USCOREemailResponse * SOAP_FMAC4 soap_in_ns1__track_USCOREemailResponse(struct soap *soap, const char *tag, struct ns1__track_USCOREemailResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__track_USCOREemailResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__track_USCOREemailResponse, sizeof(struct ns1__track_USCOREemailResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__track_USCOREemailResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__track_USCOREemailResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__track_USCOREemailResponse, 0, sizeof(struct ns1__track_USCOREemailResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__search(struct soap *soap, struct ns1__search *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->user_USCOREname);
	soap_default_string(soap, &a->password);
	soap_default_string(soap, &a->name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__search(struct soap *soap, const struct ns1__search *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->user_USCOREname);
	soap_serialize_string(soap, &a->password);
	soap_serialize_string(soap, &a->name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__search(struct soap *soap, const struct ns1__search *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__search);
	if (soap_out_ns1__search(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__search(struct soap *soap, const char *tag, int id, const struct ns1__search *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__search), type))
		return soap->error;
	if (soap_out_string(soap, "user_name", -1, &a->user_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__search * SOAP_FMAC4 soap_get_ns1__search(struct soap *soap, struct ns1__search *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__search(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__search * SOAP_FMAC4 soap_in_ns1__search(struct soap *soap, const char *tag, struct ns1__search *a, const char *type)
{
	short soap_flag_user_USCOREname = 1, soap_flag_password = 1, soap_flag_name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__search *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__search, sizeof(struct ns1__search), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__search(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_user_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "user_name", &a->user_USCOREname, "xsd:string"))
				{	soap_flag_user_USCOREname--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__search *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__search, 0, sizeof(struct ns1__search), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__searchResponse(struct soap *soap, struct ns1__searchResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__searchResponse(struct soap *soap, const struct ns1__searchResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTocontact_USCOREdetail_USCOREarray(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__searchResponse(struct soap *soap, const struct ns1__searchResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__searchResponse);
	if (soap_out_ns1__searchResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__searchResponse(struct soap *soap, const char *tag, int id, const struct ns1__searchResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__searchResponse), type))
		return soap->error;
	if (soap_out_PointerTocontact_USCOREdetail_USCOREarray(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__searchResponse * SOAP_FMAC4 soap_get_ns1__searchResponse(struct soap *soap, struct ns1__searchResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__searchResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__searchResponse * SOAP_FMAC4 soap_in_ns1__searchResponse(struct soap *soap, const char *tag, struct ns1__searchResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__searchResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__searchResponse, sizeof(struct ns1__searchResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__searchResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTocontact_USCOREdetail_USCOREarray(soap, "return", &a->return_, "ns1:contact_detail"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__searchResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__searchResponse, 0, sizeof(struct ns1__searchResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__user_USCORElist(struct soap *soap, struct ns1__user_USCORElist *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->user_USCOREname);
	soap_default_string(soap, &a->password);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__user_USCORElist(struct soap *soap, const struct ns1__user_USCORElist *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->user_USCOREname);
	soap_serialize_string(soap, &a->password);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__user_USCORElist(struct soap *soap, const struct ns1__user_USCORElist *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__user_USCORElist);
	if (soap_out_ns1__user_USCORElist(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__user_USCORElist(struct soap *soap, const char *tag, int id, const struct ns1__user_USCORElist *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__user_USCORElist), type))
		return soap->error;
	if (soap_out_string(soap, "user_name", -1, &a->user_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__user_USCORElist * SOAP_FMAC4 soap_get_ns1__user_USCORElist(struct soap *soap, struct ns1__user_USCORElist *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__user_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__user_USCORElist * SOAP_FMAC4 soap_in_ns1__user_USCORElist(struct soap *soap, const char *tag, struct ns1__user_USCORElist *a, const char *type)
{
	short soap_flag_user_USCOREname = 1, soap_flag_password = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__user_USCORElist *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__user_USCORElist, sizeof(struct ns1__user_USCORElist), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__user_USCORElist(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_user_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "user_name", &a->user_USCOREname, "xsd:string"))
				{	soap_flag_user_USCOREname--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__user_USCORElist *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__user_USCORElist, 0, sizeof(struct ns1__user_USCORElist), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__user_USCORElistResponse(struct soap *soap, struct ns1__user_USCORElistResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__user_USCORElistResponse(struct soap *soap, const struct ns1__user_USCORElistResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTouser_USCOREdetail_USCOREarray(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__user_USCORElistResponse(struct soap *soap, const struct ns1__user_USCORElistResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__user_USCORElistResponse);
	if (soap_out_ns1__user_USCORElistResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__user_USCORElistResponse(struct soap *soap, const char *tag, int id, const struct ns1__user_USCORElistResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__user_USCORElistResponse), type))
		return soap->error;
	if (soap_out_PointerTouser_USCOREdetail_USCOREarray(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__user_USCORElistResponse * SOAP_FMAC4 soap_get_ns1__user_USCORElistResponse(struct soap *soap, struct ns1__user_USCORElistResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__user_USCORElistResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__user_USCORElistResponse * SOAP_FMAC4 soap_in_ns1__user_USCORElistResponse(struct soap *soap, const char *tag, struct ns1__user_USCORElistResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__user_USCORElistResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__user_USCORElistResponse, sizeof(struct ns1__user_USCORElistResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__user_USCORElistResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTouser_USCOREdetail_USCOREarray(soap, "return", &a->return_, "ns1:user_detail"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__user_USCORElistResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__user_USCORElistResponse, 0, sizeof(struct ns1__user_USCORElistResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREcontact_USCORErelationships(struct soap *soap, struct ns1__get_USCOREcontact_USCORErelationships *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->user_USCOREname);
	soap_default_string(soap, &a->password);
	soap_default_string(soap, &a->id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREcontact_USCORErelationships(struct soap *soap, const struct ns1__get_USCOREcontact_USCORErelationships *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->user_USCOREname);
	soap_serialize_string(soap, &a->password);
	soap_serialize_string(soap, &a->id);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREcontact_USCORErelationships(struct soap *soap, const struct ns1__get_USCOREcontact_USCORErelationships *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREcontact_USCORErelationships);
	if (soap_out_ns1__get_USCOREcontact_USCORErelationships(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREcontact_USCORErelationships(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREcontact_USCORErelationships *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREcontact_USCORErelationships), type))
		return soap->error;
	if (soap_out_string(soap, "user_name", -1, &a->user_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_string(soap, "id", -1, &a->id, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREcontact_USCORErelationships * SOAP_FMAC4 soap_get_ns1__get_USCOREcontact_USCORErelationships(struct soap *soap, struct ns1__get_USCOREcontact_USCORErelationships *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREcontact_USCORErelationships(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREcontact_USCORErelationships * SOAP_FMAC4 soap_in_ns1__get_USCOREcontact_USCORErelationships(struct soap *soap, const char *tag, struct ns1__get_USCOREcontact_USCORErelationships *a, const char *type)
{
	short soap_flag_user_USCOREname = 1, soap_flag_password = 1, soap_flag_id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREcontact_USCORErelationships *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREcontact_USCORErelationships, sizeof(struct ns1__get_USCOREcontact_USCORErelationships), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREcontact_USCORErelationships(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_user_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "user_name", &a->user_USCOREname, "xsd:string"))
				{	soap_flag_user_USCOREname--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREcontact_USCORErelationships *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREcontact_USCORErelationships, 0, sizeof(struct ns1__get_USCOREcontact_USCORErelationships), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREcontact_USCORErelationshipsResponse(struct soap *soap, struct ns1__get_USCOREcontact_USCORErelationshipsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREcontact_USCORErelationshipsResponse(struct soap *soap, const struct ns1__get_USCOREcontact_USCORErelationshipsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTocontact_USCOREdetail_USCOREarray(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREcontact_USCORErelationshipsResponse(struct soap *soap, const struct ns1__get_USCOREcontact_USCORErelationshipsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREcontact_USCORErelationshipsResponse);
	if (soap_out_ns1__get_USCOREcontact_USCORErelationshipsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREcontact_USCORErelationshipsResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREcontact_USCORErelationshipsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREcontact_USCORErelationshipsResponse), type))
		return soap->error;
	if (soap_out_PointerTocontact_USCOREdetail_USCOREarray(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREcontact_USCORErelationshipsResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREcontact_USCORErelationshipsResponse(struct soap *soap, struct ns1__get_USCOREcontact_USCORErelationshipsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREcontact_USCORErelationshipsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREcontact_USCORErelationshipsResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREcontact_USCORErelationshipsResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREcontact_USCORErelationshipsResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREcontact_USCORErelationshipsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREcontact_USCORErelationshipsResponse, sizeof(struct ns1__get_USCOREcontact_USCORErelationshipsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREcontact_USCORErelationshipsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTocontact_USCOREdetail_USCOREarray(soap, "return", &a->return_, "ns1:contact_detail"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREcontact_USCORErelationshipsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREcontact_USCORErelationshipsResponse, 0, sizeof(struct ns1__get_USCOREcontact_USCORErelationshipsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__contact_USCOREby_USCOREemail(struct soap *soap, struct ns1__contact_USCOREby_USCOREemail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->user_USCOREname);
	soap_default_string(soap, &a->password);
	soap_default_string(soap, &a->email_USCOREaddress);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__contact_USCOREby_USCOREemail(struct soap *soap, const struct ns1__contact_USCOREby_USCOREemail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->user_USCOREname);
	soap_serialize_string(soap, &a->password);
	soap_serialize_string(soap, &a->email_USCOREaddress);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__contact_USCOREby_USCOREemail(struct soap *soap, const struct ns1__contact_USCOREby_USCOREemail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__contact_USCOREby_USCOREemail);
	if (soap_out_ns1__contact_USCOREby_USCOREemail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__contact_USCOREby_USCOREemail(struct soap *soap, const char *tag, int id, const struct ns1__contact_USCOREby_USCOREemail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__contact_USCOREby_USCOREemail), type))
		return soap->error;
	if (soap_out_string(soap, "user_name", -1, &a->user_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_string(soap, "email_address", -1, &a->email_USCOREaddress, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__contact_USCOREby_USCOREemail * SOAP_FMAC4 soap_get_ns1__contact_USCOREby_USCOREemail(struct soap *soap, struct ns1__contact_USCOREby_USCOREemail *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__contact_USCOREby_USCOREemail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__contact_USCOREby_USCOREemail * SOAP_FMAC4 soap_in_ns1__contact_USCOREby_USCOREemail(struct soap *soap, const char *tag, struct ns1__contact_USCOREby_USCOREemail *a, const char *type)
{
	short soap_flag_user_USCOREname = 1, soap_flag_password = 1, soap_flag_email_USCOREaddress = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__contact_USCOREby_USCOREemail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__contact_USCOREby_USCOREemail, sizeof(struct ns1__contact_USCOREby_USCOREemail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__contact_USCOREby_USCOREemail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_user_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "user_name", &a->user_USCOREname, "xsd:string"))
				{	soap_flag_user_USCOREname--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_email_USCOREaddress && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "email_address", &a->email_USCOREaddress, "xsd:string"))
				{	soap_flag_email_USCOREaddress--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__contact_USCOREby_USCOREemail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__contact_USCOREby_USCOREemail, 0, sizeof(struct ns1__contact_USCOREby_USCOREemail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__contact_USCOREby_USCOREemailResponse(struct soap *soap, struct ns1__contact_USCOREby_USCOREemailResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__contact_USCOREby_USCOREemailResponse(struct soap *soap, const struct ns1__contact_USCOREby_USCOREemailResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTocontact_USCOREdetail_USCOREarray(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__contact_USCOREby_USCOREemailResponse(struct soap *soap, const struct ns1__contact_USCOREby_USCOREemailResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__contact_USCOREby_USCOREemailResponse);
	if (soap_out_ns1__contact_USCOREby_USCOREemailResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__contact_USCOREby_USCOREemailResponse(struct soap *soap, const char *tag, int id, const struct ns1__contact_USCOREby_USCOREemailResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__contact_USCOREby_USCOREemailResponse), type))
		return soap->error;
	if (soap_out_PointerTocontact_USCOREdetail_USCOREarray(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__contact_USCOREby_USCOREemailResponse * SOAP_FMAC4 soap_get_ns1__contact_USCOREby_USCOREemailResponse(struct soap *soap, struct ns1__contact_USCOREby_USCOREemailResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__contact_USCOREby_USCOREemailResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__contact_USCOREby_USCOREemailResponse * SOAP_FMAC4 soap_in_ns1__contact_USCOREby_USCOREemailResponse(struct soap *soap, const char *tag, struct ns1__contact_USCOREby_USCOREemailResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__contact_USCOREby_USCOREemailResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__contact_USCOREby_USCOREemailResponse, sizeof(struct ns1__contact_USCOREby_USCOREemailResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__contact_USCOREby_USCOREemailResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTocontact_USCOREdetail_USCOREarray(soap, "return", &a->return_, "ns1:contact_detail"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__contact_USCOREby_USCOREemailResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__contact_USCOREby_USCOREemailResponse, 0, sizeof(struct ns1__contact_USCOREby_USCOREemailResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__end_USCOREsession(struct soap *soap, struct ns1__end_USCOREsession *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->user_USCOREname);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__end_USCOREsession(struct soap *soap, const struct ns1__end_USCOREsession *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->user_USCOREname);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__end_USCOREsession(struct soap *soap, const struct ns1__end_USCOREsession *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__end_USCOREsession);
	if (soap_out_ns1__end_USCOREsession(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__end_USCOREsession(struct soap *soap, const char *tag, int id, const struct ns1__end_USCOREsession *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__end_USCOREsession), type))
		return soap->error;
	if (soap_out_string(soap, "user_name", -1, &a->user_USCOREname, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__end_USCOREsession * SOAP_FMAC4 soap_get_ns1__end_USCOREsession(struct soap *soap, struct ns1__end_USCOREsession *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__end_USCOREsession(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__end_USCOREsession * SOAP_FMAC4 soap_in_ns1__end_USCOREsession(struct soap *soap, const char *tag, struct ns1__end_USCOREsession *a, const char *type)
{
	short soap_flag_user_USCOREname = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__end_USCOREsession *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__end_USCOREsession, sizeof(struct ns1__end_USCOREsession), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__end_USCOREsession(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_user_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "user_name", &a->user_USCOREname, "xsd:string"))
				{	soap_flag_user_USCOREname--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__end_USCOREsession *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__end_USCOREsession, 0, sizeof(struct ns1__end_USCOREsession), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__end_USCOREsessionResponse(struct soap *soap, struct ns1__end_USCOREsessionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__end_USCOREsessionResponse(struct soap *soap, const struct ns1__end_USCOREsessionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__end_USCOREsessionResponse(struct soap *soap, const struct ns1__end_USCOREsessionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__end_USCOREsessionResponse);
	if (soap_out_ns1__end_USCOREsessionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__end_USCOREsessionResponse(struct soap *soap, const char *tag, int id, const struct ns1__end_USCOREsessionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__end_USCOREsessionResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__end_USCOREsessionResponse * SOAP_FMAC4 soap_get_ns1__end_USCOREsessionResponse(struct soap *soap, struct ns1__end_USCOREsessionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__end_USCOREsessionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__end_USCOREsessionResponse * SOAP_FMAC4 soap_in_ns1__end_USCOREsessionResponse(struct soap *soap, const char *tag, struct ns1__end_USCOREsessionResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__end_USCOREsessionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__end_USCOREsessionResponse, sizeof(struct ns1__end_USCOREsessionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__end_USCOREsessionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__end_USCOREsessionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__end_USCOREsessionResponse, 0, sizeof(struct ns1__end_USCOREsessionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__create_USCOREsession(struct soap *soap, struct ns1__create_USCOREsession *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->user_USCOREname);
	soap_default_string(soap, &a->password);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__create_USCOREsession(struct soap *soap, const struct ns1__create_USCOREsession *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->user_USCOREname);
	soap_serialize_string(soap, &a->password);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__create_USCOREsession(struct soap *soap, const struct ns1__create_USCOREsession *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__create_USCOREsession);
	if (soap_out_ns1__create_USCOREsession(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__create_USCOREsession(struct soap *soap, const char *tag, int id, const struct ns1__create_USCOREsession *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__create_USCOREsession), type))
		return soap->error;
	if (soap_out_string(soap, "user_name", -1, &a->user_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__create_USCOREsession * SOAP_FMAC4 soap_get_ns1__create_USCOREsession(struct soap *soap, struct ns1__create_USCOREsession *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__create_USCOREsession(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__create_USCOREsession * SOAP_FMAC4 soap_in_ns1__create_USCOREsession(struct soap *soap, const char *tag, struct ns1__create_USCOREsession *a, const char *type)
{
	short soap_flag_user_USCOREname = 1, soap_flag_password = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__create_USCOREsession *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__create_USCOREsession, sizeof(struct ns1__create_USCOREsession), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__create_USCOREsession(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_user_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "user_name", &a->user_USCOREname, "xsd:string"))
				{	soap_flag_user_USCOREname--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__create_USCOREsession *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__create_USCOREsession, 0, sizeof(struct ns1__create_USCOREsession), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__create_USCOREsessionResponse(struct soap *soap, struct ns1__create_USCOREsessionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__create_USCOREsessionResponse(struct soap *soap, const struct ns1__create_USCOREsessionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__create_USCOREsessionResponse(struct soap *soap, const struct ns1__create_USCOREsessionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__create_USCOREsessionResponse);
	if (soap_out_ns1__create_USCOREsessionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__create_USCOREsessionResponse(struct soap *soap, const char *tag, int id, const struct ns1__create_USCOREsessionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__create_USCOREsessionResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__create_USCOREsessionResponse * SOAP_FMAC4 soap_get_ns1__create_USCOREsessionResponse(struct soap *soap, struct ns1__create_USCOREsessionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__create_USCOREsessionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__create_USCOREsessionResponse * SOAP_FMAC4 soap_in_ns1__create_USCOREsessionResponse(struct soap *soap, const char *tag, struct ns1__create_USCOREsessionResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__create_USCOREsessionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__create_USCOREsessionResponse, sizeof(struct ns1__create_USCOREsessionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__create_USCOREsessionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__create_USCOREsessionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__create_USCOREsessionResponse, 0, sizeof(struct ns1__create_USCOREsessionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREattendee_USCORElist(struct soap *soap, struct ns1__get_USCOREattendee_USCORElist *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
	soap_default_string(soap, &a->module_USCOREname);
	soap_default_string(soap, &a->id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREattendee_USCORElist(struct soap *soap, const struct ns1__get_USCOREattendee_USCORElist *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
	soap_serialize_string(soap, &a->module_USCOREname);
	soap_serialize_string(soap, &a->id);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREattendee_USCORElist(struct soap *soap, const struct ns1__get_USCOREattendee_USCORElist *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREattendee_USCORElist);
	if (soap_out_ns1__get_USCOREattendee_USCORElist(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREattendee_USCORElist(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREattendee_USCORElist *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREattendee_USCORElist), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	if (soap_out_string(soap, "module_name", -1, &a->module_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "id", -1, &a->id, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREattendee_USCORElist * SOAP_FMAC4 soap_get_ns1__get_USCOREattendee_USCORElist(struct soap *soap, struct ns1__get_USCOREattendee_USCORElist *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREattendee_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREattendee_USCORElist * SOAP_FMAC4 soap_in_ns1__get_USCOREattendee_USCORElist(struct soap *soap, const char *tag, struct ns1__get_USCOREattendee_USCORElist *a, const char *type)
{
	short soap_flag_session = 1, soap_flag_module_USCOREname = 1, soap_flag_id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREattendee_USCORElist *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREattendee_USCORElist, sizeof(struct ns1__get_USCOREattendee_USCORElist), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREattendee_USCORElist(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap_flag_module_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module_name", &a->module_USCOREname, "xsd:string"))
				{	soap_flag_module_USCOREname--;
					continue;
				}
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREattendee_USCORElist *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREattendee_USCORElist, 0, sizeof(struct ns1__get_USCOREattendee_USCORElist), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREattendee_USCORElistResponse(struct soap *soap, struct ns1__get_USCOREattendee_USCORElistResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREattendee_USCORElistResponse(struct soap *soap, const struct ns1__get_USCOREattendee_USCORElistResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__get_USCOREsync_USCOREresult_USCOREencoded(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREattendee_USCORElistResponse(struct soap *soap, const struct ns1__get_USCOREattendee_USCORElistResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREattendee_USCORElistResponse);
	if (soap_out_ns1__get_USCOREattendee_USCORElistResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREattendee_USCORElistResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREattendee_USCORElistResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREattendee_USCORElistResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__get_USCOREsync_USCOREresult_USCOREencoded(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREattendee_USCORElistResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREattendee_USCORElistResponse(struct soap *soap, struct ns1__get_USCOREattendee_USCORElistResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREattendee_USCORElistResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREattendee_USCORElistResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREattendee_USCORElistResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREattendee_USCORElistResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREattendee_USCORElistResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREattendee_USCORElistResponse, sizeof(struct ns1__get_USCOREattendee_USCORElistResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREattendee_USCORElistResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__get_USCOREsync_USCOREresult_USCOREencoded(soap, "return", &a->return_, "ns1:get_sync_result_encoded"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREattendee_USCORElistResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREattendee_USCORElistResponse, 0, sizeof(struct ns1__get_USCOREattendee_USCORElistResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREmodified_USCOREentries(struct soap *soap, struct ns1__get_USCOREmodified_USCOREentries *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
	soap_default_string(soap, &a->module_USCOREname);
	a->ids = NULL;
	a->select_USCOREfields = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREmodified_USCOREentries(struct soap *soap, const struct ns1__get_USCOREmodified_USCOREentries *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
	soap_serialize_string(soap, &a->module_USCOREname);
	soap_serialize_PointerToselect_USCOREfields(soap, &a->ids);
	soap_serialize_PointerToselect_USCOREfields(soap, &a->select_USCOREfields);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREmodified_USCOREentries(struct soap *soap, const struct ns1__get_USCOREmodified_USCOREentries *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREmodified_USCOREentries);
	if (soap_out_ns1__get_USCOREmodified_USCOREentries(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREmodified_USCOREentries(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREmodified_USCOREentries *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREmodified_USCOREentries), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	if (soap_out_string(soap, "module_name", -1, &a->module_USCOREname, ""))
		return soap->error;
	if (soap_out_PointerToselect_USCOREfields(soap, "ids", -1, &a->ids, ""))
		return soap->error;
	if (soap_out_PointerToselect_USCOREfields(soap, "select_fields", -1, &a->select_USCOREfields, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREmodified_USCOREentries * SOAP_FMAC4 soap_get_ns1__get_USCOREmodified_USCOREentries(struct soap *soap, struct ns1__get_USCOREmodified_USCOREentries *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREmodified_USCOREentries(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREmodified_USCOREentries * SOAP_FMAC4 soap_in_ns1__get_USCOREmodified_USCOREentries(struct soap *soap, const char *tag, struct ns1__get_USCOREmodified_USCOREentries *a, const char *type)
{
	short soap_flag_session = 1, soap_flag_module_USCOREname = 1, soap_flag_ids = 1, soap_flag_select_USCOREfields = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREmodified_USCOREentries *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREmodified_USCOREentries, sizeof(struct ns1__get_USCOREmodified_USCOREentries), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREmodified_USCOREentries(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap_flag_module_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module_name", &a->module_USCOREname, "xsd:string"))
				{	soap_flag_module_USCOREname--;
					continue;
				}
			if (soap_flag_ids && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToselect_USCOREfields(soap, "ids", &a->ids, "xsd:string"))
				{	soap_flag_ids--;
					continue;
				}
			if (soap_flag_select_USCOREfields && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToselect_USCOREfields(soap, "select_fields", &a->select_USCOREfields, "xsd:string"))
				{	soap_flag_select_USCOREfields--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREmodified_USCOREentries *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREmodified_USCOREentries, 0, sizeof(struct ns1__get_USCOREmodified_USCOREentries), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREmodified_USCOREentriesResponse(struct soap *soap, struct ns1__get_USCOREmodified_USCOREentriesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREmodified_USCOREentriesResponse(struct soap *soap, const struct ns1__get_USCOREmodified_USCOREentriesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__get_USCOREsync_USCOREresult_USCOREencoded(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREmodified_USCOREentriesResponse(struct soap *soap, const struct ns1__get_USCOREmodified_USCOREentriesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREmodified_USCOREentriesResponse);
	if (soap_out_ns1__get_USCOREmodified_USCOREentriesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREmodified_USCOREentriesResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREmodified_USCOREentriesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREmodified_USCOREentriesResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__get_USCOREsync_USCOREresult_USCOREencoded(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREmodified_USCOREentriesResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREmodified_USCOREentriesResponse(struct soap *soap, struct ns1__get_USCOREmodified_USCOREentriesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREmodified_USCOREentriesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREmodified_USCOREentriesResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREmodified_USCOREentriesResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREmodified_USCOREentriesResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREmodified_USCOREentriesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREmodified_USCOREentriesResponse, sizeof(struct ns1__get_USCOREmodified_USCOREentriesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREmodified_USCOREentriesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__get_USCOREsync_USCOREresult_USCOREencoded(soap, "return", &a->return_, "ns1:get_sync_result_encoded"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREmodified_USCOREentriesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREmodified_USCOREentriesResponse, 0, sizeof(struct ns1__get_USCOREmodified_USCOREentriesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__sync_USCOREget_USCOREmodified_USCORErelationships(struct soap *soap, struct ns1__sync_USCOREget_USCOREmodified_USCORErelationships *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
	soap_default_string(soap, &a->module_USCOREname);
	soap_default_string(soap, &a->related_USCOREmodule);
	soap_default_string(soap, &a->from_USCOREdate);
	soap_default_string(soap, &a->to_USCOREdate);
	soap_default_int(soap, &a->offset);
	soap_default_int(soap, &a->max_USCOREresults);
	soap_default_int(soap, &a->deleted);
	soap_default_string(soap, &a->module_USCOREid);
	a->select_USCOREfields = NULL;
	a->ids = NULL;
	soap_default_string(soap, &a->relationship_USCOREname);
	soap_default_string(soap, &a->deletion_USCOREdate);
	soap_default_int(soap, &a->php_USCOREserialize);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__sync_USCOREget_USCOREmodified_USCORErelationships(struct soap *soap, const struct ns1__sync_USCOREget_USCOREmodified_USCORErelationships *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
	soap_serialize_string(soap, &a->module_USCOREname);
	soap_serialize_string(soap, &a->related_USCOREmodule);
	soap_serialize_string(soap, &a->from_USCOREdate);
	soap_serialize_string(soap, &a->to_USCOREdate);
	soap_embedded(soap, &a->offset, SOAP_TYPE_int);
	soap_embedded(soap, &a->max_USCOREresults, SOAP_TYPE_int);
	soap_embedded(soap, &a->deleted, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->module_USCOREid);
	soap_serialize_PointerToselect_USCOREfields(soap, &a->select_USCOREfields);
	soap_serialize_PointerToselect_USCOREfields(soap, &a->ids);
	soap_serialize_string(soap, &a->relationship_USCOREname);
	soap_serialize_string(soap, &a->deletion_USCOREdate);
	soap_embedded(soap, &a->php_USCOREserialize, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__sync_USCOREget_USCOREmodified_USCORErelationships(struct soap *soap, const struct ns1__sync_USCOREget_USCOREmodified_USCORErelationships *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__sync_USCOREget_USCOREmodified_USCORErelationships);
	if (soap_out_ns1__sync_USCOREget_USCOREmodified_USCORErelationships(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__sync_USCOREget_USCOREmodified_USCORErelationships(struct soap *soap, const char *tag, int id, const struct ns1__sync_USCOREget_USCOREmodified_USCORErelationships *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__sync_USCOREget_USCOREmodified_USCORErelationships), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	if (soap_out_string(soap, "module_name", -1, &a->module_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "related_module", -1, &a->related_USCOREmodule, ""))
		return soap->error;
	if (soap_out_string(soap, "from_date", -1, &a->from_USCOREdate, ""))
		return soap->error;
	if (soap_out_string(soap, "to_date", -1, &a->to_USCOREdate, ""))
		return soap->error;
	if (soap_out_int(soap, "offset", -1, &a->offset, ""))
		return soap->error;
	if (soap_out_int(soap, "max_results", -1, &a->max_USCOREresults, ""))
		return soap->error;
	if (soap_out_int(soap, "deleted", -1, &a->deleted, ""))
		return soap->error;
	if (soap_out_string(soap, "module_id", -1, &a->module_USCOREid, ""))
		return soap->error;
	if (soap_out_PointerToselect_USCOREfields(soap, "select_fields", -1, &a->select_USCOREfields, ""))
		return soap->error;
	if (soap_out_PointerToselect_USCOREfields(soap, "ids", -1, &a->ids, ""))
		return soap->error;
	if (soap_out_string(soap, "relationship_name", -1, &a->relationship_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "deletion_date", -1, &a->deletion_USCOREdate, ""))
		return soap->error;
	if (soap_out_int(soap, "php_serialize", -1, &a->php_USCOREserialize, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__sync_USCOREget_USCOREmodified_USCORErelationships * SOAP_FMAC4 soap_get_ns1__sync_USCOREget_USCOREmodified_USCORErelationships(struct soap *soap, struct ns1__sync_USCOREget_USCOREmodified_USCORErelationships *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__sync_USCOREget_USCOREmodified_USCORErelationships(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__sync_USCOREget_USCOREmodified_USCORErelationships * SOAP_FMAC4 soap_in_ns1__sync_USCOREget_USCOREmodified_USCORErelationships(struct soap *soap, const char *tag, struct ns1__sync_USCOREget_USCOREmodified_USCORErelationships *a, const char *type)
{
	short soap_flag_session = 1, soap_flag_module_USCOREname = 1, soap_flag_related_USCOREmodule = 1, soap_flag_from_USCOREdate = 1, soap_flag_to_USCOREdate = 1, soap_flag_offset = 1, soap_flag_max_USCOREresults = 1, soap_flag_deleted = 1, soap_flag_module_USCOREid = 1, soap_flag_select_USCOREfields = 1, soap_flag_ids = 1, soap_flag_relationship_USCOREname = 1, soap_flag_deletion_USCOREdate = 1, soap_flag_php_USCOREserialize = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__sync_USCOREget_USCOREmodified_USCORErelationships *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__sync_USCOREget_USCOREmodified_USCORErelationships, sizeof(struct ns1__sync_USCOREget_USCOREmodified_USCORErelationships), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__sync_USCOREget_USCOREmodified_USCORErelationships(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap_flag_module_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module_name", &a->module_USCOREname, "xsd:string"))
				{	soap_flag_module_USCOREname--;
					continue;
				}
			if (soap_flag_related_USCOREmodule && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "related_module", &a->related_USCOREmodule, "xsd:string"))
				{	soap_flag_related_USCOREmodule--;
					continue;
				}
			if (soap_flag_from_USCOREdate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "from_date", &a->from_USCOREdate, "xsd:string"))
				{	soap_flag_from_USCOREdate--;
					continue;
				}
			if (soap_flag_to_USCOREdate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "to_date", &a->to_USCOREdate, "xsd:string"))
				{	soap_flag_to_USCOREdate--;
					continue;
				}
			if (soap_flag_offset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "offset", &a->offset, "xsd:int"))
				{	soap_flag_offset--;
					continue;
				}
			if (soap_flag_max_USCOREresults && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "max_results", &a->max_USCOREresults, "xsd:int"))
				{	soap_flag_max_USCOREresults--;
					continue;
				}
			if (soap_flag_deleted && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "deleted", &a->deleted, "xsd:int"))
				{	soap_flag_deleted--;
					continue;
				}
			if (soap_flag_module_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module_id", &a->module_USCOREid, "xsd:string"))
				{	soap_flag_module_USCOREid--;
					continue;
				}
			if (soap_flag_select_USCOREfields && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToselect_USCOREfields(soap, "select_fields", &a->select_USCOREfields, "xsd:string"))
				{	soap_flag_select_USCOREfields--;
					continue;
				}
			if (soap_flag_ids && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToselect_USCOREfields(soap, "ids", &a->ids, "xsd:string"))
				{	soap_flag_ids--;
					continue;
				}
			if (soap_flag_relationship_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "relationship_name", &a->relationship_USCOREname, "xsd:string"))
				{	soap_flag_relationship_USCOREname--;
					continue;
				}
			if (soap_flag_deletion_USCOREdate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "deletion_date", &a->deletion_USCOREdate, "xsd:string"))
				{	soap_flag_deletion_USCOREdate--;
					continue;
				}
			if (soap_flag_php_USCOREserialize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "php_serialize", &a->php_USCOREserialize, "xsd:int"))
				{	soap_flag_php_USCOREserialize--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__sync_USCOREget_USCOREmodified_USCORErelationships *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__sync_USCOREget_USCOREmodified_USCORErelationships, 0, sizeof(struct ns1__sync_USCOREget_USCOREmodified_USCORErelationships), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_offset > 0 || soap_flag_max_USCOREresults > 0 || soap_flag_deleted > 0 || soap_flag_php_USCOREserialize > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse(struct soap *soap, struct ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse(struct soap *soap, const struct ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse(struct soap *soap, const struct ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse);
	if (soap_out_ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse(struct soap *soap, const char *tag, int id, const struct ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse * SOAP_FMAC4 soap_get_ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse(struct soap *soap, struct ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse * SOAP_FMAC4 soap_in_ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse(struct soap *soap, const char *tag, struct ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse, sizeof(struct ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded(soap, "return", &a->return_, "ns1:get_entry_list_result_encoded"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse, 0, sizeof(struct ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__set_USCOREentries_USCOREdetails(struct soap *soap, struct ns1__set_USCOREentries_USCOREdetails *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
	soap_default_string(soap, &a->module_USCOREname);
	a->name_USCOREvalue_USCORElists = NULL;
	a->select_USCOREfields = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__set_USCOREentries_USCOREdetails(struct soap *soap, const struct ns1__set_USCOREentries_USCOREdetails *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
	soap_serialize_string(soap, &a->module_USCOREname);
	soap_serialize_PointerToname_USCOREvalue_USCORElists(soap, &a->name_USCOREvalue_USCORElists);
	soap_serialize_PointerToselect_USCOREfields(soap, &a->select_USCOREfields);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__set_USCOREentries_USCOREdetails(struct soap *soap, const struct ns1__set_USCOREentries_USCOREdetails *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__set_USCOREentries_USCOREdetails);
	if (soap_out_ns1__set_USCOREentries_USCOREdetails(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__set_USCOREentries_USCOREdetails(struct soap *soap, const char *tag, int id, const struct ns1__set_USCOREentries_USCOREdetails *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__set_USCOREentries_USCOREdetails), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	if (soap_out_string(soap, "module_name", -1, &a->module_USCOREname, ""))
		return soap->error;
	if (soap_out_PointerToname_USCOREvalue_USCORElists(soap, "name_value_lists", -1, &a->name_USCOREvalue_USCORElists, ""))
		return soap->error;
	if (soap_out_PointerToselect_USCOREfields(soap, "select_fields", -1, &a->select_USCOREfields, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__set_USCOREentries_USCOREdetails * SOAP_FMAC4 soap_get_ns1__set_USCOREentries_USCOREdetails(struct soap *soap, struct ns1__set_USCOREentries_USCOREdetails *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__set_USCOREentries_USCOREdetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__set_USCOREentries_USCOREdetails * SOAP_FMAC4 soap_in_ns1__set_USCOREentries_USCOREdetails(struct soap *soap, const char *tag, struct ns1__set_USCOREentries_USCOREdetails *a, const char *type)
{
	short soap_flag_session = 1, soap_flag_module_USCOREname = 1, soap_flag_name_USCOREvalue_USCORElists = 1, soap_flag_select_USCOREfields = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__set_USCOREentries_USCOREdetails *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__set_USCOREentries_USCOREdetails, sizeof(struct ns1__set_USCOREentries_USCOREdetails), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__set_USCOREentries_USCOREdetails(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap_flag_module_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module_name", &a->module_USCOREname, "xsd:string"))
				{	soap_flag_module_USCOREname--;
					continue;
				}
			if (soap_flag_name_USCOREvalue_USCORElists && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToname_USCOREvalue_USCORElists(soap, "name_value_lists", &a->name_USCOREvalue_USCORElists, "ns1:name_value"))
				{	soap_flag_name_USCOREvalue_USCORElists--;
					continue;
				}
			if (soap_flag_select_USCOREfields && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToselect_USCOREfields(soap, "select_fields", &a->select_USCOREfields, "xsd:string"))
				{	soap_flag_select_USCOREfields--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCOREentries_USCOREdetails *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__set_USCOREentries_USCOREdetails, 0, sizeof(struct ns1__set_USCOREentries_USCOREdetails), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__set_USCOREentries_USCOREdetailsResponse(struct soap *soap, struct ns1__set_USCOREentries_USCOREdetailsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__set_USCOREentries_USCOREdetailsResponse(struct soap *soap, const struct ns1__set_USCOREentries_USCOREdetailsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__set_USCOREentries_USCOREdetail_USCOREresult(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__set_USCOREentries_USCOREdetailsResponse(struct soap *soap, const struct ns1__set_USCOREentries_USCOREdetailsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__set_USCOREentries_USCOREdetailsResponse);
	if (soap_out_ns1__set_USCOREentries_USCOREdetailsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__set_USCOREentries_USCOREdetailsResponse(struct soap *soap, const char *tag, int id, const struct ns1__set_USCOREentries_USCOREdetailsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__set_USCOREentries_USCOREdetailsResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__set_USCOREentries_USCOREdetail_USCOREresult(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__set_USCOREentries_USCOREdetailsResponse * SOAP_FMAC4 soap_get_ns1__set_USCOREentries_USCOREdetailsResponse(struct soap *soap, struct ns1__set_USCOREentries_USCOREdetailsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__set_USCOREentries_USCOREdetailsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__set_USCOREentries_USCOREdetailsResponse * SOAP_FMAC4 soap_in_ns1__set_USCOREentries_USCOREdetailsResponse(struct soap *soap, const char *tag, struct ns1__set_USCOREentries_USCOREdetailsResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__set_USCOREentries_USCOREdetailsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__set_USCOREentries_USCOREdetailsResponse, sizeof(struct ns1__set_USCOREentries_USCOREdetailsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__set_USCOREentries_USCOREdetailsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__set_USCOREentries_USCOREdetail_USCOREresult(soap, "return", &a->return_, "ns1:set_entries_detail_result"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCOREentries_USCOREdetailsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__set_USCOREentries_USCOREdetailsResponse, 0, sizeof(struct ns1__set_USCOREentries_USCOREdetailsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREentries_USCOREcount(struct soap *soap, struct ns1__get_USCOREentries_USCOREcount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
	soap_default_string(soap, &a->module_USCOREname);
	soap_default_string(soap, &a->query);
	soap_default_int(soap, &a->deleted);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREentries_USCOREcount(struct soap *soap, const struct ns1__get_USCOREentries_USCOREcount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
	soap_serialize_string(soap, &a->module_USCOREname);
	soap_serialize_string(soap, &a->query);
	soap_embedded(soap, &a->deleted, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREentries_USCOREcount(struct soap *soap, const struct ns1__get_USCOREentries_USCOREcount *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREentries_USCOREcount);
	if (soap_out_ns1__get_USCOREentries_USCOREcount(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREentries_USCOREcount(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREentries_USCOREcount *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREentries_USCOREcount), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	if (soap_out_string(soap, "module_name", -1, &a->module_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "query", -1, &a->query, ""))
		return soap->error;
	if (soap_out_int(soap, "deleted", -1, &a->deleted, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREentries_USCOREcount * SOAP_FMAC4 soap_get_ns1__get_USCOREentries_USCOREcount(struct soap *soap, struct ns1__get_USCOREentries_USCOREcount *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREentries_USCOREcount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREentries_USCOREcount * SOAP_FMAC4 soap_in_ns1__get_USCOREentries_USCOREcount(struct soap *soap, const char *tag, struct ns1__get_USCOREentries_USCOREcount *a, const char *type)
{
	short soap_flag_session = 1, soap_flag_module_USCOREname = 1, soap_flag_query = 1, soap_flag_deleted = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREentries_USCOREcount *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREentries_USCOREcount, sizeof(struct ns1__get_USCOREentries_USCOREcount), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREentries_USCOREcount(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap_flag_module_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module_name", &a->module_USCOREname, "xsd:string"))
				{	soap_flag_module_USCOREname--;
					continue;
				}
			if (soap_flag_query && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "query", &a->query, "xsd:string"))
				{	soap_flag_query--;
					continue;
				}
			if (soap_flag_deleted && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "deleted", &a->deleted, "xsd:int"))
				{	soap_flag_deleted--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREentries_USCOREcount *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREentries_USCOREcount, 0, sizeof(struct ns1__get_USCOREentries_USCOREcount), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_deleted > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREentries_USCOREcountResponse(struct soap *soap, struct ns1__get_USCOREentries_USCOREcountResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREentries_USCOREcountResponse(struct soap *soap, const struct ns1__get_USCOREentries_USCOREcountResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__get_USCOREentries_USCOREcount_USCOREresult(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREentries_USCOREcountResponse(struct soap *soap, const struct ns1__get_USCOREentries_USCOREcountResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREentries_USCOREcountResponse);
	if (soap_out_ns1__get_USCOREentries_USCOREcountResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREentries_USCOREcountResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREentries_USCOREcountResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREentries_USCOREcountResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__get_USCOREentries_USCOREcount_USCOREresult(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREentries_USCOREcountResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREentries_USCOREcountResponse(struct soap *soap, struct ns1__get_USCOREentries_USCOREcountResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREentries_USCOREcountResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREentries_USCOREcountResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREentries_USCOREcountResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREentries_USCOREcountResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREentries_USCOREcountResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREentries_USCOREcountResponse, sizeof(struct ns1__get_USCOREentries_USCOREcountResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREentries_USCOREcountResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__get_USCOREentries_USCOREcount_USCOREresult(soap, "return", &a->return_, "ns1:get_entries_count_result"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREentries_USCOREcountResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREentries_USCOREcountResponse, 0, sizeof(struct ns1__get_USCOREentries_USCOREcountResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__set_USCOREcampaign_USCOREmerge(struct soap *soap, struct ns1__set_USCOREcampaign_USCOREmerge *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
	a->targets = NULL;
	soap_default_string(soap, &a->campaign_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__set_USCOREcampaign_USCOREmerge(struct soap *soap, const struct ns1__set_USCOREcampaign_USCOREmerge *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
	soap_serialize_PointerToselect_USCOREfields(soap, &a->targets);
	soap_serialize_string(soap, &a->campaign_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__set_USCOREcampaign_USCOREmerge(struct soap *soap, const struct ns1__set_USCOREcampaign_USCOREmerge *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__set_USCOREcampaign_USCOREmerge);
	if (soap_out_ns1__set_USCOREcampaign_USCOREmerge(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__set_USCOREcampaign_USCOREmerge(struct soap *soap, const char *tag, int id, const struct ns1__set_USCOREcampaign_USCOREmerge *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__set_USCOREcampaign_USCOREmerge), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	if (soap_out_PointerToselect_USCOREfields(soap, "targets", -1, &a->targets, ""))
		return soap->error;
	if (soap_out_string(soap, "campaign_id", -1, &a->campaign_USCOREid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__set_USCOREcampaign_USCOREmerge * SOAP_FMAC4 soap_get_ns1__set_USCOREcampaign_USCOREmerge(struct soap *soap, struct ns1__set_USCOREcampaign_USCOREmerge *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__set_USCOREcampaign_USCOREmerge(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__set_USCOREcampaign_USCOREmerge * SOAP_FMAC4 soap_in_ns1__set_USCOREcampaign_USCOREmerge(struct soap *soap, const char *tag, struct ns1__set_USCOREcampaign_USCOREmerge *a, const char *type)
{
	short soap_flag_session = 1, soap_flag_targets = 1, soap_flag_campaign_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__set_USCOREcampaign_USCOREmerge *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__set_USCOREcampaign_USCOREmerge, sizeof(struct ns1__set_USCOREcampaign_USCOREmerge), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__set_USCOREcampaign_USCOREmerge(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap_flag_targets && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToselect_USCOREfields(soap, "targets", &a->targets, "xsd:string"))
				{	soap_flag_targets--;
					continue;
				}
			if (soap_flag_campaign_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "campaign_id", &a->campaign_USCOREid, "xsd:string"))
				{	soap_flag_campaign_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCOREcampaign_USCOREmerge *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__set_USCOREcampaign_USCOREmerge, 0, sizeof(struct ns1__set_USCOREcampaign_USCOREmerge), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__set_USCOREcampaign_USCOREmergeResponse(struct soap *soap, struct ns1__set_USCOREcampaign_USCOREmergeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__set_USCOREcampaign_USCOREmergeResponse(struct soap *soap, const struct ns1__set_USCOREcampaign_USCOREmergeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__error_USCOREvalue(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__set_USCOREcampaign_USCOREmergeResponse(struct soap *soap, const struct ns1__set_USCOREcampaign_USCOREmergeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__set_USCOREcampaign_USCOREmergeResponse);
	if (soap_out_ns1__set_USCOREcampaign_USCOREmergeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__set_USCOREcampaign_USCOREmergeResponse(struct soap *soap, const char *tag, int id, const struct ns1__set_USCOREcampaign_USCOREmergeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__set_USCOREcampaign_USCOREmergeResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__error_USCOREvalue(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__set_USCOREcampaign_USCOREmergeResponse * SOAP_FMAC4 soap_get_ns1__set_USCOREcampaign_USCOREmergeResponse(struct soap *soap, struct ns1__set_USCOREcampaign_USCOREmergeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__set_USCOREcampaign_USCOREmergeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__set_USCOREcampaign_USCOREmergeResponse * SOAP_FMAC4 soap_in_ns1__set_USCOREcampaign_USCOREmergeResponse(struct soap *soap, const char *tag, struct ns1__set_USCOREcampaign_USCOREmergeResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__set_USCOREcampaign_USCOREmergeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__set_USCOREcampaign_USCOREmergeResponse, sizeof(struct ns1__set_USCOREcampaign_USCOREmergeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__set_USCOREcampaign_USCOREmergeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__error_USCOREvalue(soap, "return", &a->return_, "ns1:error_value"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCOREcampaign_USCOREmergeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__set_USCOREcampaign_USCOREmergeResponse, 0, sizeof(struct ns1__set_USCOREcampaign_USCOREmergeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREdocument_USCORErevision(struct soap *soap, struct ns1__get_USCOREdocument_USCORErevision *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
	soap_default_string(soap, &a->i);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREdocument_USCORErevision(struct soap *soap, const struct ns1__get_USCOREdocument_USCORErevision *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
	soap_serialize_string(soap, &a->i);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREdocument_USCORErevision(struct soap *soap, const struct ns1__get_USCOREdocument_USCORErevision *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREdocument_USCORErevision);
	if (soap_out_ns1__get_USCOREdocument_USCORErevision(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREdocument_USCORErevision(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREdocument_USCORErevision *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREdocument_USCORErevision), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	if (soap_out_string(soap, "i", -1, &a->i, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREdocument_USCORErevision * SOAP_FMAC4 soap_get_ns1__get_USCOREdocument_USCORErevision(struct soap *soap, struct ns1__get_USCOREdocument_USCORErevision *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREdocument_USCORErevision(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREdocument_USCORErevision * SOAP_FMAC4 soap_in_ns1__get_USCOREdocument_USCORErevision(struct soap *soap, const char *tag, struct ns1__get_USCOREdocument_USCORErevision *a, const char *type)
{
	short soap_flag_session = 1, soap_flag_i = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREdocument_USCORErevision *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREdocument_USCORErevision, sizeof(struct ns1__get_USCOREdocument_USCORErevision), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREdocument_USCORErevision(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap_flag_i && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "i", &a->i, "xsd:string"))
				{	soap_flag_i--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREdocument_USCORErevision *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREdocument_USCORErevision, 0, sizeof(struct ns1__get_USCOREdocument_USCORErevision), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREdocument_USCORErevisionResponse(struct soap *soap, struct ns1__get_USCOREdocument_USCORErevisionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREdocument_USCORErevisionResponse(struct soap *soap, const struct ns1__get_USCOREdocument_USCORErevisionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__return_USCOREdocument_USCORErevision(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREdocument_USCORErevisionResponse(struct soap *soap, const struct ns1__get_USCOREdocument_USCORErevisionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREdocument_USCORErevisionResponse);
	if (soap_out_ns1__get_USCOREdocument_USCORErevisionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREdocument_USCORErevisionResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREdocument_USCORErevisionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREdocument_USCORErevisionResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__return_USCOREdocument_USCORErevision(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREdocument_USCORErevisionResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREdocument_USCORErevisionResponse(struct soap *soap, struct ns1__get_USCOREdocument_USCORErevisionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREdocument_USCORErevisionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREdocument_USCORErevisionResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREdocument_USCORErevisionResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREdocument_USCORErevisionResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREdocument_USCORErevisionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREdocument_USCORErevisionResponse, sizeof(struct ns1__get_USCOREdocument_USCORErevisionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREdocument_USCORErevisionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__return_USCOREdocument_USCORErevision(soap, "return", &a->return_, "ns1:return_document_revision"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREdocument_USCORErevisionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREdocument_USCORErevisionResponse, 0, sizeof(struct ns1__get_USCOREdocument_USCORErevisionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREmailmerge_USCOREdocument2(struct soap *soap, struct ns1__get_USCOREmailmerge_USCOREdocument2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
	soap_default_string(soap, &a->file_USCOREname);
	a->fields = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREmailmerge_USCOREdocument2(struct soap *soap, const struct ns1__get_USCOREmailmerge_USCOREdocument2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
	soap_serialize_string(soap, &a->file_USCOREname);
	soap_serialize_PointerToselect_USCOREfields(soap, &a->fields);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREmailmerge_USCOREdocument2(struct soap *soap, const struct ns1__get_USCOREmailmerge_USCOREdocument2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocument2);
	if (soap_out_ns1__get_USCOREmailmerge_USCOREdocument2(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREmailmerge_USCOREdocument2(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREmailmerge_USCOREdocument2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocument2), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	if (soap_out_string(soap, "file_name", -1, &a->file_USCOREname, ""))
		return soap->error;
	if (soap_out_PointerToselect_USCOREfields(soap, "fields", -1, &a->fields, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREmailmerge_USCOREdocument2 * SOAP_FMAC4 soap_get_ns1__get_USCOREmailmerge_USCOREdocument2(struct soap *soap, struct ns1__get_USCOREmailmerge_USCOREdocument2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREmailmerge_USCOREdocument2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREmailmerge_USCOREdocument2 * SOAP_FMAC4 soap_in_ns1__get_USCOREmailmerge_USCOREdocument2(struct soap *soap, const char *tag, struct ns1__get_USCOREmailmerge_USCOREdocument2 *a, const char *type)
{
	short soap_flag_session = 1, soap_flag_file_USCOREname = 1, soap_flag_fields = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREmailmerge_USCOREdocument2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocument2, sizeof(struct ns1__get_USCOREmailmerge_USCOREdocument2), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREmailmerge_USCOREdocument2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap_flag_file_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "file_name", &a->file_USCOREname, "xsd:string"))
				{	soap_flag_file_USCOREname--;
					continue;
				}
			if (soap_flag_fields && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToselect_USCOREfields(soap, "fields", &a->fields, "xsd:string"))
				{	soap_flag_fields--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREmailmerge_USCOREdocument2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocument2, 0, sizeof(struct ns1__get_USCOREmailmerge_USCOREdocument2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREmailmerge_USCOREdocument2Response(struct soap *soap, struct ns1__get_USCOREmailmerge_USCOREdocument2Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREmailmerge_USCOREdocument2Response(struct soap *soap, const struct ns1__get_USCOREmailmerge_USCOREdocument2Response *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__get_USCOREmailmerge_USCOREdocument_USCOREresult(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREmailmerge_USCOREdocument2Response(struct soap *soap, const struct ns1__get_USCOREmailmerge_USCOREdocument2Response *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocument2Response);
	if (soap_out_ns1__get_USCOREmailmerge_USCOREdocument2Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREmailmerge_USCOREdocument2Response(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREmailmerge_USCOREdocument2Response *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocument2Response), type))
		return soap->error;
	if (soap_out_PointerTons1__get_USCOREmailmerge_USCOREdocument_USCOREresult(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREmailmerge_USCOREdocument2Response * SOAP_FMAC4 soap_get_ns1__get_USCOREmailmerge_USCOREdocument2Response(struct soap *soap, struct ns1__get_USCOREmailmerge_USCOREdocument2Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREmailmerge_USCOREdocument2Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREmailmerge_USCOREdocument2Response * SOAP_FMAC4 soap_in_ns1__get_USCOREmailmerge_USCOREdocument2Response(struct soap *soap, const char *tag, struct ns1__get_USCOREmailmerge_USCOREdocument2Response *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREmailmerge_USCOREdocument2Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocument2Response, sizeof(struct ns1__get_USCOREmailmerge_USCOREdocument2Response), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREmailmerge_USCOREdocument2Response(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__get_USCOREmailmerge_USCOREdocument_USCOREresult(soap, "return", &a->return_, "ns1:get_mailmerge_document_result"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREmailmerge_USCOREdocument2Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocument2Response, 0, sizeof(struct ns1__get_USCOREmailmerge_USCOREdocument2Response), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREmailmerge_USCOREdocument(struct soap *soap, struct ns1__get_USCOREmailmerge_USCOREdocument *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
	soap_default_string(soap, &a->file_USCOREname);
	a->fields = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREmailmerge_USCOREdocument(struct soap *soap, const struct ns1__get_USCOREmailmerge_USCOREdocument *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
	soap_serialize_string(soap, &a->file_USCOREname);
	soap_serialize_PointerToselect_USCOREfields(soap, &a->fields);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREmailmerge_USCOREdocument(struct soap *soap, const struct ns1__get_USCOREmailmerge_USCOREdocument *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocument);
	if (soap_out_ns1__get_USCOREmailmerge_USCOREdocument(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREmailmerge_USCOREdocument(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREmailmerge_USCOREdocument *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocument), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	if (soap_out_string(soap, "file_name", -1, &a->file_USCOREname, ""))
		return soap->error;
	if (soap_out_PointerToselect_USCOREfields(soap, "fields", -1, &a->fields, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREmailmerge_USCOREdocument * SOAP_FMAC4 soap_get_ns1__get_USCOREmailmerge_USCOREdocument(struct soap *soap, struct ns1__get_USCOREmailmerge_USCOREdocument *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREmailmerge_USCOREdocument(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREmailmerge_USCOREdocument * SOAP_FMAC4 soap_in_ns1__get_USCOREmailmerge_USCOREdocument(struct soap *soap, const char *tag, struct ns1__get_USCOREmailmerge_USCOREdocument *a, const char *type)
{
	short soap_flag_session = 1, soap_flag_file_USCOREname = 1, soap_flag_fields = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREmailmerge_USCOREdocument *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocument, sizeof(struct ns1__get_USCOREmailmerge_USCOREdocument), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREmailmerge_USCOREdocument(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap_flag_file_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "file_name", &a->file_USCOREname, "xsd:string"))
				{	soap_flag_file_USCOREname--;
					continue;
				}
			if (soap_flag_fields && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToselect_USCOREfields(soap, "fields", &a->fields, "xsd:string"))
				{	soap_flag_fields--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREmailmerge_USCOREdocument *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocument, 0, sizeof(struct ns1__get_USCOREmailmerge_USCOREdocument), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREmailmerge_USCOREdocumentResponse(struct soap *soap, struct ns1__get_USCOREmailmerge_USCOREdocumentResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREmailmerge_USCOREdocumentResponse(struct soap *soap, const struct ns1__get_USCOREmailmerge_USCOREdocumentResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__get_USCOREsync_USCOREresult_USCOREencoded(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREmailmerge_USCOREdocumentResponse(struct soap *soap, const struct ns1__get_USCOREmailmerge_USCOREdocumentResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocumentResponse);
	if (soap_out_ns1__get_USCOREmailmerge_USCOREdocumentResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREmailmerge_USCOREdocumentResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREmailmerge_USCOREdocumentResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocumentResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__get_USCOREsync_USCOREresult_USCOREencoded(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREmailmerge_USCOREdocumentResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREmailmerge_USCOREdocumentResponse(struct soap *soap, struct ns1__get_USCOREmailmerge_USCOREdocumentResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREmailmerge_USCOREdocumentResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREmailmerge_USCOREdocumentResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREmailmerge_USCOREdocumentResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREmailmerge_USCOREdocumentResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREmailmerge_USCOREdocumentResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocumentResponse, sizeof(struct ns1__get_USCOREmailmerge_USCOREdocumentResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREmailmerge_USCOREdocumentResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__get_USCOREsync_USCOREresult_USCOREencoded(soap, "return", &a->return_, "ns1:get_sync_result_encoded"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREmailmerge_USCOREdocumentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocumentResponse, 0, sizeof(struct ns1__get_USCOREmailmerge_USCOREdocumentResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__search_USCOREby_USCOREmodule(struct soap *soap, struct ns1__search_USCOREby_USCOREmodule *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->user_USCOREname);
	soap_default_string(soap, &a->password);
	soap_default_string(soap, &a->search_USCOREstring);
	a->modules = NULL;
	soap_default_int(soap, &a->offset);
	soap_default_int(soap, &a->max_USCOREresults);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__search_USCOREby_USCOREmodule(struct soap *soap, const struct ns1__search_USCOREby_USCOREmodule *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->user_USCOREname);
	soap_serialize_string(soap, &a->password);
	soap_serialize_string(soap, &a->search_USCOREstring);
	soap_serialize_PointerToselect_USCOREfields(soap, &a->modules);
	soap_embedded(soap, &a->offset, SOAP_TYPE_int);
	soap_embedded(soap, &a->max_USCOREresults, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__search_USCOREby_USCOREmodule(struct soap *soap, const struct ns1__search_USCOREby_USCOREmodule *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__search_USCOREby_USCOREmodule);
	if (soap_out_ns1__search_USCOREby_USCOREmodule(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__search_USCOREby_USCOREmodule(struct soap *soap, const char *tag, int id, const struct ns1__search_USCOREby_USCOREmodule *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__search_USCOREby_USCOREmodule), type))
		return soap->error;
	if (soap_out_string(soap, "user_name", -1, &a->user_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_string(soap, "search_string", -1, &a->search_USCOREstring, ""))
		return soap->error;
	if (soap_out_PointerToselect_USCOREfields(soap, "modules", -1, &a->modules, ""))
		return soap->error;
	if (soap_out_int(soap, "offset", -1, &a->offset, ""))
		return soap->error;
	if (soap_out_int(soap, "max_results", -1, &a->max_USCOREresults, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__search_USCOREby_USCOREmodule * SOAP_FMAC4 soap_get_ns1__search_USCOREby_USCOREmodule(struct soap *soap, struct ns1__search_USCOREby_USCOREmodule *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__search_USCOREby_USCOREmodule(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__search_USCOREby_USCOREmodule * SOAP_FMAC4 soap_in_ns1__search_USCOREby_USCOREmodule(struct soap *soap, const char *tag, struct ns1__search_USCOREby_USCOREmodule *a, const char *type)
{
	short soap_flag_user_USCOREname = 1, soap_flag_password = 1, soap_flag_search_USCOREstring = 1, soap_flag_modules = 1, soap_flag_offset = 1, soap_flag_max_USCOREresults = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__search_USCOREby_USCOREmodule *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__search_USCOREby_USCOREmodule, sizeof(struct ns1__search_USCOREby_USCOREmodule), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__search_USCOREby_USCOREmodule(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_user_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "user_name", &a->user_USCOREname, "xsd:string"))
				{	soap_flag_user_USCOREname--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_search_USCOREstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "search_string", &a->search_USCOREstring, "xsd:string"))
				{	soap_flag_search_USCOREstring--;
					continue;
				}
			if (soap_flag_modules && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToselect_USCOREfields(soap, "modules", &a->modules, "xsd:string"))
				{	soap_flag_modules--;
					continue;
				}
			if (soap_flag_offset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "offset", &a->offset, "xsd:int"))
				{	soap_flag_offset--;
					continue;
				}
			if (soap_flag_max_USCOREresults && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "max_results", &a->max_USCOREresults, "xsd:int"))
				{	soap_flag_max_USCOREresults--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__search_USCOREby_USCOREmodule *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__search_USCOREby_USCOREmodule, 0, sizeof(struct ns1__search_USCOREby_USCOREmodule), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_offset > 0 || soap_flag_max_USCOREresults > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__search_USCOREby_USCOREmoduleResponse(struct soap *soap, struct ns1__search_USCOREby_USCOREmoduleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__search_USCOREby_USCOREmoduleResponse(struct soap *soap, const struct ns1__search_USCOREby_USCOREmoduleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__get_USCOREentry_USCORElist_USCOREresult(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__search_USCOREby_USCOREmoduleResponse(struct soap *soap, const struct ns1__search_USCOREby_USCOREmoduleResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__search_USCOREby_USCOREmoduleResponse);
	if (soap_out_ns1__search_USCOREby_USCOREmoduleResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__search_USCOREby_USCOREmoduleResponse(struct soap *soap, const char *tag, int id, const struct ns1__search_USCOREby_USCOREmoduleResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__search_USCOREby_USCOREmoduleResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__get_USCOREentry_USCORElist_USCOREresult(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__search_USCOREby_USCOREmoduleResponse * SOAP_FMAC4 soap_get_ns1__search_USCOREby_USCOREmoduleResponse(struct soap *soap, struct ns1__search_USCOREby_USCOREmoduleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__search_USCOREby_USCOREmoduleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__search_USCOREby_USCOREmoduleResponse * SOAP_FMAC4 soap_in_ns1__search_USCOREby_USCOREmoduleResponse(struct soap *soap, const char *tag, struct ns1__search_USCOREby_USCOREmoduleResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__search_USCOREby_USCOREmoduleResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__search_USCOREby_USCOREmoduleResponse, sizeof(struct ns1__search_USCOREby_USCOREmoduleResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__search_USCOREby_USCOREmoduleResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__get_USCOREentry_USCORElist_USCOREresult(soap, "return", &a->return_, "ns1:get_entry_list_result"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__search_USCOREby_USCOREmoduleResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__search_USCOREby_USCOREmoduleResponse, 0, sizeof(struct ns1__search_USCOREby_USCOREmoduleResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__set_USCOREdocument_USCORErevision(struct soap *soap, struct ns1__set_USCOREdocument_USCORErevision *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
	a->note = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__set_USCOREdocument_USCORErevision(struct soap *soap, const struct ns1__set_USCOREdocument_USCORErevision *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
	soap_serialize_PointerTons1__document_USCORErevision(soap, &a->note);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__set_USCOREdocument_USCORErevision(struct soap *soap, const struct ns1__set_USCOREdocument_USCORErevision *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__set_USCOREdocument_USCORErevision);
	if (soap_out_ns1__set_USCOREdocument_USCORErevision(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__set_USCOREdocument_USCORErevision(struct soap *soap, const char *tag, int id, const struct ns1__set_USCOREdocument_USCORErevision *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__set_USCOREdocument_USCORErevision), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	if (soap_out_PointerTons1__document_USCORErevision(soap, "note", -1, &a->note, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__set_USCOREdocument_USCORErevision * SOAP_FMAC4 soap_get_ns1__set_USCOREdocument_USCORErevision(struct soap *soap, struct ns1__set_USCOREdocument_USCORErevision *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__set_USCOREdocument_USCORErevision(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__set_USCOREdocument_USCORErevision * SOAP_FMAC4 soap_in_ns1__set_USCOREdocument_USCORErevision(struct soap *soap, const char *tag, struct ns1__set_USCOREdocument_USCORErevision *a, const char *type)
{
	short soap_flag_session = 1, soap_flag_note = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__set_USCOREdocument_USCORErevision *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__set_USCOREdocument_USCORErevision, sizeof(struct ns1__set_USCOREdocument_USCORErevision), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__set_USCOREdocument_USCORErevision(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap_flag_note && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__document_USCORErevision(soap, "note", &a->note, "ns1:document_revision"))
				{	soap_flag_note--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCOREdocument_USCORErevision *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__set_USCOREdocument_USCORErevision, 0, sizeof(struct ns1__set_USCOREdocument_USCORErevision), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__set_USCOREdocument_USCORErevisionResponse(struct soap *soap, struct ns1__set_USCOREdocument_USCORErevisionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__set_USCOREdocument_USCORErevisionResponse(struct soap *soap, const struct ns1__set_USCOREdocument_USCORErevisionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__set_USCOREentry_USCOREresult(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__set_USCOREdocument_USCORErevisionResponse(struct soap *soap, const struct ns1__set_USCOREdocument_USCORErevisionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__set_USCOREdocument_USCORErevisionResponse);
	if (soap_out_ns1__set_USCOREdocument_USCORErevisionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__set_USCOREdocument_USCORErevisionResponse(struct soap *soap, const char *tag, int id, const struct ns1__set_USCOREdocument_USCORErevisionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__set_USCOREdocument_USCORErevisionResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__set_USCOREentry_USCOREresult(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__set_USCOREdocument_USCORErevisionResponse * SOAP_FMAC4 soap_get_ns1__set_USCOREdocument_USCORErevisionResponse(struct soap *soap, struct ns1__set_USCOREdocument_USCORErevisionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__set_USCOREdocument_USCORErevisionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__set_USCOREdocument_USCORErevisionResponse * SOAP_FMAC4 soap_in_ns1__set_USCOREdocument_USCORErevisionResponse(struct soap *soap, const char *tag, struct ns1__set_USCOREdocument_USCORErevisionResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__set_USCOREdocument_USCORErevisionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__set_USCOREdocument_USCORErevisionResponse, sizeof(struct ns1__set_USCOREdocument_USCORErevisionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__set_USCOREdocument_USCORErevisionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__set_USCOREentry_USCOREresult(soap, "return", &a->return_, "ns1:set_entry_result"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCOREdocument_USCORErevisionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__set_USCOREdocument_USCORErevisionResponse, 0, sizeof(struct ns1__set_USCOREdocument_USCORErevisionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__set_USCORErelationships(struct soap *soap, struct ns1__set_USCORErelationships *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
	a->set_USCORErelationship_USCORElist = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__set_USCORErelationships(struct soap *soap, const struct ns1__set_USCORErelationships *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
	soap_serialize_PointerToset_USCORErelationship_USCORElist(soap, &a->set_USCORErelationship_USCORElist);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__set_USCORErelationships(struct soap *soap, const struct ns1__set_USCORErelationships *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__set_USCORErelationships);
	if (soap_out_ns1__set_USCORErelationships(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__set_USCORErelationships(struct soap *soap, const char *tag, int id, const struct ns1__set_USCORErelationships *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__set_USCORErelationships), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	if (soap_out_PointerToset_USCORErelationship_USCORElist(soap, "set_relationship_list", -1, &a->set_USCORErelationship_USCORElist, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__set_USCORErelationships * SOAP_FMAC4 soap_get_ns1__set_USCORErelationships(struct soap *soap, struct ns1__set_USCORErelationships *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__set_USCORErelationships(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__set_USCORErelationships * SOAP_FMAC4 soap_in_ns1__set_USCORErelationships(struct soap *soap, const char *tag, struct ns1__set_USCORErelationships *a, const char *type)
{
	short soap_flag_session = 1, soap_flag_set_USCORErelationship_USCORElist = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__set_USCORErelationships *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__set_USCORErelationships, sizeof(struct ns1__set_USCORErelationships), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__set_USCORErelationships(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap_flag_set_USCORErelationship_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToset_USCORErelationship_USCORElist(soap, "set_relationship_list", &a->set_USCORErelationship_USCORElist, "ns1:set_relationship_value"))
				{	soap_flag_set_USCORErelationship_USCORElist--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCORErelationships *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__set_USCORErelationships, 0, sizeof(struct ns1__set_USCORErelationships), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__set_USCORErelationshipsResponse(struct soap *soap, struct ns1__set_USCORErelationshipsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__set_USCORErelationshipsResponse(struct soap *soap, const struct ns1__set_USCORErelationshipsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__set_USCORErelationship_USCORElist_USCOREresult(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__set_USCORErelationshipsResponse(struct soap *soap, const struct ns1__set_USCORErelationshipsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__set_USCORErelationshipsResponse);
	if (soap_out_ns1__set_USCORErelationshipsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__set_USCORErelationshipsResponse(struct soap *soap, const char *tag, int id, const struct ns1__set_USCORErelationshipsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__set_USCORErelationshipsResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__set_USCORErelationship_USCORElist_USCOREresult(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__set_USCORErelationshipsResponse * SOAP_FMAC4 soap_get_ns1__set_USCORErelationshipsResponse(struct soap *soap, struct ns1__set_USCORErelationshipsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__set_USCORErelationshipsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__set_USCORErelationshipsResponse * SOAP_FMAC4 soap_in_ns1__set_USCORErelationshipsResponse(struct soap *soap, const char *tag, struct ns1__set_USCORErelationshipsResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__set_USCORErelationshipsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__set_USCORErelationshipsResponse, sizeof(struct ns1__set_USCORErelationshipsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__set_USCORErelationshipsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__set_USCORErelationship_USCORElist_USCOREresult(soap, "return", &a->return_, "ns1:set_relationship_list_result"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCORErelationshipsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__set_USCORErelationshipsResponse, 0, sizeof(struct ns1__set_USCORErelationshipsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__set_USCORErelationship(struct soap *soap, struct ns1__set_USCORErelationship *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
	a->set_USCORErelationship_USCOREvalue = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__set_USCORErelationship(struct soap *soap, const struct ns1__set_USCORErelationship *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
	soap_serialize_PointerTons1__set_USCORErelationship_USCOREvalue(soap, &a->set_USCORErelationship_USCOREvalue);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__set_USCORErelationship(struct soap *soap, const struct ns1__set_USCORErelationship *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__set_USCORErelationship);
	if (soap_out_ns1__set_USCORErelationship(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__set_USCORErelationship(struct soap *soap, const char *tag, int id, const struct ns1__set_USCORErelationship *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__set_USCORErelationship), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	if (soap_out_PointerTons1__set_USCORErelationship_USCOREvalue(soap, "set_relationship_value", -1, &a->set_USCORErelationship_USCOREvalue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__set_USCORErelationship * SOAP_FMAC4 soap_get_ns1__set_USCORErelationship(struct soap *soap, struct ns1__set_USCORErelationship *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__set_USCORErelationship(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__set_USCORErelationship * SOAP_FMAC4 soap_in_ns1__set_USCORErelationship(struct soap *soap, const char *tag, struct ns1__set_USCORErelationship *a, const char *type)
{
	short soap_flag_session = 1, soap_flag_set_USCORErelationship_USCOREvalue = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__set_USCORErelationship *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__set_USCORErelationship, sizeof(struct ns1__set_USCORErelationship), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__set_USCORErelationship(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap_flag_set_USCORErelationship_USCOREvalue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__set_USCORErelationship_USCOREvalue(soap, "set_relationship_value", &a->set_USCORErelationship_USCOREvalue, "ns1:set_relationship_value"))
				{	soap_flag_set_USCORErelationship_USCOREvalue--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCORErelationship *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__set_USCORErelationship, 0, sizeof(struct ns1__set_USCORErelationship), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__set_USCORErelationshipResponse(struct soap *soap, struct ns1__set_USCORErelationshipResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__set_USCORErelationshipResponse(struct soap *soap, const struct ns1__set_USCORErelationshipResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__error_USCOREvalue(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__set_USCORErelationshipResponse(struct soap *soap, const struct ns1__set_USCORErelationshipResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__set_USCORErelationshipResponse);
	if (soap_out_ns1__set_USCORErelationshipResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__set_USCORErelationshipResponse(struct soap *soap, const char *tag, int id, const struct ns1__set_USCORErelationshipResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__set_USCORErelationshipResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__error_USCOREvalue(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__set_USCORErelationshipResponse * SOAP_FMAC4 soap_get_ns1__set_USCORErelationshipResponse(struct soap *soap, struct ns1__set_USCORErelationshipResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__set_USCORErelationshipResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__set_USCORErelationshipResponse * SOAP_FMAC4 soap_in_ns1__set_USCORErelationshipResponse(struct soap *soap, const char *tag, struct ns1__set_USCORErelationshipResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__set_USCORErelationshipResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__set_USCORErelationshipResponse, sizeof(struct ns1__set_USCORErelationshipResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__set_USCORErelationshipResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__error_USCOREvalue(soap, "return", &a->return_, "ns1:error_value"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCORErelationshipResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__set_USCORErelationshipResponse, 0, sizeof(struct ns1__set_USCORErelationshipResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCORErelationships(struct soap *soap, struct ns1__get_USCORErelationships *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
	soap_default_string(soap, &a->module_USCOREname);
	soap_default_string(soap, &a->module_USCOREid);
	soap_default_string(soap, &a->related_USCOREmodule);
	soap_default_string(soap, &a->related_USCOREmodule_USCOREquery);
	soap_default_int(soap, &a->deleted);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCORErelationships(struct soap *soap, const struct ns1__get_USCORErelationships *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
	soap_serialize_string(soap, &a->module_USCOREname);
	soap_serialize_string(soap, &a->module_USCOREid);
	soap_serialize_string(soap, &a->related_USCOREmodule);
	soap_serialize_string(soap, &a->related_USCOREmodule_USCOREquery);
	soap_embedded(soap, &a->deleted, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCORErelationships(struct soap *soap, const struct ns1__get_USCORErelationships *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCORErelationships);
	if (soap_out_ns1__get_USCORErelationships(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCORErelationships(struct soap *soap, const char *tag, int id, const struct ns1__get_USCORErelationships *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCORErelationships), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	if (soap_out_string(soap, "module_name", -1, &a->module_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "module_id", -1, &a->module_USCOREid, ""))
		return soap->error;
	if (soap_out_string(soap, "related_module", -1, &a->related_USCOREmodule, ""))
		return soap->error;
	if (soap_out_string(soap, "related_module_query", -1, &a->related_USCOREmodule_USCOREquery, ""))
		return soap->error;
	if (soap_out_int(soap, "deleted", -1, &a->deleted, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCORErelationships * SOAP_FMAC4 soap_get_ns1__get_USCORErelationships(struct soap *soap, struct ns1__get_USCORErelationships *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCORErelationships(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCORErelationships * SOAP_FMAC4 soap_in_ns1__get_USCORErelationships(struct soap *soap, const char *tag, struct ns1__get_USCORErelationships *a, const char *type)
{
	short soap_flag_session = 1, soap_flag_module_USCOREname = 1, soap_flag_module_USCOREid = 1, soap_flag_related_USCOREmodule = 1, soap_flag_related_USCOREmodule_USCOREquery = 1, soap_flag_deleted = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCORErelationships *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCORErelationships, sizeof(struct ns1__get_USCORErelationships), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCORErelationships(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap_flag_module_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module_name", &a->module_USCOREname, "xsd:string"))
				{	soap_flag_module_USCOREname--;
					continue;
				}
			if (soap_flag_module_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module_id", &a->module_USCOREid, "xsd:string"))
				{	soap_flag_module_USCOREid--;
					continue;
				}
			if (soap_flag_related_USCOREmodule && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "related_module", &a->related_USCOREmodule, "xsd:string"))
				{	soap_flag_related_USCOREmodule--;
					continue;
				}
			if (soap_flag_related_USCOREmodule_USCOREquery && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "related_module_query", &a->related_USCOREmodule_USCOREquery, "xsd:string"))
				{	soap_flag_related_USCOREmodule_USCOREquery--;
					continue;
				}
			if (soap_flag_deleted && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "deleted", &a->deleted, "xsd:int"))
				{	soap_flag_deleted--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCORErelationships *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCORErelationships, 0, sizeof(struct ns1__get_USCORErelationships), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_deleted > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCORErelationshipsResponse(struct soap *soap, struct ns1__get_USCORErelationshipsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCORErelationshipsResponse(struct soap *soap, const struct ns1__get_USCORErelationshipsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__get_USCORErelationships_USCOREresult(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCORErelationshipsResponse(struct soap *soap, const struct ns1__get_USCORErelationshipsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCORErelationshipsResponse);
	if (soap_out_ns1__get_USCORErelationshipsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCORErelationshipsResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCORErelationshipsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCORErelationshipsResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__get_USCORErelationships_USCOREresult(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCORErelationshipsResponse * SOAP_FMAC4 soap_get_ns1__get_USCORErelationshipsResponse(struct soap *soap, struct ns1__get_USCORErelationshipsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCORErelationshipsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCORErelationshipsResponse * SOAP_FMAC4 soap_in_ns1__get_USCORErelationshipsResponse(struct soap *soap, const char *tag, struct ns1__get_USCORErelationshipsResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCORErelationshipsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCORErelationshipsResponse, sizeof(struct ns1__get_USCORErelationshipsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCORErelationshipsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__get_USCORErelationships_USCOREresult(soap, "return", &a->return_, "ns1:get_relationships_result"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCORErelationshipsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCORErelationshipsResponse, 0, sizeof(struct ns1__get_USCORErelationshipsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREserver_USCOREversion(struct soap *soap, struct ns1__get_USCOREserver_USCOREversion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREserver_USCOREversion(struct soap *soap, const struct ns1__get_USCOREserver_USCOREversion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREserver_USCOREversion(struct soap *soap, const struct ns1__get_USCOREserver_USCOREversion *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREserver_USCOREversion);
	if (soap_out_ns1__get_USCOREserver_USCOREversion(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREserver_USCOREversion(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREserver_USCOREversion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREserver_USCOREversion), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREserver_USCOREversion * SOAP_FMAC4 soap_get_ns1__get_USCOREserver_USCOREversion(struct soap *soap, struct ns1__get_USCOREserver_USCOREversion *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREserver_USCOREversion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREserver_USCOREversion * SOAP_FMAC4 soap_in_ns1__get_USCOREserver_USCOREversion(struct soap *soap, const char *tag, struct ns1__get_USCOREserver_USCOREversion *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREserver_USCOREversion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREserver_USCOREversion, sizeof(struct ns1__get_USCOREserver_USCOREversion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREserver_USCOREversion(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREserver_USCOREversion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREserver_USCOREversion, 0, sizeof(struct ns1__get_USCOREserver_USCOREversion), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREserver_USCOREversionResponse(struct soap *soap, struct ns1__get_USCOREserver_USCOREversionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREserver_USCOREversionResponse(struct soap *soap, const struct ns1__get_USCOREserver_USCOREversionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREserver_USCOREversionResponse(struct soap *soap, const struct ns1__get_USCOREserver_USCOREversionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREserver_USCOREversionResponse);
	if (soap_out_ns1__get_USCOREserver_USCOREversionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREserver_USCOREversionResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREserver_USCOREversionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREserver_USCOREversionResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREserver_USCOREversionResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREserver_USCOREversionResponse(struct soap *soap, struct ns1__get_USCOREserver_USCOREversionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREserver_USCOREversionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREserver_USCOREversionResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREserver_USCOREversionResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREserver_USCOREversionResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREserver_USCOREversionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREserver_USCOREversionResponse, sizeof(struct ns1__get_USCOREserver_USCOREversionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREserver_USCOREversionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREserver_USCOREversionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREserver_USCOREversionResponse, 0, sizeof(struct ns1__get_USCOREserver_USCOREversionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREsugar_USCOREflavor(struct soap *soap, struct ns1__get_USCOREsugar_USCOREflavor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREsugar_USCOREflavor(struct soap *soap, const struct ns1__get_USCOREsugar_USCOREflavor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREsugar_USCOREflavor(struct soap *soap, const struct ns1__get_USCOREsugar_USCOREflavor *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREsugar_USCOREflavor);
	if (soap_out_ns1__get_USCOREsugar_USCOREflavor(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREsugar_USCOREflavor(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREsugar_USCOREflavor *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREsugar_USCOREflavor), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREsugar_USCOREflavor * SOAP_FMAC4 soap_get_ns1__get_USCOREsugar_USCOREflavor(struct soap *soap, struct ns1__get_USCOREsugar_USCOREflavor *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREsugar_USCOREflavor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREsugar_USCOREflavor * SOAP_FMAC4 soap_in_ns1__get_USCOREsugar_USCOREflavor(struct soap *soap, const char *tag, struct ns1__get_USCOREsugar_USCOREflavor *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREsugar_USCOREflavor *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREsugar_USCOREflavor, sizeof(struct ns1__get_USCOREsugar_USCOREflavor), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREsugar_USCOREflavor(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREsugar_USCOREflavor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREsugar_USCOREflavor, 0, sizeof(struct ns1__get_USCOREsugar_USCOREflavor), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREsugar_USCOREflavorResponse(struct soap *soap, struct ns1__get_USCOREsugar_USCOREflavorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREsugar_USCOREflavorResponse(struct soap *soap, const struct ns1__get_USCOREsugar_USCOREflavorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREsugar_USCOREflavorResponse(struct soap *soap, const struct ns1__get_USCOREsugar_USCOREflavorResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREsugar_USCOREflavorResponse);
	if (soap_out_ns1__get_USCOREsugar_USCOREflavorResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREsugar_USCOREflavorResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREsugar_USCOREflavorResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREsugar_USCOREflavorResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREsugar_USCOREflavorResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREsugar_USCOREflavorResponse(struct soap *soap, struct ns1__get_USCOREsugar_USCOREflavorResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREsugar_USCOREflavorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREsugar_USCOREflavorResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREsugar_USCOREflavorResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREsugar_USCOREflavorResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREsugar_USCOREflavorResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREsugar_USCOREflavorResponse, sizeof(struct ns1__get_USCOREsugar_USCOREflavorResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREsugar_USCOREflavorResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREsugar_USCOREflavorResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREsugar_USCOREflavorResponse, 0, sizeof(struct ns1__get_USCOREsugar_USCOREflavorResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREgmt_USCOREtime(struct soap *soap, struct ns1__get_USCOREgmt_USCOREtime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREgmt_USCOREtime(struct soap *soap, const struct ns1__get_USCOREgmt_USCOREtime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREgmt_USCOREtime(struct soap *soap, const struct ns1__get_USCOREgmt_USCOREtime *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREgmt_USCOREtime);
	if (soap_out_ns1__get_USCOREgmt_USCOREtime(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREgmt_USCOREtime(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREgmt_USCOREtime *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREgmt_USCOREtime), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREgmt_USCOREtime * SOAP_FMAC4 soap_get_ns1__get_USCOREgmt_USCOREtime(struct soap *soap, struct ns1__get_USCOREgmt_USCOREtime *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREgmt_USCOREtime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREgmt_USCOREtime * SOAP_FMAC4 soap_in_ns1__get_USCOREgmt_USCOREtime(struct soap *soap, const char *tag, struct ns1__get_USCOREgmt_USCOREtime *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREgmt_USCOREtime *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREgmt_USCOREtime, sizeof(struct ns1__get_USCOREgmt_USCOREtime), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREgmt_USCOREtime(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREgmt_USCOREtime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREgmt_USCOREtime, 0, sizeof(struct ns1__get_USCOREgmt_USCOREtime), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREgmt_USCOREtimeResponse(struct soap *soap, struct ns1__get_USCOREgmt_USCOREtimeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREgmt_USCOREtimeResponse(struct soap *soap, const struct ns1__get_USCOREgmt_USCOREtimeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREgmt_USCOREtimeResponse(struct soap *soap, const struct ns1__get_USCOREgmt_USCOREtimeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREgmt_USCOREtimeResponse);
	if (soap_out_ns1__get_USCOREgmt_USCOREtimeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREgmt_USCOREtimeResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREgmt_USCOREtimeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREgmt_USCOREtimeResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREgmt_USCOREtimeResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREgmt_USCOREtimeResponse(struct soap *soap, struct ns1__get_USCOREgmt_USCOREtimeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREgmt_USCOREtimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREgmt_USCOREtimeResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREgmt_USCOREtimeResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREgmt_USCOREtimeResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREgmt_USCOREtimeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREgmt_USCOREtimeResponse, sizeof(struct ns1__get_USCOREgmt_USCOREtimeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREgmt_USCOREtimeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREgmt_USCOREtimeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREgmt_USCOREtimeResponse, 0, sizeof(struct ns1__get_USCOREgmt_USCOREtimeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREserver_USCOREtime(struct soap *soap, struct ns1__get_USCOREserver_USCOREtime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREserver_USCOREtime(struct soap *soap, const struct ns1__get_USCOREserver_USCOREtime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREserver_USCOREtime(struct soap *soap, const struct ns1__get_USCOREserver_USCOREtime *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREserver_USCOREtime);
	if (soap_out_ns1__get_USCOREserver_USCOREtime(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREserver_USCOREtime(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREserver_USCOREtime *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREserver_USCOREtime), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREserver_USCOREtime * SOAP_FMAC4 soap_get_ns1__get_USCOREserver_USCOREtime(struct soap *soap, struct ns1__get_USCOREserver_USCOREtime *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREserver_USCOREtime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREserver_USCOREtime * SOAP_FMAC4 soap_in_ns1__get_USCOREserver_USCOREtime(struct soap *soap, const char *tag, struct ns1__get_USCOREserver_USCOREtime *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREserver_USCOREtime *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREserver_USCOREtime, sizeof(struct ns1__get_USCOREserver_USCOREtime), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREserver_USCOREtime(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREserver_USCOREtime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREserver_USCOREtime, 0, sizeof(struct ns1__get_USCOREserver_USCOREtime), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREserver_USCOREtimeResponse(struct soap *soap, struct ns1__get_USCOREserver_USCOREtimeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREserver_USCOREtimeResponse(struct soap *soap, const struct ns1__get_USCOREserver_USCOREtimeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREserver_USCOREtimeResponse(struct soap *soap, const struct ns1__get_USCOREserver_USCOREtimeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREserver_USCOREtimeResponse);
	if (soap_out_ns1__get_USCOREserver_USCOREtimeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREserver_USCOREtimeResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREserver_USCOREtimeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREserver_USCOREtimeResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREserver_USCOREtimeResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREserver_USCOREtimeResponse(struct soap *soap, struct ns1__get_USCOREserver_USCOREtimeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREserver_USCOREtimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREserver_USCOREtimeResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREserver_USCOREtimeResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREserver_USCOREtimeResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREserver_USCOREtimeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREserver_USCOREtimeResponse, sizeof(struct ns1__get_USCOREserver_USCOREtimeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREserver_USCOREtimeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREserver_USCOREtimeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREserver_USCOREtimeResponse, 0, sizeof(struct ns1__get_USCOREserver_USCOREtimeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREuser_USCOREteam_USCOREid(struct soap *soap, struct ns1__get_USCOREuser_USCOREteam_USCOREid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREuser_USCOREteam_USCOREid(struct soap *soap, const struct ns1__get_USCOREuser_USCOREteam_USCOREid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREuser_USCOREteam_USCOREid(struct soap *soap, const struct ns1__get_USCOREuser_USCOREteam_USCOREid *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREuser_USCOREteam_USCOREid);
	if (soap_out_ns1__get_USCOREuser_USCOREteam_USCOREid(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREuser_USCOREteam_USCOREid(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREuser_USCOREteam_USCOREid *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREuser_USCOREteam_USCOREid), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREuser_USCOREteam_USCOREid * SOAP_FMAC4 soap_get_ns1__get_USCOREuser_USCOREteam_USCOREid(struct soap *soap, struct ns1__get_USCOREuser_USCOREteam_USCOREid *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREuser_USCOREteam_USCOREid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREuser_USCOREteam_USCOREid * SOAP_FMAC4 soap_in_ns1__get_USCOREuser_USCOREteam_USCOREid(struct soap *soap, const char *tag, struct ns1__get_USCOREuser_USCOREteam_USCOREid *a, const char *type)
{
	short soap_flag_session = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREuser_USCOREteam_USCOREid *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREuser_USCOREteam_USCOREid, sizeof(struct ns1__get_USCOREuser_USCOREteam_USCOREid), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREuser_USCOREteam_USCOREid(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREuser_USCOREteam_USCOREid *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREuser_USCOREteam_USCOREid, 0, sizeof(struct ns1__get_USCOREuser_USCOREteam_USCOREid), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREuser_USCOREteam_USCOREidResponse(struct soap *soap, struct ns1__get_USCOREuser_USCOREteam_USCOREidResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREuser_USCOREteam_USCOREidResponse(struct soap *soap, const struct ns1__get_USCOREuser_USCOREteam_USCOREidResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREuser_USCOREteam_USCOREidResponse(struct soap *soap, const struct ns1__get_USCOREuser_USCOREteam_USCOREidResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREuser_USCOREteam_USCOREidResponse);
	if (soap_out_ns1__get_USCOREuser_USCOREteam_USCOREidResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREuser_USCOREteam_USCOREidResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREuser_USCOREteam_USCOREidResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREuser_USCOREteam_USCOREidResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREuser_USCOREteam_USCOREidResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREuser_USCOREteam_USCOREidResponse(struct soap *soap, struct ns1__get_USCOREuser_USCOREteam_USCOREidResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREuser_USCOREteam_USCOREidResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREuser_USCOREteam_USCOREidResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREuser_USCOREteam_USCOREidResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREuser_USCOREteam_USCOREidResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREuser_USCOREteam_USCOREidResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREuser_USCOREteam_USCOREidResponse, sizeof(struct ns1__get_USCOREuser_USCOREteam_USCOREidResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREuser_USCOREteam_USCOREidResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREuser_USCOREteam_USCOREidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREuser_USCOREteam_USCOREidResponse, 0, sizeof(struct ns1__get_USCOREuser_USCOREteam_USCOREidResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREuser_USCOREid(struct soap *soap, struct ns1__get_USCOREuser_USCOREid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREuser_USCOREid(struct soap *soap, const struct ns1__get_USCOREuser_USCOREid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREuser_USCOREid(struct soap *soap, const struct ns1__get_USCOREuser_USCOREid *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREuser_USCOREid);
	if (soap_out_ns1__get_USCOREuser_USCOREid(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREuser_USCOREid(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREuser_USCOREid *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREuser_USCOREid), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREuser_USCOREid * SOAP_FMAC4 soap_get_ns1__get_USCOREuser_USCOREid(struct soap *soap, struct ns1__get_USCOREuser_USCOREid *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREuser_USCOREid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREuser_USCOREid * SOAP_FMAC4 soap_in_ns1__get_USCOREuser_USCOREid(struct soap *soap, const char *tag, struct ns1__get_USCOREuser_USCOREid *a, const char *type)
{
	short soap_flag_session = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREuser_USCOREid *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREuser_USCOREid, sizeof(struct ns1__get_USCOREuser_USCOREid), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREuser_USCOREid(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREuser_USCOREid *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREuser_USCOREid, 0, sizeof(struct ns1__get_USCOREuser_USCOREid), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREuser_USCOREidResponse(struct soap *soap, struct ns1__get_USCOREuser_USCOREidResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREuser_USCOREidResponse(struct soap *soap, const struct ns1__get_USCOREuser_USCOREidResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREuser_USCOREidResponse(struct soap *soap, const struct ns1__get_USCOREuser_USCOREidResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREuser_USCOREidResponse);
	if (soap_out_ns1__get_USCOREuser_USCOREidResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREuser_USCOREidResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREuser_USCOREidResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREuser_USCOREidResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREuser_USCOREidResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREuser_USCOREidResponse(struct soap *soap, struct ns1__get_USCOREuser_USCOREidResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREuser_USCOREidResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREuser_USCOREidResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREuser_USCOREidResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREuser_USCOREidResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREuser_USCOREidResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREuser_USCOREidResponse, sizeof(struct ns1__get_USCOREuser_USCOREidResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREuser_USCOREidResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREuser_USCOREidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREuser_USCOREidResponse, 0, sizeof(struct ns1__get_USCOREuser_USCOREidResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__update_USCOREportal_USCOREuser(struct soap *soap, struct ns1__update_USCOREportal_USCOREuser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
	soap_default_string(soap, &a->portal_USCOREname);
	a->name_USCOREvalue_USCORElist = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__update_USCOREportal_USCOREuser(struct soap *soap, const struct ns1__update_USCOREportal_USCOREuser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
	soap_serialize_string(soap, &a->portal_USCOREname);
	soap_serialize_PointerToname_USCOREvalue_USCORElist(soap, &a->name_USCOREvalue_USCORElist);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__update_USCOREportal_USCOREuser(struct soap *soap, const struct ns1__update_USCOREportal_USCOREuser *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__update_USCOREportal_USCOREuser);
	if (soap_out_ns1__update_USCOREportal_USCOREuser(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__update_USCOREportal_USCOREuser(struct soap *soap, const char *tag, int id, const struct ns1__update_USCOREportal_USCOREuser *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__update_USCOREportal_USCOREuser), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	if (soap_out_string(soap, "portal_name", -1, &a->portal_USCOREname, ""))
		return soap->error;
	if (soap_out_PointerToname_USCOREvalue_USCORElist(soap, "name_value_list", -1, &a->name_USCOREvalue_USCORElist, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__update_USCOREportal_USCOREuser * SOAP_FMAC4 soap_get_ns1__update_USCOREportal_USCOREuser(struct soap *soap, struct ns1__update_USCOREportal_USCOREuser *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__update_USCOREportal_USCOREuser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__update_USCOREportal_USCOREuser * SOAP_FMAC4 soap_in_ns1__update_USCOREportal_USCOREuser(struct soap *soap, const char *tag, struct ns1__update_USCOREportal_USCOREuser *a, const char *type)
{
	short soap_flag_session = 1, soap_flag_portal_USCOREname = 1, soap_flag_name_USCOREvalue_USCORElist = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__update_USCOREportal_USCOREuser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__update_USCOREportal_USCOREuser, sizeof(struct ns1__update_USCOREportal_USCOREuser), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__update_USCOREportal_USCOREuser(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap_flag_portal_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "portal_name", &a->portal_USCOREname, "xsd:string"))
				{	soap_flag_portal_USCOREname--;
					continue;
				}
			if (soap_flag_name_USCOREvalue_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToname_USCOREvalue_USCORElist(soap, "name_value_list", &a->name_USCOREvalue_USCORElist, "ns1:name_value"))
				{	soap_flag_name_USCOREvalue_USCORElist--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__update_USCOREportal_USCOREuser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__update_USCOREportal_USCOREuser, 0, sizeof(struct ns1__update_USCOREportal_USCOREuser), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__update_USCOREportal_USCOREuserResponse(struct soap *soap, struct ns1__update_USCOREportal_USCOREuserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__update_USCOREportal_USCOREuserResponse(struct soap *soap, const struct ns1__update_USCOREportal_USCOREuserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__error_USCOREvalue(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__update_USCOREportal_USCOREuserResponse(struct soap *soap, const struct ns1__update_USCOREportal_USCOREuserResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__update_USCOREportal_USCOREuserResponse);
	if (soap_out_ns1__update_USCOREportal_USCOREuserResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__update_USCOREportal_USCOREuserResponse(struct soap *soap, const char *tag, int id, const struct ns1__update_USCOREportal_USCOREuserResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__update_USCOREportal_USCOREuserResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__error_USCOREvalue(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__update_USCOREportal_USCOREuserResponse * SOAP_FMAC4 soap_get_ns1__update_USCOREportal_USCOREuserResponse(struct soap *soap, struct ns1__update_USCOREportal_USCOREuserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__update_USCOREportal_USCOREuserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__update_USCOREportal_USCOREuserResponse * SOAP_FMAC4 soap_in_ns1__update_USCOREportal_USCOREuserResponse(struct soap *soap, const char *tag, struct ns1__update_USCOREportal_USCOREuserResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__update_USCOREportal_USCOREuserResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__update_USCOREportal_USCOREuserResponse, sizeof(struct ns1__update_USCOREportal_USCOREuserResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__update_USCOREportal_USCOREuserResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__error_USCOREvalue(soap, "return", &a->return_, "ns1:error_value"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__update_USCOREportal_USCOREuserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__update_USCOREportal_USCOREuserResponse, 0, sizeof(struct ns1__update_USCOREportal_USCOREuserResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREavailable_USCOREmodules(struct soap *soap, struct ns1__get_USCOREavailable_USCOREmodules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREavailable_USCOREmodules(struct soap *soap, const struct ns1__get_USCOREavailable_USCOREmodules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREavailable_USCOREmodules(struct soap *soap, const struct ns1__get_USCOREavailable_USCOREmodules *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREavailable_USCOREmodules);
	if (soap_out_ns1__get_USCOREavailable_USCOREmodules(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREavailable_USCOREmodules(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREavailable_USCOREmodules *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREavailable_USCOREmodules), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREavailable_USCOREmodules * SOAP_FMAC4 soap_get_ns1__get_USCOREavailable_USCOREmodules(struct soap *soap, struct ns1__get_USCOREavailable_USCOREmodules *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREavailable_USCOREmodules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREavailable_USCOREmodules * SOAP_FMAC4 soap_in_ns1__get_USCOREavailable_USCOREmodules(struct soap *soap, const char *tag, struct ns1__get_USCOREavailable_USCOREmodules *a, const char *type)
{
	short soap_flag_session = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREavailable_USCOREmodules *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREavailable_USCOREmodules, sizeof(struct ns1__get_USCOREavailable_USCOREmodules), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREavailable_USCOREmodules(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREavailable_USCOREmodules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREavailable_USCOREmodules, 0, sizeof(struct ns1__get_USCOREavailable_USCOREmodules), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREavailable_USCOREmodulesResponse(struct soap *soap, struct ns1__get_USCOREavailable_USCOREmodulesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREavailable_USCOREmodulesResponse(struct soap *soap, const struct ns1__get_USCOREavailable_USCOREmodulesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__module_USCORElist(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREavailable_USCOREmodulesResponse(struct soap *soap, const struct ns1__get_USCOREavailable_USCOREmodulesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREavailable_USCOREmodulesResponse);
	if (soap_out_ns1__get_USCOREavailable_USCOREmodulesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREavailable_USCOREmodulesResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREavailable_USCOREmodulesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREavailable_USCOREmodulesResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__module_USCORElist(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREavailable_USCOREmodulesResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREavailable_USCOREmodulesResponse(struct soap *soap, struct ns1__get_USCOREavailable_USCOREmodulesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREavailable_USCOREmodulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREavailable_USCOREmodulesResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREavailable_USCOREmodulesResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREavailable_USCOREmodulesResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREavailable_USCOREmodulesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREavailable_USCOREmodulesResponse, sizeof(struct ns1__get_USCOREavailable_USCOREmodulesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREavailable_USCOREmodulesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__module_USCORElist(soap, "return", &a->return_, "ns1:module_list"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREavailable_USCOREmodulesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREavailable_USCOREmodulesResponse, 0, sizeof(struct ns1__get_USCOREavailable_USCOREmodulesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREmodule_USCOREfields(struct soap *soap, struct ns1__get_USCOREmodule_USCOREfields *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
	soap_default_string(soap, &a->module_USCOREname);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREmodule_USCOREfields(struct soap *soap, const struct ns1__get_USCOREmodule_USCOREfields *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
	soap_serialize_string(soap, &a->module_USCOREname);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREmodule_USCOREfields(struct soap *soap, const struct ns1__get_USCOREmodule_USCOREfields *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREmodule_USCOREfields);
	if (soap_out_ns1__get_USCOREmodule_USCOREfields(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREmodule_USCOREfields(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREmodule_USCOREfields *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREmodule_USCOREfields), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	if (soap_out_string(soap, "module_name", -1, &a->module_USCOREname, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREmodule_USCOREfields * SOAP_FMAC4 soap_get_ns1__get_USCOREmodule_USCOREfields(struct soap *soap, struct ns1__get_USCOREmodule_USCOREfields *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREmodule_USCOREfields(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREmodule_USCOREfields * SOAP_FMAC4 soap_in_ns1__get_USCOREmodule_USCOREfields(struct soap *soap, const char *tag, struct ns1__get_USCOREmodule_USCOREfields *a, const char *type)
{
	short soap_flag_session = 1, soap_flag_module_USCOREname = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREmodule_USCOREfields *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREmodule_USCOREfields, sizeof(struct ns1__get_USCOREmodule_USCOREfields), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREmodule_USCOREfields(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap_flag_module_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module_name", &a->module_USCOREname, "xsd:string"))
				{	soap_flag_module_USCOREname--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREmodule_USCOREfields *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREmodule_USCOREfields, 0, sizeof(struct ns1__get_USCOREmodule_USCOREfields), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREmodule_USCOREfieldsResponse(struct soap *soap, struct ns1__get_USCOREmodule_USCOREfieldsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREmodule_USCOREfieldsResponse(struct soap *soap, const struct ns1__get_USCOREmodule_USCOREfieldsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__module_USCOREfields(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREmodule_USCOREfieldsResponse(struct soap *soap, const struct ns1__get_USCOREmodule_USCOREfieldsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREmodule_USCOREfieldsResponse);
	if (soap_out_ns1__get_USCOREmodule_USCOREfieldsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREmodule_USCOREfieldsResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREmodule_USCOREfieldsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREmodule_USCOREfieldsResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__module_USCOREfields(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREmodule_USCOREfieldsResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREmodule_USCOREfieldsResponse(struct soap *soap, struct ns1__get_USCOREmodule_USCOREfieldsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREmodule_USCOREfieldsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREmodule_USCOREfieldsResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREmodule_USCOREfieldsResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREmodule_USCOREfieldsResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREmodule_USCOREfieldsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREmodule_USCOREfieldsResponse, sizeof(struct ns1__get_USCOREmodule_USCOREfieldsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREmodule_USCOREfieldsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__module_USCOREfields(soap, "return", &a->return_, "ns1:module_fields"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREmodule_USCOREfieldsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREmodule_USCOREfieldsResponse, 0, sizeof(struct ns1__get_USCOREmodule_USCOREfieldsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__logout(struct soap *soap, struct ns1__logout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__logout(struct soap *soap, const struct ns1__logout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__logout(struct soap *soap, const struct ns1__logout *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__logout);
	if (soap_out_ns1__logout(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__logout(struct soap *soap, const char *tag, int id, const struct ns1__logout *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__logout), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__logout * SOAP_FMAC4 soap_get_ns1__logout(struct soap *soap, struct ns1__logout *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__logout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__logout * SOAP_FMAC4 soap_in_ns1__logout(struct soap *soap, const char *tag, struct ns1__logout *a, const char *type)
{
	short soap_flag_session = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__logout *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__logout, sizeof(struct ns1__logout), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__logout(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__logout *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__logout, 0, sizeof(struct ns1__logout), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__logoutResponse(struct soap *soap, struct ns1__logoutResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__logoutResponse(struct soap *soap, const struct ns1__logoutResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__error_USCOREvalue(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__logoutResponse(struct soap *soap, const struct ns1__logoutResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__logoutResponse);
	if (soap_out_ns1__logoutResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__logoutResponse(struct soap *soap, const char *tag, int id, const struct ns1__logoutResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__logoutResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__error_USCOREvalue(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__logoutResponse * SOAP_FMAC4 soap_get_ns1__logoutResponse(struct soap *soap, struct ns1__logoutResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__logoutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__logoutResponse * SOAP_FMAC4 soap_in_ns1__logoutResponse(struct soap *soap, const char *tag, struct ns1__logoutResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__logoutResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__logoutResponse, sizeof(struct ns1__logoutResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__logoutResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__error_USCOREvalue(soap, "return", &a->return_, "ns1:error_value"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__logoutResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__logoutResponse, 0, sizeof(struct ns1__logoutResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCORErelated_USCOREnotes(struct soap *soap, struct ns1__get_USCORErelated_USCOREnotes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
	soap_default_string(soap, &a->module_USCOREname);
	soap_default_string(soap, &a->module_USCOREid);
	a->select_USCOREfields = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCORErelated_USCOREnotes(struct soap *soap, const struct ns1__get_USCORErelated_USCOREnotes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
	soap_serialize_string(soap, &a->module_USCOREname);
	soap_serialize_string(soap, &a->module_USCOREid);
	soap_serialize_PointerToselect_USCOREfields(soap, &a->select_USCOREfields);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCORErelated_USCOREnotes(struct soap *soap, const struct ns1__get_USCORErelated_USCOREnotes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCORErelated_USCOREnotes);
	if (soap_out_ns1__get_USCORErelated_USCOREnotes(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCORErelated_USCOREnotes(struct soap *soap, const char *tag, int id, const struct ns1__get_USCORErelated_USCOREnotes *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCORErelated_USCOREnotes), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	if (soap_out_string(soap, "module_name", -1, &a->module_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "module_id", -1, &a->module_USCOREid, ""))
		return soap->error;
	if (soap_out_PointerToselect_USCOREfields(soap, "select_fields", -1, &a->select_USCOREfields, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCORErelated_USCOREnotes * SOAP_FMAC4 soap_get_ns1__get_USCORErelated_USCOREnotes(struct soap *soap, struct ns1__get_USCORErelated_USCOREnotes *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCORErelated_USCOREnotes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCORErelated_USCOREnotes * SOAP_FMAC4 soap_in_ns1__get_USCORErelated_USCOREnotes(struct soap *soap, const char *tag, struct ns1__get_USCORErelated_USCOREnotes *a, const char *type)
{
	short soap_flag_session = 1, soap_flag_module_USCOREname = 1, soap_flag_module_USCOREid = 1, soap_flag_select_USCOREfields = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCORErelated_USCOREnotes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCORErelated_USCOREnotes, sizeof(struct ns1__get_USCORErelated_USCOREnotes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCORErelated_USCOREnotes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap_flag_module_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module_name", &a->module_USCOREname, "xsd:string"))
				{	soap_flag_module_USCOREname--;
					continue;
				}
			if (soap_flag_module_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module_id", &a->module_USCOREid, "xsd:string"))
				{	soap_flag_module_USCOREid--;
					continue;
				}
			if (soap_flag_select_USCOREfields && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToselect_USCOREfields(soap, "select_fields", &a->select_USCOREfields, "xsd:string"))
				{	soap_flag_select_USCOREfields--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCORErelated_USCOREnotes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCORErelated_USCOREnotes, 0, sizeof(struct ns1__get_USCORErelated_USCOREnotes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCORErelated_USCOREnotesResponse(struct soap *soap, struct ns1__get_USCORErelated_USCOREnotesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCORErelated_USCOREnotesResponse(struct soap *soap, const struct ns1__get_USCORErelated_USCOREnotesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__get_USCOREentry_USCOREresult(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCORErelated_USCOREnotesResponse(struct soap *soap, const struct ns1__get_USCORErelated_USCOREnotesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCORErelated_USCOREnotesResponse);
	if (soap_out_ns1__get_USCORErelated_USCOREnotesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCORErelated_USCOREnotesResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCORErelated_USCOREnotesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCORErelated_USCOREnotesResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__get_USCOREentry_USCOREresult(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCORErelated_USCOREnotesResponse * SOAP_FMAC4 soap_get_ns1__get_USCORErelated_USCOREnotesResponse(struct soap *soap, struct ns1__get_USCORErelated_USCOREnotesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCORErelated_USCOREnotesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCORErelated_USCOREnotesResponse * SOAP_FMAC4 soap_in_ns1__get_USCORErelated_USCOREnotesResponse(struct soap *soap, const char *tag, struct ns1__get_USCORErelated_USCOREnotesResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCORErelated_USCOREnotesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCORErelated_USCOREnotesResponse, sizeof(struct ns1__get_USCORErelated_USCOREnotesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCORErelated_USCOREnotesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__get_USCOREentry_USCOREresult(soap, "return", &a->return_, "ns1:get_entry_result"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCORErelated_USCOREnotesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCORErelated_USCOREnotesResponse, 0, sizeof(struct ns1__get_USCORErelated_USCOREnotesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__relate_USCOREnote_USCOREto_USCOREmodule(struct soap *soap, struct ns1__relate_USCOREnote_USCOREto_USCOREmodule *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
	soap_default_string(soap, &a->note_USCOREid);
	soap_default_string(soap, &a->module_USCOREname);
	soap_default_string(soap, &a->module_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__relate_USCOREnote_USCOREto_USCOREmodule(struct soap *soap, const struct ns1__relate_USCOREnote_USCOREto_USCOREmodule *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
	soap_serialize_string(soap, &a->note_USCOREid);
	soap_serialize_string(soap, &a->module_USCOREname);
	soap_serialize_string(soap, &a->module_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__relate_USCOREnote_USCOREto_USCOREmodule(struct soap *soap, const struct ns1__relate_USCOREnote_USCOREto_USCOREmodule *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__relate_USCOREnote_USCOREto_USCOREmodule);
	if (soap_out_ns1__relate_USCOREnote_USCOREto_USCOREmodule(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__relate_USCOREnote_USCOREto_USCOREmodule(struct soap *soap, const char *tag, int id, const struct ns1__relate_USCOREnote_USCOREto_USCOREmodule *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__relate_USCOREnote_USCOREto_USCOREmodule), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	if (soap_out_string(soap, "note_id", -1, &a->note_USCOREid, ""))
		return soap->error;
	if (soap_out_string(soap, "module_name", -1, &a->module_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "module_id", -1, &a->module_USCOREid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__relate_USCOREnote_USCOREto_USCOREmodule * SOAP_FMAC4 soap_get_ns1__relate_USCOREnote_USCOREto_USCOREmodule(struct soap *soap, struct ns1__relate_USCOREnote_USCOREto_USCOREmodule *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__relate_USCOREnote_USCOREto_USCOREmodule(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__relate_USCOREnote_USCOREto_USCOREmodule * SOAP_FMAC4 soap_in_ns1__relate_USCOREnote_USCOREto_USCOREmodule(struct soap *soap, const char *tag, struct ns1__relate_USCOREnote_USCOREto_USCOREmodule *a, const char *type)
{
	short soap_flag_session = 1, soap_flag_note_USCOREid = 1, soap_flag_module_USCOREname = 1, soap_flag_module_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__relate_USCOREnote_USCOREto_USCOREmodule *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__relate_USCOREnote_USCOREto_USCOREmodule, sizeof(struct ns1__relate_USCOREnote_USCOREto_USCOREmodule), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__relate_USCOREnote_USCOREto_USCOREmodule(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap_flag_note_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "note_id", &a->note_USCOREid, "xsd:string"))
				{	soap_flag_note_USCOREid--;
					continue;
				}
			if (soap_flag_module_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module_name", &a->module_USCOREname, "xsd:string"))
				{	soap_flag_module_USCOREname--;
					continue;
				}
			if (soap_flag_module_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module_id", &a->module_USCOREid, "xsd:string"))
				{	soap_flag_module_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__relate_USCOREnote_USCOREto_USCOREmodule *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__relate_USCOREnote_USCOREto_USCOREmodule, 0, sizeof(struct ns1__relate_USCOREnote_USCOREto_USCOREmodule), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse(struct soap *soap, struct ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse(struct soap *soap, const struct ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__error_USCOREvalue(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse(struct soap *soap, const struct ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse);
	if (soap_out_ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse(struct soap *soap, const char *tag, int id, const struct ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__error_USCOREvalue(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse * SOAP_FMAC4 soap_get_ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse(struct soap *soap, struct ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse * SOAP_FMAC4 soap_in_ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse(struct soap *soap, const char *tag, struct ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse, sizeof(struct ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__error_USCOREvalue(soap, "return", &a->return_, "ns1:error_value"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse, 0, sizeof(struct ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREnote_USCOREattachment(struct soap *soap, struct ns1__get_USCOREnote_USCOREattachment *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
	soap_default_string(soap, &a->id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREnote_USCOREattachment(struct soap *soap, const struct ns1__get_USCOREnote_USCOREattachment *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
	soap_serialize_string(soap, &a->id);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREnote_USCOREattachment(struct soap *soap, const struct ns1__get_USCOREnote_USCOREattachment *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREnote_USCOREattachment);
	if (soap_out_ns1__get_USCOREnote_USCOREattachment(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREnote_USCOREattachment(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREnote_USCOREattachment *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREnote_USCOREattachment), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	if (soap_out_string(soap, "id", -1, &a->id, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREnote_USCOREattachment * SOAP_FMAC4 soap_get_ns1__get_USCOREnote_USCOREattachment(struct soap *soap, struct ns1__get_USCOREnote_USCOREattachment *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREnote_USCOREattachment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREnote_USCOREattachment * SOAP_FMAC4 soap_in_ns1__get_USCOREnote_USCOREattachment(struct soap *soap, const char *tag, struct ns1__get_USCOREnote_USCOREattachment *a, const char *type)
{
	short soap_flag_session = 1, soap_flag_id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREnote_USCOREattachment *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREnote_USCOREattachment, sizeof(struct ns1__get_USCOREnote_USCOREattachment), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREnote_USCOREattachment(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREnote_USCOREattachment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREnote_USCOREattachment, 0, sizeof(struct ns1__get_USCOREnote_USCOREattachment), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREnote_USCOREattachmentResponse(struct soap *soap, struct ns1__get_USCOREnote_USCOREattachmentResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREnote_USCOREattachmentResponse(struct soap *soap, const struct ns1__get_USCOREnote_USCOREattachmentResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__return_USCOREnote_USCOREattachment(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREnote_USCOREattachmentResponse(struct soap *soap, const struct ns1__get_USCOREnote_USCOREattachmentResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREnote_USCOREattachmentResponse);
	if (soap_out_ns1__get_USCOREnote_USCOREattachmentResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREnote_USCOREattachmentResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREnote_USCOREattachmentResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREnote_USCOREattachmentResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__return_USCOREnote_USCOREattachment(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREnote_USCOREattachmentResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREnote_USCOREattachmentResponse(struct soap *soap, struct ns1__get_USCOREnote_USCOREattachmentResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREnote_USCOREattachmentResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREnote_USCOREattachmentResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREnote_USCOREattachmentResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREnote_USCOREattachmentResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREnote_USCOREattachmentResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREnote_USCOREattachmentResponse, sizeof(struct ns1__get_USCOREnote_USCOREattachmentResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREnote_USCOREattachmentResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__return_USCOREnote_USCOREattachment(soap, "return", &a->return_, "ns1:return_note_attachment"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREnote_USCOREattachmentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREnote_USCOREattachmentResponse, 0, sizeof(struct ns1__get_USCOREnote_USCOREattachmentResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__set_USCOREnote_USCOREattachment(struct soap *soap, struct ns1__set_USCOREnote_USCOREattachment *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
	a->note = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__set_USCOREnote_USCOREattachment(struct soap *soap, const struct ns1__set_USCOREnote_USCOREattachment *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
	soap_serialize_PointerTons1__note_USCOREattachment(soap, &a->note);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__set_USCOREnote_USCOREattachment(struct soap *soap, const struct ns1__set_USCOREnote_USCOREattachment *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__set_USCOREnote_USCOREattachment);
	if (soap_out_ns1__set_USCOREnote_USCOREattachment(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__set_USCOREnote_USCOREattachment(struct soap *soap, const char *tag, int id, const struct ns1__set_USCOREnote_USCOREattachment *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__set_USCOREnote_USCOREattachment), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	if (soap_out_PointerTons1__note_USCOREattachment(soap, "note", -1, &a->note, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__set_USCOREnote_USCOREattachment * SOAP_FMAC4 soap_get_ns1__set_USCOREnote_USCOREattachment(struct soap *soap, struct ns1__set_USCOREnote_USCOREattachment *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__set_USCOREnote_USCOREattachment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__set_USCOREnote_USCOREattachment * SOAP_FMAC4 soap_in_ns1__set_USCOREnote_USCOREattachment(struct soap *soap, const char *tag, struct ns1__set_USCOREnote_USCOREattachment *a, const char *type)
{
	short soap_flag_session = 1, soap_flag_note = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__set_USCOREnote_USCOREattachment *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__set_USCOREnote_USCOREattachment, sizeof(struct ns1__set_USCOREnote_USCOREattachment), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__set_USCOREnote_USCOREattachment(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap_flag_note && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__note_USCOREattachment(soap, "note", &a->note, "ns1:note_attachment"))
				{	soap_flag_note--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCOREnote_USCOREattachment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__set_USCOREnote_USCOREattachment, 0, sizeof(struct ns1__set_USCOREnote_USCOREattachment), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__set_USCOREnote_USCOREattachmentResponse(struct soap *soap, struct ns1__set_USCOREnote_USCOREattachmentResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__set_USCOREnote_USCOREattachmentResponse(struct soap *soap, const struct ns1__set_USCOREnote_USCOREattachmentResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__set_USCOREentry_USCOREresult(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__set_USCOREnote_USCOREattachmentResponse(struct soap *soap, const struct ns1__set_USCOREnote_USCOREattachmentResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__set_USCOREnote_USCOREattachmentResponse);
	if (soap_out_ns1__set_USCOREnote_USCOREattachmentResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__set_USCOREnote_USCOREattachmentResponse(struct soap *soap, const char *tag, int id, const struct ns1__set_USCOREnote_USCOREattachmentResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__set_USCOREnote_USCOREattachmentResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__set_USCOREentry_USCOREresult(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__set_USCOREnote_USCOREattachmentResponse * SOAP_FMAC4 soap_get_ns1__set_USCOREnote_USCOREattachmentResponse(struct soap *soap, struct ns1__set_USCOREnote_USCOREattachmentResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__set_USCOREnote_USCOREattachmentResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__set_USCOREnote_USCOREattachmentResponse * SOAP_FMAC4 soap_in_ns1__set_USCOREnote_USCOREattachmentResponse(struct soap *soap, const char *tag, struct ns1__set_USCOREnote_USCOREattachmentResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__set_USCOREnote_USCOREattachmentResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__set_USCOREnote_USCOREattachmentResponse, sizeof(struct ns1__set_USCOREnote_USCOREattachmentResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__set_USCOREnote_USCOREattachmentResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__set_USCOREentry_USCOREresult(soap, "return", &a->return_, "ns1:set_entry_result"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCOREnote_USCOREattachmentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__set_USCOREnote_USCOREattachmentResponse, 0, sizeof(struct ns1__set_USCOREnote_USCOREattachmentResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__set_USCOREentries(struct soap *soap, struct ns1__set_USCOREentries *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
	soap_default_string(soap, &a->module_USCOREname);
	a->name_USCOREvalue_USCORElists = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__set_USCOREentries(struct soap *soap, const struct ns1__set_USCOREentries *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
	soap_serialize_string(soap, &a->module_USCOREname);
	soap_serialize_PointerToname_USCOREvalue_USCORElists(soap, &a->name_USCOREvalue_USCORElists);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__set_USCOREentries(struct soap *soap, const struct ns1__set_USCOREentries *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__set_USCOREentries);
	if (soap_out_ns1__set_USCOREentries(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__set_USCOREentries(struct soap *soap, const char *tag, int id, const struct ns1__set_USCOREentries *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__set_USCOREentries), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	if (soap_out_string(soap, "module_name", -1, &a->module_USCOREname, ""))
		return soap->error;
	if (soap_out_PointerToname_USCOREvalue_USCORElists(soap, "name_value_lists", -1, &a->name_USCOREvalue_USCORElists, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__set_USCOREentries * SOAP_FMAC4 soap_get_ns1__set_USCOREentries(struct soap *soap, struct ns1__set_USCOREentries *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__set_USCOREentries(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__set_USCOREentries * SOAP_FMAC4 soap_in_ns1__set_USCOREentries(struct soap *soap, const char *tag, struct ns1__set_USCOREentries *a, const char *type)
{
	short soap_flag_session = 1, soap_flag_module_USCOREname = 1, soap_flag_name_USCOREvalue_USCORElists = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__set_USCOREentries *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__set_USCOREentries, sizeof(struct ns1__set_USCOREentries), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__set_USCOREentries(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap_flag_module_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module_name", &a->module_USCOREname, "xsd:string"))
				{	soap_flag_module_USCOREname--;
					continue;
				}
			if (soap_flag_name_USCOREvalue_USCORElists && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToname_USCOREvalue_USCORElists(soap, "name_value_lists", &a->name_USCOREvalue_USCORElists, "ns1:name_value"))
				{	soap_flag_name_USCOREvalue_USCORElists--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCOREentries *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__set_USCOREentries, 0, sizeof(struct ns1__set_USCOREentries), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__set_USCOREentriesResponse(struct soap *soap, struct ns1__set_USCOREentriesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__set_USCOREentriesResponse(struct soap *soap, const struct ns1__set_USCOREentriesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__set_USCOREentries_USCOREresult(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__set_USCOREentriesResponse(struct soap *soap, const struct ns1__set_USCOREentriesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__set_USCOREentriesResponse);
	if (soap_out_ns1__set_USCOREentriesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__set_USCOREentriesResponse(struct soap *soap, const char *tag, int id, const struct ns1__set_USCOREentriesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__set_USCOREentriesResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__set_USCOREentries_USCOREresult(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__set_USCOREentriesResponse * SOAP_FMAC4 soap_get_ns1__set_USCOREentriesResponse(struct soap *soap, struct ns1__set_USCOREentriesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__set_USCOREentriesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__set_USCOREentriesResponse * SOAP_FMAC4 soap_in_ns1__set_USCOREentriesResponse(struct soap *soap, const char *tag, struct ns1__set_USCOREentriesResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__set_USCOREentriesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__set_USCOREentriesResponse, sizeof(struct ns1__set_USCOREentriesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__set_USCOREentriesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__set_USCOREentries_USCOREresult(soap, "return", &a->return_, "ns1:set_entries_result"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCOREentriesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__set_USCOREentriesResponse, 0, sizeof(struct ns1__set_USCOREentriesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__set_USCOREentry(struct soap *soap, struct ns1__set_USCOREentry *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
	soap_default_string(soap, &a->module_USCOREname);
	a->name_USCOREvalue_USCORElist = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__set_USCOREentry(struct soap *soap, const struct ns1__set_USCOREentry *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
	soap_serialize_string(soap, &a->module_USCOREname);
	soap_serialize_PointerToname_USCOREvalue_USCORElist(soap, &a->name_USCOREvalue_USCORElist);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__set_USCOREentry(struct soap *soap, const struct ns1__set_USCOREentry *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__set_USCOREentry);
	if (soap_out_ns1__set_USCOREentry(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__set_USCOREentry(struct soap *soap, const char *tag, int id, const struct ns1__set_USCOREentry *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__set_USCOREentry), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	if (soap_out_string(soap, "module_name", -1, &a->module_USCOREname, ""))
		return soap->error;
	if (soap_out_PointerToname_USCOREvalue_USCORElist(soap, "name_value_list", -1, &a->name_USCOREvalue_USCORElist, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__set_USCOREentry * SOAP_FMAC4 soap_get_ns1__set_USCOREentry(struct soap *soap, struct ns1__set_USCOREentry *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__set_USCOREentry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__set_USCOREentry * SOAP_FMAC4 soap_in_ns1__set_USCOREentry(struct soap *soap, const char *tag, struct ns1__set_USCOREentry *a, const char *type)
{
	short soap_flag_session = 1, soap_flag_module_USCOREname = 1, soap_flag_name_USCOREvalue_USCORElist = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__set_USCOREentry *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__set_USCOREentry, sizeof(struct ns1__set_USCOREentry), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__set_USCOREentry(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap_flag_module_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module_name", &a->module_USCOREname, "xsd:string"))
				{	soap_flag_module_USCOREname--;
					continue;
				}
			if (soap_flag_name_USCOREvalue_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToname_USCOREvalue_USCORElist(soap, "name_value_list", &a->name_USCOREvalue_USCORElist, "ns1:name_value"))
				{	soap_flag_name_USCOREvalue_USCORElist--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCOREentry *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__set_USCOREentry, 0, sizeof(struct ns1__set_USCOREentry), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__set_USCOREentryResponse(struct soap *soap, struct ns1__set_USCOREentryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__set_USCOREentryResponse(struct soap *soap, const struct ns1__set_USCOREentryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__set_USCOREentry_USCOREresult(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__set_USCOREentryResponse(struct soap *soap, const struct ns1__set_USCOREentryResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__set_USCOREentryResponse);
	if (soap_out_ns1__set_USCOREentryResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__set_USCOREentryResponse(struct soap *soap, const char *tag, int id, const struct ns1__set_USCOREentryResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__set_USCOREentryResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__set_USCOREentry_USCOREresult(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__set_USCOREentryResponse * SOAP_FMAC4 soap_get_ns1__set_USCOREentryResponse(struct soap *soap, struct ns1__set_USCOREentryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__set_USCOREentryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__set_USCOREentryResponse * SOAP_FMAC4 soap_in_ns1__set_USCOREentryResponse(struct soap *soap, const char *tag, struct ns1__set_USCOREentryResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__set_USCOREentryResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__set_USCOREentryResponse, sizeof(struct ns1__set_USCOREentryResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__set_USCOREentryResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__set_USCOREentry_USCOREresult(soap, "return", &a->return_, "ns1:set_entry_result"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCOREentryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__set_USCOREentryResponse, 0, sizeof(struct ns1__set_USCOREentryResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREentries(struct soap *soap, struct ns1__get_USCOREentries *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
	soap_default_string(soap, &a->module_USCOREname);
	a->ids = NULL;
	a->select_USCOREfields = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREentries(struct soap *soap, const struct ns1__get_USCOREentries *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
	soap_serialize_string(soap, &a->module_USCOREname);
	soap_serialize_PointerToselect_USCOREfields(soap, &a->ids);
	soap_serialize_PointerToselect_USCOREfields(soap, &a->select_USCOREfields);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREentries(struct soap *soap, const struct ns1__get_USCOREentries *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREentries);
	if (soap_out_ns1__get_USCOREentries(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREentries(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREentries *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREentries), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	if (soap_out_string(soap, "module_name", -1, &a->module_USCOREname, ""))
		return soap->error;
	if (soap_out_PointerToselect_USCOREfields(soap, "ids", -1, &a->ids, ""))
		return soap->error;
	if (soap_out_PointerToselect_USCOREfields(soap, "select_fields", -1, &a->select_USCOREfields, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREentries * SOAP_FMAC4 soap_get_ns1__get_USCOREentries(struct soap *soap, struct ns1__get_USCOREentries *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREentries(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREentries * SOAP_FMAC4 soap_in_ns1__get_USCOREentries(struct soap *soap, const char *tag, struct ns1__get_USCOREentries *a, const char *type)
{
	short soap_flag_session = 1, soap_flag_module_USCOREname = 1, soap_flag_ids = 1, soap_flag_select_USCOREfields = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREentries *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREentries, sizeof(struct ns1__get_USCOREentries), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREentries(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap_flag_module_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module_name", &a->module_USCOREname, "xsd:string"))
				{	soap_flag_module_USCOREname--;
					continue;
				}
			if (soap_flag_ids && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToselect_USCOREfields(soap, "ids", &a->ids, "xsd:string"))
				{	soap_flag_ids--;
					continue;
				}
			if (soap_flag_select_USCOREfields && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToselect_USCOREfields(soap, "select_fields", &a->select_USCOREfields, "xsd:string"))
				{	soap_flag_select_USCOREfields--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREentries *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREentries, 0, sizeof(struct ns1__get_USCOREentries), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREentriesResponse(struct soap *soap, struct ns1__get_USCOREentriesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREentriesResponse(struct soap *soap, const struct ns1__get_USCOREentriesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__get_USCOREentry_USCOREresult(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREentriesResponse(struct soap *soap, const struct ns1__get_USCOREentriesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREentriesResponse);
	if (soap_out_ns1__get_USCOREentriesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREentriesResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREentriesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREentriesResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__get_USCOREentry_USCOREresult(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREentriesResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREentriesResponse(struct soap *soap, struct ns1__get_USCOREentriesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREentriesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREentriesResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREentriesResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREentriesResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREentriesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREentriesResponse, sizeof(struct ns1__get_USCOREentriesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREentriesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__get_USCOREentry_USCOREresult(soap, "return", &a->return_, "ns1:get_entry_result"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREentriesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREentriesResponse, 0, sizeof(struct ns1__get_USCOREentriesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREentry(struct soap *soap, struct ns1__get_USCOREentry *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
	soap_default_string(soap, &a->module_USCOREname);
	soap_default_string(soap, &a->id);
	a->select_USCOREfields = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREentry(struct soap *soap, const struct ns1__get_USCOREentry *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
	soap_serialize_string(soap, &a->module_USCOREname);
	soap_serialize_string(soap, &a->id);
	soap_serialize_PointerToselect_USCOREfields(soap, &a->select_USCOREfields);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREentry(struct soap *soap, const struct ns1__get_USCOREentry *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREentry);
	if (soap_out_ns1__get_USCOREentry(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREentry(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREentry *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREentry), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	if (soap_out_string(soap, "module_name", -1, &a->module_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_PointerToselect_USCOREfields(soap, "select_fields", -1, &a->select_USCOREfields, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREentry * SOAP_FMAC4 soap_get_ns1__get_USCOREentry(struct soap *soap, struct ns1__get_USCOREentry *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREentry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREentry * SOAP_FMAC4 soap_in_ns1__get_USCOREentry(struct soap *soap, const char *tag, struct ns1__get_USCOREentry *a, const char *type)
{
	short soap_flag_session = 1, soap_flag_module_USCOREname = 1, soap_flag_id = 1, soap_flag_select_USCOREfields = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREentry *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREentry, sizeof(struct ns1__get_USCOREentry), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREentry(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap_flag_module_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module_name", &a->module_USCOREname, "xsd:string"))
				{	soap_flag_module_USCOREname--;
					continue;
				}
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_select_USCOREfields && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToselect_USCOREfields(soap, "select_fields", &a->select_USCOREfields, "xsd:string"))
				{	soap_flag_select_USCOREfields--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREentry *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREentry, 0, sizeof(struct ns1__get_USCOREentry), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREentryResponse(struct soap *soap, struct ns1__get_USCOREentryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREentryResponse(struct soap *soap, const struct ns1__get_USCOREentryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__get_USCOREentry_USCOREresult(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREentryResponse(struct soap *soap, const struct ns1__get_USCOREentryResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREentryResponse);
	if (soap_out_ns1__get_USCOREentryResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREentryResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREentryResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREentryResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__get_USCOREentry_USCOREresult(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREentryResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREentryResponse(struct soap *soap, struct ns1__get_USCOREentryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREentryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREentryResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREentryResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREentryResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREentryResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREentryResponse, sizeof(struct ns1__get_USCOREentryResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREentryResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__get_USCOREentry_USCOREresult(soap, "return", &a->return_, "ns1:get_entry_result"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREentryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREentryResponse, 0, sizeof(struct ns1__get_USCOREentryResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREentry_USCORElist(struct soap *soap, struct ns1__get_USCOREentry_USCORElist *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
	soap_default_string(soap, &a->module_USCOREname);
	soap_default_string(soap, &a->query);
	soap_default_string(soap, &a->order_USCOREby);
	soap_default_int(soap, &a->offset);
	a->select_USCOREfields = NULL;
	soap_default_int(soap, &a->max_USCOREresults);
	soap_default_int(soap, &a->deleted);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREentry_USCORElist(struct soap *soap, const struct ns1__get_USCOREentry_USCORElist *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
	soap_serialize_string(soap, &a->module_USCOREname);
	soap_serialize_string(soap, &a->query);
	soap_serialize_string(soap, &a->order_USCOREby);
	soap_embedded(soap, &a->offset, SOAP_TYPE_int);
	soap_serialize_PointerToselect_USCOREfields(soap, &a->select_USCOREfields);
	soap_embedded(soap, &a->max_USCOREresults, SOAP_TYPE_int);
	soap_embedded(soap, &a->deleted, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREentry_USCORElist(struct soap *soap, const struct ns1__get_USCOREentry_USCORElist *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREentry_USCORElist);
	if (soap_out_ns1__get_USCOREentry_USCORElist(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREentry_USCORElist(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREentry_USCORElist *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREentry_USCORElist), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	if (soap_out_string(soap, "module_name", -1, &a->module_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "query", -1, &a->query, ""))
		return soap->error;
	if (soap_out_string(soap, "order_by", -1, &a->order_USCOREby, ""))
		return soap->error;
	if (soap_out_int(soap, "offset", -1, &a->offset, ""))
		return soap->error;
	if (soap_out_PointerToselect_USCOREfields(soap, "select_fields", -1, &a->select_USCOREfields, ""))
		return soap->error;
	if (soap_out_int(soap, "max_results", -1, &a->max_USCOREresults, ""))
		return soap->error;
	if (soap_out_int(soap, "deleted", -1, &a->deleted, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREentry_USCORElist * SOAP_FMAC4 soap_get_ns1__get_USCOREentry_USCORElist(struct soap *soap, struct ns1__get_USCOREentry_USCORElist *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREentry_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREentry_USCORElist * SOAP_FMAC4 soap_in_ns1__get_USCOREentry_USCORElist(struct soap *soap, const char *tag, struct ns1__get_USCOREentry_USCORElist *a, const char *type)
{
	short soap_flag_session = 1, soap_flag_module_USCOREname = 1, soap_flag_query = 1, soap_flag_order_USCOREby = 1, soap_flag_offset = 1, soap_flag_select_USCOREfields = 1, soap_flag_max_USCOREresults = 1, soap_flag_deleted = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREentry_USCORElist *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREentry_USCORElist, sizeof(struct ns1__get_USCOREentry_USCORElist), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREentry_USCORElist(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap_flag_module_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module_name", &a->module_USCOREname, "xsd:string"))
				{	soap_flag_module_USCOREname--;
					continue;
				}
			if (soap_flag_query && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "query", &a->query, "xsd:string"))
				{	soap_flag_query--;
					continue;
				}
			if (soap_flag_order_USCOREby && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "order_by", &a->order_USCOREby, "xsd:string"))
				{	soap_flag_order_USCOREby--;
					continue;
				}
			if (soap_flag_offset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "offset", &a->offset, "xsd:int"))
				{	soap_flag_offset--;
					continue;
				}
			if (soap_flag_select_USCOREfields && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToselect_USCOREfields(soap, "select_fields", &a->select_USCOREfields, "xsd:string"))
				{	soap_flag_select_USCOREfields--;
					continue;
				}
			if (soap_flag_max_USCOREresults && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "max_results", &a->max_USCOREresults, "xsd:int"))
				{	soap_flag_max_USCOREresults--;
					continue;
				}
			if (soap_flag_deleted && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "deleted", &a->deleted, "xsd:int"))
				{	soap_flag_deleted--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREentry_USCORElist *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREentry_USCORElist, 0, sizeof(struct ns1__get_USCOREentry_USCORElist), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_offset > 0 || soap_flag_max_USCOREresults > 0 || soap_flag_deleted > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREentry_USCORElistResponse(struct soap *soap, struct ns1__get_USCOREentry_USCORElistResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREentry_USCORElistResponse(struct soap *soap, const struct ns1__get_USCOREentry_USCORElistResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__get_USCOREentry_USCORElist_USCOREresult(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREentry_USCORElistResponse(struct soap *soap, const struct ns1__get_USCOREentry_USCORElistResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREentry_USCORElistResponse);
	if (soap_out_ns1__get_USCOREentry_USCORElistResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREentry_USCORElistResponse(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREentry_USCORElistResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREentry_USCORElistResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__get_USCOREentry_USCORElist_USCOREresult(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREentry_USCORElistResponse * SOAP_FMAC4 soap_get_ns1__get_USCOREentry_USCORElistResponse(struct soap *soap, struct ns1__get_USCOREentry_USCORElistResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREentry_USCORElistResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREentry_USCORElistResponse * SOAP_FMAC4 soap_in_ns1__get_USCOREentry_USCORElistResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREentry_USCORElistResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREentry_USCORElistResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREentry_USCORElistResponse, sizeof(struct ns1__get_USCOREentry_USCORElistResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREentry_USCORElistResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__get_USCOREentry_USCORElist_USCOREresult(soap, "return", &a->return_, "ns1:get_entry_list_result"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREentry_USCORElistResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREentry_USCORElistResponse, 0, sizeof(struct ns1__get_USCOREentry_USCORElistResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__seamless_USCORElogin(struct soap *soap, struct ns1__seamless_USCORElogin *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__seamless_USCORElogin(struct soap *soap, const struct ns1__seamless_USCORElogin *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__seamless_USCORElogin(struct soap *soap, const struct ns1__seamless_USCORElogin *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__seamless_USCORElogin);
	if (soap_out_ns1__seamless_USCORElogin(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__seamless_USCORElogin(struct soap *soap, const char *tag, int id, const struct ns1__seamless_USCORElogin *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__seamless_USCORElogin), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__seamless_USCORElogin * SOAP_FMAC4 soap_get_ns1__seamless_USCORElogin(struct soap *soap, struct ns1__seamless_USCORElogin *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__seamless_USCORElogin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__seamless_USCORElogin * SOAP_FMAC4 soap_in_ns1__seamless_USCORElogin(struct soap *soap, const char *tag, struct ns1__seamless_USCORElogin *a, const char *type)
{
	short soap_flag_session = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__seamless_USCORElogin *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__seamless_USCORElogin, sizeof(struct ns1__seamless_USCORElogin), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__seamless_USCORElogin(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__seamless_USCORElogin *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__seamless_USCORElogin, 0, sizeof(struct ns1__seamless_USCORElogin), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__seamless_USCOREloginResponse(struct soap *soap, struct ns1__seamless_USCOREloginResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__seamless_USCOREloginResponse(struct soap *soap, const struct ns1__seamless_USCOREloginResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__seamless_USCOREloginResponse(struct soap *soap, const struct ns1__seamless_USCOREloginResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__seamless_USCOREloginResponse);
	if (soap_out_ns1__seamless_USCOREloginResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__seamless_USCOREloginResponse(struct soap *soap, const char *tag, int id, const struct ns1__seamless_USCOREloginResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__seamless_USCOREloginResponse), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__seamless_USCOREloginResponse * SOAP_FMAC4 soap_get_ns1__seamless_USCOREloginResponse(struct soap *soap, struct ns1__seamless_USCOREloginResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__seamless_USCOREloginResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__seamless_USCOREloginResponse * SOAP_FMAC4 soap_in_ns1__seamless_USCOREloginResponse(struct soap *soap, const char *tag, struct ns1__seamless_USCOREloginResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__seamless_USCOREloginResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__seamless_USCOREloginResponse, sizeof(struct ns1__seamless_USCOREloginResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__seamless_USCOREloginResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "return", &a->return_, "xsd:int"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__seamless_USCOREloginResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__seamless_USCOREloginResponse, 0, sizeof(struct ns1__seamless_USCOREloginResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__is_USCOREloopback(struct soap *soap, struct ns1__is_USCOREloopback *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__is_USCOREloopback(struct soap *soap, const struct ns1__is_USCOREloopback *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__is_USCOREloopback(struct soap *soap, const struct ns1__is_USCOREloopback *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__is_USCOREloopback);
	if (soap_out_ns1__is_USCOREloopback(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__is_USCOREloopback(struct soap *soap, const char *tag, int id, const struct ns1__is_USCOREloopback *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__is_USCOREloopback), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__is_USCOREloopback * SOAP_FMAC4 soap_get_ns1__is_USCOREloopback(struct soap *soap, struct ns1__is_USCOREloopback *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__is_USCOREloopback(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__is_USCOREloopback * SOAP_FMAC4 soap_in_ns1__is_USCOREloopback(struct soap *soap, const char *tag, struct ns1__is_USCOREloopback *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__is_USCOREloopback *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__is_USCOREloopback, sizeof(struct ns1__is_USCOREloopback), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__is_USCOREloopback(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__is_USCOREloopback *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__is_USCOREloopback, 0, sizeof(struct ns1__is_USCOREloopback), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__is_USCOREloopbackResponse(struct soap *soap, struct ns1__is_USCOREloopbackResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__is_USCOREloopbackResponse(struct soap *soap, const struct ns1__is_USCOREloopbackResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__is_USCOREloopbackResponse(struct soap *soap, const struct ns1__is_USCOREloopbackResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__is_USCOREloopbackResponse);
	if (soap_out_ns1__is_USCOREloopbackResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__is_USCOREloopbackResponse(struct soap *soap, const char *tag, int id, const struct ns1__is_USCOREloopbackResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__is_USCOREloopbackResponse), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__is_USCOREloopbackResponse * SOAP_FMAC4 soap_get_ns1__is_USCOREloopbackResponse(struct soap *soap, struct ns1__is_USCOREloopbackResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__is_USCOREloopbackResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__is_USCOREloopbackResponse * SOAP_FMAC4 soap_in_ns1__is_USCOREloopbackResponse(struct soap *soap, const char *tag, struct ns1__is_USCOREloopbackResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__is_USCOREloopbackResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__is_USCOREloopbackResponse, sizeof(struct ns1__is_USCOREloopbackResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__is_USCOREloopbackResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "return", &a->return_, "xsd:int"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__is_USCOREloopbackResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__is_USCOREloopbackResponse, 0, sizeof(struct ns1__is_USCOREloopbackResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__login(struct soap *soap, struct ns1__login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->user_USCOREauth = NULL;
	soap_default_string(soap, &a->application_USCOREname);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__login(struct soap *soap, const struct ns1__login *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__user_USCOREauth(soap, &a->user_USCOREauth);
	soap_serialize_string(soap, &a->application_USCOREname);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__login(struct soap *soap, const struct ns1__login *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__login);
	if (soap_out_ns1__login(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__login(struct soap *soap, const char *tag, int id, const struct ns1__login *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__login), type))
		return soap->error;
	if (soap_out_PointerTons1__user_USCOREauth(soap, "user_auth", -1, &a->user_USCOREauth, ""))
		return soap->error;
	if (soap_out_string(soap, "application_name", -1, &a->application_USCOREname, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__login * SOAP_FMAC4 soap_get_ns1__login(struct soap *soap, struct ns1__login *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__login(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__login * SOAP_FMAC4 soap_in_ns1__login(struct soap *soap, const char *tag, struct ns1__login *a, const char *type)
{
	short soap_flag_user_USCOREauth = 1, soap_flag_application_USCOREname = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__login *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__login, sizeof(struct ns1__login), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__login(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_user_USCOREauth && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__user_USCOREauth(soap, "user_auth", &a->user_USCOREauth, "ns1:user_auth"))
				{	soap_flag_user_USCOREauth--;
					continue;
				}
			if (soap_flag_application_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "application_name", &a->application_USCOREname, "xsd:string"))
				{	soap_flag_application_USCOREname--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__login *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__login, 0, sizeof(struct ns1__login), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__loginResponse(struct soap *soap, struct ns1__loginResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__loginResponse(struct soap *soap, const struct ns1__loginResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__set_USCOREentry_USCOREresult(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__loginResponse(struct soap *soap, const struct ns1__loginResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__loginResponse);
	if (soap_out_ns1__loginResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__loginResponse(struct soap *soap, const char *tag, int id, const struct ns1__loginResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__loginResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__set_USCOREentry_USCOREresult(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__loginResponse * SOAP_FMAC4 soap_get_ns1__loginResponse(struct soap *soap, struct ns1__loginResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__loginResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__loginResponse * SOAP_FMAC4 soap_in_ns1__loginResponse(struct soap *soap, const char *tag, struct ns1__loginResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__loginResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__loginResponse, sizeof(struct ns1__loginResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__loginResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__set_USCOREentry_USCOREresult(soap, "return", &a->return_, "ns1:set_entry_result"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__loginResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__loginResponse, 0, sizeof(struct ns1__loginResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__is_USCOREuser_USCOREadmin(struct soap *soap, struct ns1__is_USCOREuser_USCOREadmin *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->session);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__is_USCOREuser_USCOREadmin(struct soap *soap, const struct ns1__is_USCOREuser_USCOREadmin *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->session);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__is_USCOREuser_USCOREadmin(struct soap *soap, const struct ns1__is_USCOREuser_USCOREadmin *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__is_USCOREuser_USCOREadmin);
	if (soap_out_ns1__is_USCOREuser_USCOREadmin(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__is_USCOREuser_USCOREadmin(struct soap *soap, const char *tag, int id, const struct ns1__is_USCOREuser_USCOREadmin *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__is_USCOREuser_USCOREadmin), type))
		return soap->error;
	if (soap_out_string(soap, "session", -1, &a->session, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__is_USCOREuser_USCOREadmin * SOAP_FMAC4 soap_get_ns1__is_USCOREuser_USCOREadmin(struct soap *soap, struct ns1__is_USCOREuser_USCOREadmin *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__is_USCOREuser_USCOREadmin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__is_USCOREuser_USCOREadmin * SOAP_FMAC4 soap_in_ns1__is_USCOREuser_USCOREadmin(struct soap *soap, const char *tag, struct ns1__is_USCOREuser_USCOREadmin *a, const char *type)
{
	short soap_flag_session = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__is_USCOREuser_USCOREadmin *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__is_USCOREuser_USCOREadmin, sizeof(struct ns1__is_USCOREuser_USCOREadmin), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__is_USCOREuser_USCOREadmin(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "session", &a->session, "xsd:string"))
				{	soap_flag_session--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__is_USCOREuser_USCOREadmin *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__is_USCOREuser_USCOREadmin, 0, sizeof(struct ns1__is_USCOREuser_USCOREadmin), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__is_USCOREuser_USCOREadminResponse(struct soap *soap, struct ns1__is_USCOREuser_USCOREadminResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__is_USCOREuser_USCOREadminResponse(struct soap *soap, const struct ns1__is_USCOREuser_USCOREadminResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__is_USCOREuser_USCOREadminResponse(struct soap *soap, const struct ns1__is_USCOREuser_USCOREadminResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__is_USCOREuser_USCOREadminResponse);
	if (soap_out_ns1__is_USCOREuser_USCOREadminResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__is_USCOREuser_USCOREadminResponse(struct soap *soap, const char *tag, int id, const struct ns1__is_USCOREuser_USCOREadminResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__is_USCOREuser_USCOREadminResponse), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__is_USCOREuser_USCOREadminResponse * SOAP_FMAC4 soap_get_ns1__is_USCOREuser_USCOREadminResponse(struct soap *soap, struct ns1__is_USCOREuser_USCOREadminResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__is_USCOREuser_USCOREadminResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__is_USCOREuser_USCOREadminResponse * SOAP_FMAC4 soap_in_ns1__is_USCOREuser_USCOREadminResponse(struct soap *soap, const char *tag, struct ns1__is_USCOREuser_USCOREadminResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__is_USCOREuser_USCOREadminResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__is_USCOREuser_USCOREadminResponse, sizeof(struct ns1__is_USCOREuser_USCOREadminResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__is_USCOREuser_USCOREadminResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "return", &a->return_, "xsd:int"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__is_USCOREuser_USCOREadminResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__is_USCOREuser_USCOREadminResponse, 0, sizeof(struct ns1__is_USCOREuser_USCOREadminResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_user_USCOREdetail_USCOREarray(struct soap *soap, struct user_USCOREdetail_USCOREarray *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_user_USCOREdetail_USCOREarray(struct soap *soap, struct user_USCOREdetail_USCOREarray const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_user_USCOREdetail_USCOREarray))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__user_USCOREdetail(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_user_USCOREdetail_USCOREarray(struct soap *soap, const struct user_USCOREdetail_USCOREarray *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_user_USCOREdetail_USCOREarray);
	if (soap_out_user_USCOREdetail_USCOREarray(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_user_USCOREdetail_USCOREarray(struct soap *soap, const char *tag, int id, const struct user_USCOREdetail_USCOREarray *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:user_detail", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_user_USCOREdetail_USCOREarray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__user_USCOREdetail(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct user_USCOREdetail_USCOREarray * SOAP_FMAC4 soap_get_user_USCOREdetail_USCOREarray(struct soap *soap, struct user_USCOREdetail_USCOREarray *p, const char *tag, const char *type)
{
	if ((p = soap_in_user_USCOREdetail_USCOREarray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct user_USCOREdetail_USCOREarray * SOAP_FMAC4 soap_in_user_USCOREdetail_USCOREarray(struct soap *soap, const char *tag, struct user_USCOREdetail_USCOREarray *a, const char *type)
{	int i, j;
	struct ns1__user_USCOREdetail **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct user_USCOREdetail_USCOREarray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_user_USCOREdetail_USCOREarray, sizeof(struct user_USCOREdetail_USCOREarray), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_user_USCOREdetail_USCOREarray(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__user_USCOREdetail **)soap_malloc(soap, sizeof(struct ns1__user_USCOREdetail *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__user_USCOREdetail(soap, NULL, a->__ptr + i, "ns1:user_detail"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__user_USCOREdetail **)soap_push_block(soap, sizeof(struct ns1__user_USCOREdetail *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__user_USCOREdetail(soap, NULL, p, "ns1:user_detail"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (struct ns1__user_USCOREdetail **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct user_USCOREdetail_USCOREarray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_user_USCOREdetail_USCOREarray, 0, sizeof(struct user_USCOREdetail_USCOREarray), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_contact_USCOREdetail_USCOREarray(struct soap *soap, struct contact_USCOREdetail_USCOREarray *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_contact_USCOREdetail_USCOREarray(struct soap *soap, struct contact_USCOREdetail_USCOREarray const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_contact_USCOREdetail_USCOREarray))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__contact_USCOREdetail(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_contact_USCOREdetail_USCOREarray(struct soap *soap, const struct contact_USCOREdetail_USCOREarray *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_contact_USCOREdetail_USCOREarray);
	if (soap_out_contact_USCOREdetail_USCOREarray(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_contact_USCOREdetail_USCOREarray(struct soap *soap, const char *tag, int id, const struct contact_USCOREdetail_USCOREarray *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:contact_detail", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_contact_USCOREdetail_USCOREarray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__contact_USCOREdetail(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct contact_USCOREdetail_USCOREarray * SOAP_FMAC4 soap_get_contact_USCOREdetail_USCOREarray(struct soap *soap, struct contact_USCOREdetail_USCOREarray *p, const char *tag, const char *type)
{
	if ((p = soap_in_contact_USCOREdetail_USCOREarray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct contact_USCOREdetail_USCOREarray * SOAP_FMAC4 soap_in_contact_USCOREdetail_USCOREarray(struct soap *soap, const char *tag, struct contact_USCOREdetail_USCOREarray *a, const char *type)
{	int i, j;
	struct ns1__contact_USCOREdetail **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct contact_USCOREdetail_USCOREarray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_contact_USCOREdetail_USCOREarray, sizeof(struct contact_USCOREdetail_USCOREarray), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_contact_USCOREdetail_USCOREarray(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__contact_USCOREdetail **)soap_malloc(soap, sizeof(struct ns1__contact_USCOREdetail *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__contact_USCOREdetail(soap, NULL, a->__ptr + i, "ns1:contact_detail"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__contact_USCOREdetail **)soap_push_block(soap, sizeof(struct ns1__contact_USCOREdetail *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__contact_USCOREdetail(soap, NULL, p, "ns1:contact_detail"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (struct ns1__contact_USCOREdetail **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct contact_USCOREdetail_USCOREarray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_contact_USCOREdetail_USCOREarray, 0, sizeof(struct contact_USCOREdetail_USCOREarray), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_str_USCOREarray(struct soap *soap, struct str_USCOREarray *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_str_USCOREarray(struct soap *soap, struct str_USCOREarray const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_str_USCOREarray))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_string(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_str_USCOREarray(struct soap *soap, const struct str_USCOREarray *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_str_USCOREarray);
	if (soap_out_str_USCOREarray(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_str_USCOREarray(struct soap *soap, const char *tag, int id, const struct str_USCOREarray *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "xsd:string", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_str_USCOREarray);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_string(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct str_USCOREarray * SOAP_FMAC4 soap_get_str_USCOREarray(struct soap *soap, struct str_USCOREarray *p, const char *tag, const char *type)
{
	if ((p = soap_in_str_USCOREarray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct str_USCOREarray * SOAP_FMAC4 soap_in_str_USCOREarray(struct soap *soap, const char *tag, struct str_USCOREarray *a, const char *type)
{	int i, j;
	char **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct str_USCOREarray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_str_USCOREarray, sizeof(struct str_USCOREarray), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_str_USCOREarray(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (char **)soap_malloc(soap, sizeof(char *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_string(soap, NULL, a->__ptr + i, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (char **)soap_push_block(soap, sizeof(char *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_string(soap, NULL, p, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (char **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct str_USCOREarray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_str_USCOREarray, 0, sizeof(struct str_USCOREarray), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_name_USCOREvalue_USCOREoperator_USCORElist(struct soap *soap, struct name_USCOREvalue_USCOREoperator_USCORElist *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_name_USCOREvalue_USCOREoperator_USCORElist(struct soap *soap, struct name_USCOREvalue_USCOREoperator_USCORElist const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_name_USCOREvalue_USCOREoperator_USCORElist))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__name_USCOREvalue_USCOREoperator(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_name_USCOREvalue_USCOREoperator_USCORElist(struct soap *soap, const struct name_USCOREvalue_USCOREoperator_USCORElist *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_name_USCOREvalue_USCOREoperator_USCORElist);
	if (soap_out_name_USCOREvalue_USCOREoperator_USCORElist(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_name_USCOREvalue_USCOREoperator_USCORElist(struct soap *soap, const char *tag, int id, const struct name_USCOREvalue_USCOREoperator_USCORElist *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:name_value_operator", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_name_USCOREvalue_USCOREoperator_USCORElist);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__name_USCOREvalue_USCOREoperator(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct name_USCOREvalue_USCOREoperator_USCORElist * SOAP_FMAC4 soap_get_name_USCOREvalue_USCOREoperator_USCORElist(struct soap *soap, struct name_USCOREvalue_USCOREoperator_USCORElist *p, const char *tag, const char *type)
{
	if ((p = soap_in_name_USCOREvalue_USCOREoperator_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct name_USCOREvalue_USCOREoperator_USCORElist * SOAP_FMAC4 soap_in_name_USCOREvalue_USCOREoperator_USCORElist(struct soap *soap, const char *tag, struct name_USCOREvalue_USCOREoperator_USCORElist *a, const char *type)
{	int i, j;
	struct ns1__name_USCOREvalue_USCOREoperator **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct name_USCOREvalue_USCOREoperator_USCORElist *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_name_USCOREvalue_USCOREoperator_USCORElist, sizeof(struct name_USCOREvalue_USCOREoperator_USCORElist), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_name_USCOREvalue_USCOREoperator_USCORElist(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__name_USCOREvalue_USCOREoperator **)soap_malloc(soap, sizeof(struct ns1__name_USCOREvalue_USCOREoperator *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__name_USCOREvalue_USCOREoperator(soap, NULL, a->__ptr + i, "ns1:name_value_operator"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__name_USCOREvalue_USCOREoperator **)soap_push_block(soap, sizeof(struct ns1__name_USCOREvalue_USCOREoperator *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__name_USCOREvalue_USCOREoperator(soap, NULL, p, "ns1:name_value_operator"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (struct ns1__name_USCOREvalue_USCOREoperator **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct name_USCOREvalue_USCOREoperator_USCORElist *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_name_USCOREvalue_USCOREoperator_USCORElist, 0, sizeof(struct name_USCOREvalue_USCOREoperator_USCORElist), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_new_USCOREset_USCORErelationhip_USCOREids(struct soap *soap, struct new_USCOREset_USCORErelationhip_USCOREids *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_new_USCOREset_USCORErelationhip_USCOREids(struct soap *soap, struct new_USCOREset_USCORErelationhip_USCOREids const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_new_USCOREset_USCORErelationhip_USCOREids))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerToselect_USCOREfields(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_new_USCOREset_USCORErelationhip_USCOREids(struct soap *soap, const struct new_USCOREset_USCORErelationhip_USCOREids *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_new_USCOREset_USCORErelationhip_USCOREids);
	if (soap_out_new_USCOREset_USCORErelationhip_USCOREids(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_new_USCOREset_USCORErelationhip_USCOREids(struct soap *soap, const char *tag, int id, const struct new_USCOREset_USCORErelationhip_USCOREids *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "xsd:string", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_new_USCOREset_USCORErelationhip_USCOREids);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerToselect_USCOREfields(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct new_USCOREset_USCORErelationhip_USCOREids * SOAP_FMAC4 soap_get_new_USCOREset_USCORErelationhip_USCOREids(struct soap *soap, struct new_USCOREset_USCORErelationhip_USCOREids *p, const char *tag, const char *type)
{
	if ((p = soap_in_new_USCOREset_USCORErelationhip_USCOREids(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct new_USCOREset_USCORErelationhip_USCOREids * SOAP_FMAC4 soap_in_new_USCOREset_USCORErelationhip_USCOREids(struct soap *soap, const char *tag, struct new_USCOREset_USCORErelationhip_USCOREids *a, const char *type)
{	int i, j;
	struct select_USCOREfields **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct new_USCOREset_USCORErelationhip_USCOREids *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_new_USCOREset_USCORErelationhip_USCOREids, sizeof(struct new_USCOREset_USCORErelationhip_USCOREids), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_new_USCOREset_USCORErelationhip_USCOREids(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct select_USCOREfields **)soap_malloc(soap, sizeof(struct select_USCOREfields *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerToselect_USCOREfields(soap, NULL, a->__ptr + i, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (struct select_USCOREfields **)soap_push_block(soap, sizeof(struct select_USCOREfields *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerToselect_USCOREfields(soap, NULL, p, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (struct select_USCOREfields **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct new_USCOREset_USCORErelationhip_USCOREids *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_new_USCOREset_USCORErelationhip_USCOREids, 0, sizeof(struct new_USCOREset_USCORErelationhip_USCOREids), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_set_USCORErelationship_USCORElist(struct soap *soap, struct set_USCORErelationship_USCORElist *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_set_USCORErelationship_USCORElist(struct soap *soap, struct set_USCORErelationship_USCORElist const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_set_USCORErelationship_USCORElist))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__set_USCORErelationship_USCOREvalue(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_set_USCORErelationship_USCORElist(struct soap *soap, const struct set_USCORErelationship_USCORElist *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_set_USCORErelationship_USCORElist);
	if (soap_out_set_USCORErelationship_USCORElist(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_set_USCORErelationship_USCORElist(struct soap *soap, const char *tag, int id, const struct set_USCORErelationship_USCORElist *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:set_relationship_value", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_set_USCORErelationship_USCORElist);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__set_USCORErelationship_USCOREvalue(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct set_USCORErelationship_USCORElist * SOAP_FMAC4 soap_get_set_USCORErelationship_USCORElist(struct soap *soap, struct set_USCORErelationship_USCORElist *p, const char *tag, const char *type)
{
	if ((p = soap_in_set_USCORErelationship_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct set_USCORErelationship_USCORElist * SOAP_FMAC4 soap_in_set_USCORErelationship_USCORElist(struct soap *soap, const char *tag, struct set_USCORErelationship_USCORElist *a, const char *type)
{	int i, j;
	struct ns1__set_USCORErelationship_USCOREvalue **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct set_USCORErelationship_USCORElist *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_set_USCORErelationship_USCORElist, sizeof(struct set_USCORErelationship_USCORElist), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_set_USCORErelationship_USCORElist(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__set_USCORErelationship_USCOREvalue **)soap_malloc(soap, sizeof(struct ns1__set_USCORErelationship_USCOREvalue *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__set_USCORErelationship_USCOREvalue(soap, NULL, a->__ptr + i, "ns1:set_relationship_value"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__set_USCORErelationship_USCOREvalue **)soap_push_block(soap, sizeof(struct ns1__set_USCORErelationship_USCOREvalue *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__set_USCORErelationship_USCOREvalue(soap, NULL, p, "ns1:set_relationship_value"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (struct ns1__set_USCORErelationship_USCOREvalue **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct set_USCORErelationship_USCORElist *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_set_USCORErelationship_USCORElist, 0, sizeof(struct set_USCORErelationship_USCORElist), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_link_USCOREvalue(struct soap *soap, struct link_USCOREvalue *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_link_USCOREvalue(struct soap *soap, struct link_USCOREvalue const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_link_USCOREvalue))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerToname_USCOREvalue_USCORElist(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_link_USCOREvalue(struct soap *soap, const struct link_USCOREvalue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_link_USCOREvalue);
	if (soap_out_link_USCOREvalue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_link_USCOREvalue(struct soap *soap, const char *tag, int id, const struct link_USCOREvalue *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:name_value", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_link_USCOREvalue);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerToname_USCOREvalue_USCORElist(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct link_USCOREvalue * SOAP_FMAC4 soap_get_link_USCOREvalue(struct soap *soap, struct link_USCOREvalue *p, const char *tag, const char *type)
{
	if ((p = soap_in_link_USCOREvalue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct link_USCOREvalue * SOAP_FMAC4 soap_in_link_USCOREvalue(struct soap *soap, const char *tag, struct link_USCOREvalue *a, const char *type)
{	int i, j;
	struct name_USCOREvalue_USCORElist **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct link_USCOREvalue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_link_USCOREvalue, sizeof(struct link_USCOREvalue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_link_USCOREvalue(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct name_USCOREvalue_USCORElist **)soap_malloc(soap, sizeof(struct name_USCOREvalue_USCORElist *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerToname_USCOREvalue_USCORElist(soap, NULL, a->__ptr + i, "ns1:name_value"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (struct name_USCOREvalue_USCORElist **)soap_push_block(soap, sizeof(struct name_USCOREvalue_USCORElist *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerToname_USCOREvalue_USCORElist(soap, NULL, p, "ns1:name_value"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (struct name_USCOREvalue_USCORElist **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct link_USCOREvalue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_link_USCOREvalue, 0, sizeof(struct link_USCOREvalue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__user_USCOREdetail(struct soap *soap, struct ns1__user_USCOREdetail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->email_USCOREaddress);
	soap_default_string(soap, &a->user_USCOREname);
	soap_default_string(soap, &a->first_USCOREname);
	soap_default_string(soap, &a->last_USCOREname);
	soap_default_string(soap, &a->department);
	soap_default_string(soap, &a->id);
	soap_default_string(soap, &a->title);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__user_USCOREdetail(struct soap *soap, const struct ns1__user_USCOREdetail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->email_USCOREaddress);
	soap_serialize_string(soap, &a->user_USCOREname);
	soap_serialize_string(soap, &a->first_USCOREname);
	soap_serialize_string(soap, &a->last_USCOREname);
	soap_serialize_string(soap, &a->department);
	soap_serialize_string(soap, &a->id);
	soap_serialize_string(soap, &a->title);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__user_USCOREdetail(struct soap *soap, const struct ns1__user_USCOREdetail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__user_USCOREdetail);
	if (soap_out_ns1__user_USCOREdetail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__user_USCOREdetail(struct soap *soap, const char *tag, int id, const struct ns1__user_USCOREdetail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__user_USCOREdetail), type))
		return soap->error;
	if (soap_out_string(soap, "email_address", -1, &a->email_USCOREaddress, ""))
		return soap->error;
	if (soap_out_string(soap, "user_name", -1, &a->user_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "first_name", -1, &a->first_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "last_name", -1, &a->last_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "department", -1, &a->department, ""))
		return soap->error;
	if (soap_out_string(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_string(soap, "title", -1, &a->title, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__user_USCOREdetail * SOAP_FMAC4 soap_get_ns1__user_USCOREdetail(struct soap *soap, struct ns1__user_USCOREdetail *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__user_USCOREdetail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__user_USCOREdetail * SOAP_FMAC4 soap_in_ns1__user_USCOREdetail(struct soap *soap, const char *tag, struct ns1__user_USCOREdetail *a, const char *type)
{
	short soap_flag_email_USCOREaddress = 1, soap_flag_user_USCOREname = 1, soap_flag_first_USCOREname = 1, soap_flag_last_USCOREname = 1, soap_flag_department = 1, soap_flag_id = 1, soap_flag_title = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__user_USCOREdetail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__user_USCOREdetail, sizeof(struct ns1__user_USCOREdetail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__user_USCOREdetail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_email_USCOREaddress && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "email_address", &a->email_USCOREaddress, "xsd:string"))
				{	soap_flag_email_USCOREaddress--;
					continue;
				}
			if (soap_flag_user_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "user_name", &a->user_USCOREname, "xsd:string"))
				{	soap_flag_user_USCOREname--;
					continue;
				}
			if (soap_flag_first_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "first_name", &a->first_USCOREname, "xsd:string"))
				{	soap_flag_first_USCOREname--;
					continue;
				}
			if (soap_flag_last_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "last_name", &a->last_USCOREname, "xsd:string"))
				{	soap_flag_last_USCOREname--;
					continue;
				}
			if (soap_flag_department && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "department", &a->department, "xsd:string"))
				{	soap_flag_department--;
					continue;
				}
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_title && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "title", &a->title, "xsd:string"))
				{	soap_flag_title--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__user_USCOREdetail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__user_USCOREdetail, 0, sizeof(struct ns1__user_USCOREdetail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_email_USCOREaddress > 0 || soap_flag_user_USCOREname > 0 || soap_flag_first_USCOREname > 0 || soap_flag_last_USCOREname > 0 || soap_flag_department > 0 || soap_flag_id > 0 || soap_flag_title > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__contact_USCOREdetail(struct soap *soap, struct ns1__contact_USCOREdetail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->email_USCOREaddress);
	soap_default_string(soap, &a->name1);
	soap_default_string(soap, &a->name2);
	soap_default_string(soap, &a->association);
	soap_default_string(soap, &a->id);
	soap_default_string(soap, &a->msi_USCOREid);
	soap_default_string(soap, &a->type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__contact_USCOREdetail(struct soap *soap, const struct ns1__contact_USCOREdetail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->email_USCOREaddress);
	soap_serialize_string(soap, &a->name1);
	soap_serialize_string(soap, &a->name2);
	soap_serialize_string(soap, &a->association);
	soap_serialize_string(soap, &a->id);
	soap_serialize_string(soap, &a->msi_USCOREid);
	soap_serialize_string(soap, &a->type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__contact_USCOREdetail(struct soap *soap, const struct ns1__contact_USCOREdetail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__contact_USCOREdetail);
	if (soap_out_ns1__contact_USCOREdetail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__contact_USCOREdetail(struct soap *soap, const char *tag, int id, const struct ns1__contact_USCOREdetail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__contact_USCOREdetail), type))
		return soap->error;
	if (soap_out_string(soap, "email_address", -1, &a->email_USCOREaddress, ""))
		return soap->error;
	if (soap_out_string(soap, "name1", -1, &a->name1, ""))
		return soap->error;
	if (soap_out_string(soap, "name2", -1, &a->name2, ""))
		return soap->error;
	if (soap_out_string(soap, "association", -1, &a->association, ""))
		return soap->error;
	if (soap_out_string(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_string(soap, "msi_id", -1, &a->msi_USCOREid, ""))
		return soap->error;
	if (soap_out_string(soap, "type", -1, &a->type, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__contact_USCOREdetail * SOAP_FMAC4 soap_get_ns1__contact_USCOREdetail(struct soap *soap, struct ns1__contact_USCOREdetail *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__contact_USCOREdetail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__contact_USCOREdetail * SOAP_FMAC4 soap_in_ns1__contact_USCOREdetail(struct soap *soap, const char *tag, struct ns1__contact_USCOREdetail *a, const char *type)
{
	short soap_flag_email_USCOREaddress = 1, soap_flag_name1 = 1, soap_flag_name2 = 1, soap_flag_association = 1, soap_flag_id = 1, soap_flag_msi_USCOREid = 1, soap_flag_type = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__contact_USCOREdetail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__contact_USCOREdetail, sizeof(struct ns1__contact_USCOREdetail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__contact_USCOREdetail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_email_USCOREaddress && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "email_address", &a->email_USCOREaddress, "xsd:string"))
				{	soap_flag_email_USCOREaddress--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name1", &a->name1, "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name2", &a->name2, "xsd:string"))
				{	soap_flag_name2--;
					continue;
				}
			if (soap_flag_association && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "association", &a->association, "xsd:string"))
				{	soap_flag_association--;
					continue;
				}
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_msi_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "msi_id", &a->msi_USCOREid, "xsd:string"))
				{	soap_flag_msi_USCOREid--;
					continue;
				}
			if (soap_flag_type && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "type", &a->type, "xsd:string"))
				{	soap_flag_type--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__contact_USCOREdetail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__contact_USCOREdetail, 0, sizeof(struct ns1__contact_USCOREdetail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_email_USCOREaddress > 0 || soap_flag_name1 > 0 || soap_flag_name2 > 0 || soap_flag_association > 0 || soap_flag_id > 0 || soap_flag_msi_USCOREid > 0 || soap_flag_type > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__set_USCOREentries_USCOREdetail_USCOREresult(struct soap *soap, struct ns1__set_USCOREentries_USCOREdetail_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->name_USCOREvalue_USCORElists = NULL;
	a->error = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__set_USCOREentries_USCOREdetail_USCOREresult(struct soap *soap, const struct ns1__set_USCOREentries_USCOREdetail_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToname_USCOREvalue_USCORElists(soap, &a->name_USCOREvalue_USCORElists);
	soap_serialize_PointerTons1__error_USCOREvalue(soap, &a->error);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__set_USCOREentries_USCOREdetail_USCOREresult(struct soap *soap, const struct ns1__set_USCOREentries_USCOREdetail_USCOREresult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__set_USCOREentries_USCOREdetail_USCOREresult);
	if (soap_out_ns1__set_USCOREentries_USCOREdetail_USCOREresult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__set_USCOREentries_USCOREdetail_USCOREresult(struct soap *soap, const char *tag, int id, const struct ns1__set_USCOREentries_USCOREdetail_USCOREresult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__set_USCOREentries_USCOREdetail_USCOREresult), type))
		return soap->error;
	if (soap_out_PointerToname_USCOREvalue_USCORElists(soap, "name_value_lists", -1, &a->name_USCOREvalue_USCORElists, ""))
		return soap->error;
	if (soap_out_PointerTons1__error_USCOREvalue(soap, "error", -1, &a->error, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__set_USCOREentries_USCOREdetail_USCOREresult * SOAP_FMAC4 soap_get_ns1__set_USCOREentries_USCOREdetail_USCOREresult(struct soap *soap, struct ns1__set_USCOREentries_USCOREdetail_USCOREresult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__set_USCOREentries_USCOREdetail_USCOREresult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__set_USCOREentries_USCOREdetail_USCOREresult * SOAP_FMAC4 soap_in_ns1__set_USCOREentries_USCOREdetail_USCOREresult(struct soap *soap, const char *tag, struct ns1__set_USCOREentries_USCOREdetail_USCOREresult *a, const char *type)
{
	short soap_flag_name_USCOREvalue_USCORElists = 1, soap_flag_error = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__set_USCOREentries_USCOREdetail_USCOREresult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__set_USCOREentries_USCOREdetail_USCOREresult, sizeof(struct ns1__set_USCOREentries_USCOREdetail_USCOREresult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__set_USCOREentries_USCOREdetail_USCOREresult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name_USCOREvalue_USCORElists && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToname_USCOREvalue_USCORElists(soap, "name_value_lists", &a->name_USCOREvalue_USCORElists, "ns1:name_value"))
				{	soap_flag_name_USCOREvalue_USCORElists--;
					continue;
				}
			if (soap_flag_error && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__error_USCOREvalue(soap, "error", &a->error, "ns1:error_value"))
				{	soap_flag_error--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCOREentries_USCOREdetail_USCOREresult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__set_USCOREentries_USCOREdetail_USCOREresult, 0, sizeof(struct ns1__set_USCOREentries_USCOREdetail_USCOREresult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name_USCOREvalue_USCORElists > 0 || soap_flag_error > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREentries_USCOREcount_USCOREresult(struct soap *soap, struct ns1__get_USCOREentries_USCOREcount_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result_USCOREcount);
	a->error = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREentries_USCOREcount_USCOREresult(struct soap *soap, const struct ns1__get_USCOREentries_USCOREcount_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result_USCOREcount, SOAP_TYPE_int);
	soap_serialize_PointerTons1__error_USCOREvalue(soap, &a->error);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREentries_USCOREcount_USCOREresult(struct soap *soap, const struct ns1__get_USCOREentries_USCOREcount_USCOREresult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREentries_USCOREcount_USCOREresult);
	if (soap_out_ns1__get_USCOREentries_USCOREcount_USCOREresult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREentries_USCOREcount_USCOREresult(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREentries_USCOREcount_USCOREresult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREentries_USCOREcount_USCOREresult), type))
		return soap->error;
	if (soap_out_int(soap, "result_count", -1, &a->result_USCOREcount, ""))
		return soap->error;
	if (soap_out_PointerTons1__error_USCOREvalue(soap, "error", -1, &a->error, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREentries_USCOREcount_USCOREresult * SOAP_FMAC4 soap_get_ns1__get_USCOREentries_USCOREcount_USCOREresult(struct soap *soap, struct ns1__get_USCOREentries_USCOREcount_USCOREresult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREentries_USCOREcount_USCOREresult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREentries_USCOREcount_USCOREresult * SOAP_FMAC4 soap_in_ns1__get_USCOREentries_USCOREcount_USCOREresult(struct soap *soap, const char *tag, struct ns1__get_USCOREentries_USCOREcount_USCOREresult *a, const char *type)
{
	short soap_flag_result_USCOREcount = 1, soap_flag_error = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREentries_USCOREcount_USCOREresult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREentries_USCOREcount_USCOREresult, sizeof(struct ns1__get_USCOREentries_USCOREcount_USCOREresult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREentries_USCOREcount_USCOREresult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result_USCOREcount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result_count", &a->result_USCOREcount, "xsd:int"))
				{	soap_flag_result_USCOREcount--;
					continue;
				}
			if (soap_flag_error && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__error_USCOREvalue(soap, "error", &a->error, "ns1:error_value"))
				{	soap_flag_error--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREentries_USCOREcount_USCOREresult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREentries_USCOREcount_USCOREresult, 0, sizeof(struct ns1__get_USCOREentries_USCOREcount_USCOREresult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result_USCOREcount > 0 || soap_flag_error > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_name_USCOREvalue_USCORElists(struct soap *soap, struct name_USCOREvalue_USCORElists *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_name_USCOREvalue_USCORElists(struct soap *soap, struct name_USCOREvalue_USCORElists const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_name_USCOREvalue_USCORElists))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerToname_USCOREvalue_USCORElist(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_name_USCOREvalue_USCORElists(struct soap *soap, const struct name_USCOREvalue_USCORElists *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_name_USCOREvalue_USCORElists);
	if (soap_out_name_USCOREvalue_USCORElists(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_name_USCOREvalue_USCORElists(struct soap *soap, const char *tag, int id, const struct name_USCOREvalue_USCORElists *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:name_value", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_name_USCOREvalue_USCORElists);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerToname_USCOREvalue_USCORElist(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct name_USCOREvalue_USCORElists * SOAP_FMAC4 soap_get_name_USCOREvalue_USCORElists(struct soap *soap, struct name_USCOREvalue_USCORElists *p, const char *tag, const char *type)
{
	if ((p = soap_in_name_USCOREvalue_USCORElists(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct name_USCOREvalue_USCORElists * SOAP_FMAC4 soap_in_name_USCOREvalue_USCORElists(struct soap *soap, const char *tag, struct name_USCOREvalue_USCORElists *a, const char *type)
{	int i, j;
	struct name_USCOREvalue_USCORElist **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct name_USCOREvalue_USCORElists *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_name_USCOREvalue_USCORElists, sizeof(struct name_USCOREvalue_USCORElists), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_name_USCOREvalue_USCORElists(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct name_USCOREvalue_USCORElist **)soap_malloc(soap, sizeof(struct name_USCOREvalue_USCORElist *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerToname_USCOREvalue_USCORElist(soap, NULL, a->__ptr + i, "ns1:name_value"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (struct name_USCOREvalue_USCORElist **)soap_push_block(soap, sizeof(struct name_USCOREvalue_USCORElist *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerToname_USCOREvalue_USCORElist(soap, NULL, p, "ns1:name_value"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (struct name_USCOREvalue_USCORElist **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct name_USCOREvalue_USCORElists *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_name_USCOREvalue_USCORElists, 0, sizeof(struct name_USCOREvalue_USCORElists), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__name_USCOREvalue_USCORElists_USCOREerror(struct soap *soap, struct ns1__name_USCOREvalue_USCORElists_USCOREerror *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->name_USCOREvalue_USCORElists = NULL;
	a->error = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__name_USCOREvalue_USCORElists_USCOREerror(struct soap *soap, const struct ns1__name_USCOREvalue_USCORElists_USCOREerror *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToname_USCOREvalue_USCORElists(soap, &a->name_USCOREvalue_USCORElists);
	soap_serialize_PointerTons1__error_USCOREvalue(soap, &a->error);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__name_USCOREvalue_USCORElists_USCOREerror(struct soap *soap, const struct ns1__name_USCOREvalue_USCORElists_USCOREerror *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__name_USCOREvalue_USCORElists_USCOREerror);
	if (soap_out_ns1__name_USCOREvalue_USCORElists_USCOREerror(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__name_USCOREvalue_USCORElists_USCOREerror(struct soap *soap, const char *tag, int id, const struct ns1__name_USCOREvalue_USCORElists_USCOREerror *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__name_USCOREvalue_USCORElists_USCOREerror), type))
		return soap->error;
	if (soap_out_PointerToname_USCOREvalue_USCORElists(soap, "name_value_lists", -1, &a->name_USCOREvalue_USCORElists, ""))
		return soap->error;
	if (soap_out_PointerTons1__error_USCOREvalue(soap, "error", -1, &a->error, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__name_USCOREvalue_USCORElists_USCOREerror * SOAP_FMAC4 soap_get_ns1__name_USCOREvalue_USCORElists_USCOREerror(struct soap *soap, struct ns1__name_USCOREvalue_USCORElists_USCOREerror *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__name_USCOREvalue_USCORElists_USCOREerror(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__name_USCOREvalue_USCORElists_USCOREerror * SOAP_FMAC4 soap_in_ns1__name_USCOREvalue_USCORElists_USCOREerror(struct soap *soap, const char *tag, struct ns1__name_USCOREvalue_USCORElists_USCOREerror *a, const char *type)
{
	short soap_flag_name_USCOREvalue_USCORElists = 1, soap_flag_error = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__name_USCOREvalue_USCORElists_USCOREerror *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__name_USCOREvalue_USCORElists_USCOREerror, sizeof(struct ns1__name_USCOREvalue_USCORElists_USCOREerror), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__name_USCOREvalue_USCORElists_USCOREerror(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name_USCOREvalue_USCORElists && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToname_USCOREvalue_USCORElists(soap, "name_value_lists", &a->name_USCOREvalue_USCORElists, "ns1:name_value"))
				{	soap_flag_name_USCOREvalue_USCORElists--;
					continue;
				}
			if (soap_flag_error && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__error_USCOREvalue(soap, "error", &a->error, "ns1:error_value"))
				{	soap_flag_error--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__name_USCOREvalue_USCORElists_USCOREerror *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__name_USCOREvalue_USCORElists_USCOREerror, 0, sizeof(struct ns1__name_USCOREvalue_USCORElists_USCOREerror), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name_USCOREvalue_USCORElists > 0 || soap_flag_error > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_newsletter_USCORElist(struct soap *soap, struct newsletter_USCORElist *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_newsletter_USCORElist(struct soap *soap, struct newsletter_USCORElist const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_newsletter_USCORElist))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__newsletter(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_newsletter_USCORElist(struct soap *soap, const struct newsletter_USCORElist *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_newsletter_USCORElist);
	if (soap_out_newsletter_USCORElist(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_newsletter_USCORElist(struct soap *soap, const char *tag, int id, const struct newsletter_USCORElist *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:newsletter", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_newsletter_USCORElist);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__newsletter(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct newsletter_USCORElist * SOAP_FMAC4 soap_get_newsletter_USCORElist(struct soap *soap, struct newsletter_USCORElist *p, const char *tag, const char *type)
{
	if ((p = soap_in_newsletter_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct newsletter_USCORElist * SOAP_FMAC4 soap_in_newsletter_USCORElist(struct soap *soap, const char *tag, struct newsletter_USCORElist *a, const char *type)
{	int i, j;
	struct ns1__newsletter **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct newsletter_USCORElist *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_newsletter_USCORElist, sizeof(struct newsletter_USCORElist), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_newsletter_USCORElist(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__newsletter **)soap_malloc(soap, sizeof(struct ns1__newsletter *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__newsletter(soap, NULL, a->__ptr + i, "ns1:newsletter"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__newsletter **)soap_push_block(soap, sizeof(struct ns1__newsletter *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__newsletter(soap, NULL, p, "ns1:newsletter"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (struct ns1__newsletter **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct newsletter_USCORElist *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_newsletter_USCORElist, 0, sizeof(struct newsletter_USCORElist), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREsubscription_USCORElists_USCOREresult(struct soap *soap, struct ns1__get_USCOREsubscription_USCORElists_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->unsubscribed = NULL;
	a->subscribed = NULL;
	a->error = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREsubscription_USCORElists_USCOREresult(struct soap *soap, const struct ns1__get_USCOREsubscription_USCORElists_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTonewsletter_USCORElist(soap, &a->unsubscribed);
	soap_serialize_PointerTonewsletter_USCORElist(soap, &a->subscribed);
	soap_serialize_PointerTons1__error_USCOREvalue(soap, &a->error);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREsubscription_USCORElists_USCOREresult(struct soap *soap, const struct ns1__get_USCOREsubscription_USCORElists_USCOREresult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREsubscription_USCORElists_USCOREresult);
	if (soap_out_ns1__get_USCOREsubscription_USCORElists_USCOREresult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREsubscription_USCORElists_USCOREresult(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREsubscription_USCORElists_USCOREresult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREsubscription_USCORElists_USCOREresult), type))
		return soap->error;
	if (soap_out_PointerTonewsletter_USCORElist(soap, "unsubscribed", -1, &a->unsubscribed, ""))
		return soap->error;
	if (soap_out_PointerTonewsletter_USCORElist(soap, "subscribed", -1, &a->subscribed, ""))
		return soap->error;
	if (soap_out_PointerTons1__error_USCOREvalue(soap, "error", -1, &a->error, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREsubscription_USCORElists_USCOREresult * SOAP_FMAC4 soap_get_ns1__get_USCOREsubscription_USCORElists_USCOREresult(struct soap *soap, struct ns1__get_USCOREsubscription_USCORElists_USCOREresult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREsubscription_USCORElists_USCOREresult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREsubscription_USCORElists_USCOREresult * SOAP_FMAC4 soap_in_ns1__get_USCOREsubscription_USCORElists_USCOREresult(struct soap *soap, const char *tag, struct ns1__get_USCOREsubscription_USCORElists_USCOREresult *a, const char *type)
{
	short soap_flag_unsubscribed = 1, soap_flag_subscribed = 1, soap_flag_error = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREsubscription_USCORElists_USCOREresult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREsubscription_USCORElists_USCOREresult, sizeof(struct ns1__get_USCOREsubscription_USCORElists_USCOREresult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREsubscription_USCORElists_USCOREresult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_unsubscribed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTonewsletter_USCORElist(soap, "unsubscribed", &a->unsubscribed, "ns1:newsletter"))
				{	soap_flag_unsubscribed--;
					continue;
				}
			if (soap_flag_subscribed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTonewsletter_USCORElist(soap, "subscribed", &a->subscribed, "ns1:newsletter"))
				{	soap_flag_subscribed--;
					continue;
				}
			if (soap_flag_error && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__error_USCOREvalue(soap, "error", &a->error, "ns1:error_value"))
				{	soap_flag_error--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREsubscription_USCORElists_USCOREresult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREsubscription_USCORElists_USCOREresult, 0, sizeof(struct ns1__get_USCOREsubscription_USCORElists_USCOREresult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_unsubscribed > 0 || soap_flag_subscribed > 0 || soap_flag_error > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__newsletter(struct soap *soap, struct ns1__newsletter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->name);
	soap_default_string(soap, &a->prospect_USCORElist_USCOREid);
	soap_default_string(soap, &a->campaign_USCOREid);
	soap_default_string(soap, &a->description);
	soap_default_string(soap, &a->frequency);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__newsletter(struct soap *soap, const struct ns1__newsletter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->name);
	soap_serialize_string(soap, &a->prospect_USCORElist_USCOREid);
	soap_serialize_string(soap, &a->campaign_USCOREid);
	soap_serialize_string(soap, &a->description);
	soap_serialize_string(soap, &a->frequency);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__newsletter(struct soap *soap, const struct ns1__newsletter *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__newsletter);
	if (soap_out_ns1__newsletter(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__newsletter(struct soap *soap, const char *tag, int id, const struct ns1__newsletter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__newsletter), type))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->name, ""))
		return soap->error;
	if (soap_out_string(soap, "prospect_list_id", -1, &a->prospect_USCORElist_USCOREid, ""))
		return soap->error;
	if (soap_out_string(soap, "campaign_id", -1, &a->campaign_USCOREid, ""))
		return soap->error;
	if (soap_out_string(soap, "description", -1, &a->description, ""))
		return soap->error;
	if (soap_out_string(soap, "frequency", -1, &a->frequency, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__newsletter * SOAP_FMAC4 soap_get_ns1__newsletter(struct soap *soap, struct ns1__newsletter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__newsletter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__newsletter * SOAP_FMAC4 soap_in_ns1__newsletter(struct soap *soap, const char *tag, struct ns1__newsletter *a, const char *type)
{
	short soap_flag_name = 1, soap_flag_prospect_USCORElist_USCOREid = 1, soap_flag_campaign_USCOREid = 1, soap_flag_description = 1, soap_flag_frequency = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__newsletter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__newsletter, sizeof(struct ns1__newsletter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__newsletter(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_prospect_USCORElist_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "prospect_list_id", &a->prospect_USCORElist_USCOREid, "xsd:string"))
				{	soap_flag_prospect_USCORElist_USCOREid--;
					continue;
				}
			if (soap_flag_campaign_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "campaign_id", &a->campaign_USCOREid, "xsd:string"))
				{	soap_flag_campaign_USCOREid--;
					continue;
				}
			if (soap_flag_description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "description", &a->description, "xsd:string"))
				{	soap_flag_description--;
					continue;
				}
			if (soap_flag_frequency && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "frequency", &a->frequency, "xsd:string"))
				{	soap_flag_frequency--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__newsletter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__newsletter, 0, sizeof(struct ns1__newsletter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name > 0 || soap_flag_prospect_USCORElist_USCOREid > 0 || soap_flag_campaign_USCOREid > 0 || soap_flag_description > 0 || soap_flag_frequency > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__name_USCOREvalue_USCOREoperator(struct soap *soap, struct ns1__name_USCOREvalue_USCOREoperator *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->name);
	soap_default_string(soap, &a->value);
	soap_default_string(soap, &a->operator_);
	a->value_USCOREarray = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__name_USCOREvalue_USCOREoperator(struct soap *soap, const struct ns1__name_USCOREvalue_USCOREoperator *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->name);
	soap_serialize_string(soap, &a->value);
	soap_serialize_string(soap, &a->operator_);
	soap_serialize_PointerToselect_USCOREfields(soap, &a->value_USCOREarray);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__name_USCOREvalue_USCOREoperator(struct soap *soap, const struct ns1__name_USCOREvalue_USCOREoperator *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__name_USCOREvalue_USCOREoperator);
	if (soap_out_ns1__name_USCOREvalue_USCOREoperator(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__name_USCOREvalue_USCOREoperator(struct soap *soap, const char *tag, int id, const struct ns1__name_USCOREvalue_USCOREoperator *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__name_USCOREvalue_USCOREoperator), type))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->name, ""))
		return soap->error;
	if (soap_out_string(soap, "value", -1, &a->value, ""))
		return soap->error;
	if (soap_out_string(soap, "operator", -1, &a->operator_, ""))
		return soap->error;
	if (soap_out_PointerToselect_USCOREfields(soap, "value_array", -1, &a->value_USCOREarray, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__name_USCOREvalue_USCOREoperator * SOAP_FMAC4 soap_get_ns1__name_USCOREvalue_USCOREoperator(struct soap *soap, struct ns1__name_USCOREvalue_USCOREoperator *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__name_USCOREvalue_USCOREoperator(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__name_USCOREvalue_USCOREoperator * SOAP_FMAC4 soap_in_ns1__name_USCOREvalue_USCOREoperator(struct soap *soap, const char *tag, struct ns1__name_USCOREvalue_USCOREoperator *a, const char *type)
{
	short soap_flag_name = 1, soap_flag_value = 1, soap_flag_operator_ = 1, soap_flag_value_USCOREarray = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__name_USCOREvalue_USCOREoperator *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__name_USCOREvalue_USCOREoperator, sizeof(struct ns1__name_USCOREvalue_USCOREoperator), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__name_USCOREvalue_USCOREoperator(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "value", &a->value, "xsd:string"))
				{	soap_flag_value--;
					continue;
				}
			if (soap_flag_operator_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "operator", &a->operator_, "xsd:string"))
				{	soap_flag_operator_--;
					continue;
				}
			if (soap_flag_value_USCOREarray && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToselect_USCOREfields(soap, "value_array", &a->value_USCOREarray, "xsd:string"))
				{	soap_flag_value_USCOREarray--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__name_USCOREvalue_USCOREoperator *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__name_USCOREvalue_USCOREoperator, 0, sizeof(struct ns1__name_USCOREvalue_USCOREoperator), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name > 0 || soap_flag_value > 0 || soap_flag_operator_ > 0 || soap_flag_value_USCOREarray > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__new_USCOREreturn_USCOREdocument_USCORErevision(struct soap *soap, struct ns1__new_USCOREreturn_USCOREdocument_USCORErevision *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->document_USCORErevision = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__new_USCOREreturn_USCOREdocument_USCORErevision(struct soap *soap, const struct ns1__new_USCOREreturn_USCOREdocument_USCORErevision *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__document_USCORErevision(soap, &a->document_USCORErevision);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__new_USCOREreturn_USCOREdocument_USCORErevision(struct soap *soap, const struct ns1__new_USCOREreturn_USCOREdocument_USCORErevision *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__new_USCOREreturn_USCOREdocument_USCORErevision);
	if (soap_out_ns1__new_USCOREreturn_USCOREdocument_USCORErevision(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__new_USCOREreturn_USCOREdocument_USCORErevision(struct soap *soap, const char *tag, int id, const struct ns1__new_USCOREreturn_USCOREdocument_USCORErevision *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__new_USCOREreturn_USCOREdocument_USCORErevision), type))
		return soap->error;
	if (soap_out_PointerTons1__document_USCORErevision(soap, "document_revision", -1, &a->document_USCORErevision, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__new_USCOREreturn_USCOREdocument_USCORErevision * SOAP_FMAC4 soap_get_ns1__new_USCOREreturn_USCOREdocument_USCORErevision(struct soap *soap, struct ns1__new_USCOREreturn_USCOREdocument_USCORErevision *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__new_USCOREreturn_USCOREdocument_USCORErevision(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__new_USCOREreturn_USCOREdocument_USCORErevision * SOAP_FMAC4 soap_in_ns1__new_USCOREreturn_USCOREdocument_USCORErevision(struct soap *soap, const char *tag, struct ns1__new_USCOREreturn_USCOREdocument_USCORErevision *a, const char *type)
{
	short soap_flag_document_USCORErevision = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__new_USCOREreturn_USCOREdocument_USCORErevision *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__new_USCOREreturn_USCOREdocument_USCORErevision, sizeof(struct ns1__new_USCOREreturn_USCOREdocument_USCORErevision), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__new_USCOREreturn_USCOREdocument_USCORErevision(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_document_USCORErevision && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__document_USCORErevision(soap, "document_revision", &a->document_USCORErevision, "ns1:document_revision"))
				{	soap_flag_document_USCORErevision--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__new_USCOREreturn_USCOREdocument_USCORErevision *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__new_USCOREreturn_USCOREdocument_USCORErevision, 0, sizeof(struct ns1__new_USCOREreturn_USCOREdocument_USCORErevision), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_document_USCORErevision > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__return_USCOREdocument_USCORErevision(struct soap *soap, struct ns1__return_USCOREdocument_USCORErevision *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->document_USCORErevision = NULL;
	a->error = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__return_USCOREdocument_USCORErevision(struct soap *soap, const struct ns1__return_USCOREdocument_USCORErevision *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__document_USCORErevision(soap, &a->document_USCORErevision);
	soap_serialize_PointerTons1__error_USCOREvalue(soap, &a->error);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__return_USCOREdocument_USCORErevision(struct soap *soap, const struct ns1__return_USCOREdocument_USCORErevision *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__return_USCOREdocument_USCORErevision);
	if (soap_out_ns1__return_USCOREdocument_USCORErevision(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__return_USCOREdocument_USCORErevision(struct soap *soap, const char *tag, int id, const struct ns1__return_USCOREdocument_USCORErevision *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__return_USCOREdocument_USCORErevision), type))
		return soap->error;
	if (soap_out_PointerTons1__document_USCORErevision(soap, "document_revision", -1, &a->document_USCORErevision, ""))
		return soap->error;
	if (soap_out_PointerTons1__error_USCOREvalue(soap, "error", -1, &a->error, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__return_USCOREdocument_USCORErevision * SOAP_FMAC4 soap_get_ns1__return_USCOREdocument_USCORErevision(struct soap *soap, struct ns1__return_USCOREdocument_USCORErevision *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__return_USCOREdocument_USCORErevision(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__return_USCOREdocument_USCORErevision * SOAP_FMAC4 soap_in_ns1__return_USCOREdocument_USCORErevision(struct soap *soap, const char *tag, struct ns1__return_USCOREdocument_USCORErevision *a, const char *type)
{
	short soap_flag_document_USCORErevision = 1, soap_flag_error = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__return_USCOREdocument_USCORErevision *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__return_USCOREdocument_USCORErevision, sizeof(struct ns1__return_USCOREdocument_USCORErevision), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__return_USCOREdocument_USCORErevision(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_document_USCORErevision && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__document_USCORErevision(soap, "document_revision", &a->document_USCORErevision, "ns1:document_revision"))
				{	soap_flag_document_USCORErevision--;
					continue;
				}
			if (soap_flag_error && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__error_USCOREvalue(soap, "error", &a->error, "ns1:error_value"))
				{	soap_flag_error--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__return_USCOREdocument_USCORErevision *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__return_USCOREdocument_USCORErevision, 0, sizeof(struct ns1__return_USCOREdocument_USCORErevision), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_document_USCORErevision > 0 || soap_flag_error > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREquick_USCOREsync_USCOREresult_USCOREencoded(struct soap *soap, struct ns1__get_USCOREquick_USCOREsync_USCOREresult_USCOREencoded *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->result);
	soap_default_int(soap, &a->result_USCOREcount);
	soap_default_int(soap, &a->next_USCOREoffset);
	soap_default_int(soap, &a->total_USCOREcount);
	a->error = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREquick_USCOREsync_USCOREresult_USCOREencoded(struct soap *soap, const struct ns1__get_USCOREquick_USCOREsync_USCOREresult_USCOREencoded *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->result);
	soap_embedded(soap, &a->result_USCOREcount, SOAP_TYPE_int);
	soap_embedded(soap, &a->next_USCOREoffset, SOAP_TYPE_int);
	soap_embedded(soap, &a->total_USCOREcount, SOAP_TYPE_int);
	soap_serialize_PointerTons1__error_USCOREvalue(soap, &a->error);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREquick_USCOREsync_USCOREresult_USCOREencoded(struct soap *soap, const struct ns1__get_USCOREquick_USCOREsync_USCOREresult_USCOREencoded *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREquick_USCOREsync_USCOREresult_USCOREencoded);
	if (soap_out_ns1__get_USCOREquick_USCOREsync_USCOREresult_USCOREencoded(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREquick_USCOREsync_USCOREresult_USCOREencoded(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREquick_USCOREsync_USCOREresult_USCOREencoded *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREquick_USCOREsync_USCOREresult_USCOREencoded), type))
		return soap->error;
	if (soap_out_string(soap, "result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_int(soap, "result_count", -1, &a->result_USCOREcount, ""))
		return soap->error;
	if (soap_out_int(soap, "next_offset", -1, &a->next_USCOREoffset, ""))
		return soap->error;
	if (soap_out_int(soap, "total_count", -1, &a->total_USCOREcount, ""))
		return soap->error;
	if (soap_out_PointerTons1__error_USCOREvalue(soap, "error", -1, &a->error, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREquick_USCOREsync_USCOREresult_USCOREencoded * SOAP_FMAC4 soap_get_ns1__get_USCOREquick_USCOREsync_USCOREresult_USCOREencoded(struct soap *soap, struct ns1__get_USCOREquick_USCOREsync_USCOREresult_USCOREencoded *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREquick_USCOREsync_USCOREresult_USCOREencoded(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREquick_USCOREsync_USCOREresult_USCOREencoded * SOAP_FMAC4 soap_in_ns1__get_USCOREquick_USCOREsync_USCOREresult_USCOREencoded(struct soap *soap, const char *tag, struct ns1__get_USCOREquick_USCOREsync_USCOREresult_USCOREencoded *a, const char *type)
{
	short soap_flag_result = 1, soap_flag_result_USCOREcount = 1, soap_flag_next_USCOREoffset = 1, soap_flag_total_USCOREcount = 1, soap_flag_error = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREquick_USCOREsync_USCOREresult_USCOREencoded *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREquick_USCOREsync_USCOREresult_USCOREencoded, sizeof(struct ns1__get_USCOREquick_USCOREsync_USCOREresult_USCOREencoded), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREquick_USCOREsync_USCOREresult_USCOREencoded(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_result_USCOREcount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result_count", &a->result_USCOREcount, "xsd:int"))
				{	soap_flag_result_USCOREcount--;
					continue;
				}
			if (soap_flag_next_USCOREoffset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "next_offset", &a->next_USCOREoffset, "xsd:int"))
				{	soap_flag_next_USCOREoffset--;
					continue;
				}
			if (soap_flag_total_USCOREcount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "total_count", &a->total_USCOREcount, "xsd:int"))
				{	soap_flag_total_USCOREcount--;
					continue;
				}
			if (soap_flag_error && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__error_USCOREvalue(soap, "error", &a->error, "ns1:error_value"))
				{	soap_flag_error--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREquick_USCOREsync_USCOREresult_USCOREencoded *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREquick_USCOREsync_USCOREresult_USCOREencoded, 0, sizeof(struct ns1__get_USCOREquick_USCOREsync_USCOREresult_USCOREencoded), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0 || soap_flag_result_USCOREcount > 0 || soap_flag_next_USCOREoffset > 0 || soap_flag_total_USCOREcount > 0 || soap_flag_error > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREsync_USCOREresult_USCOREencoded(struct soap *soap, struct ns1__get_USCOREsync_USCOREresult_USCOREencoded *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->result);
	a->error = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREsync_USCOREresult_USCOREencoded(struct soap *soap, const struct ns1__get_USCOREsync_USCOREresult_USCOREencoded *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->result);
	soap_serialize_PointerTons1__error_USCOREvalue(soap, &a->error);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREsync_USCOREresult_USCOREencoded(struct soap *soap, const struct ns1__get_USCOREsync_USCOREresult_USCOREencoded *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREsync_USCOREresult_USCOREencoded);
	if (soap_out_ns1__get_USCOREsync_USCOREresult_USCOREencoded(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREsync_USCOREresult_USCOREencoded(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREsync_USCOREresult_USCOREencoded *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREsync_USCOREresult_USCOREencoded), type))
		return soap->error;
	if (soap_out_string(soap, "result", -1, &a->result, ""))
		return soap->error;
	if (soap_out_PointerTons1__error_USCOREvalue(soap, "error", -1, &a->error, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREsync_USCOREresult_USCOREencoded * SOAP_FMAC4 soap_get_ns1__get_USCOREsync_USCOREresult_USCOREencoded(struct soap *soap, struct ns1__get_USCOREsync_USCOREresult_USCOREencoded *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREsync_USCOREresult_USCOREencoded(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREsync_USCOREresult_USCOREencoded * SOAP_FMAC4 soap_in_ns1__get_USCOREsync_USCOREresult_USCOREencoded(struct soap *soap, const char *tag, struct ns1__get_USCOREsync_USCOREresult_USCOREencoded *a, const char *type)
{
	short soap_flag_result = 1, soap_flag_error = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREsync_USCOREresult_USCOREencoded *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREsync_USCOREresult_USCOREencoded, sizeof(struct ns1__get_USCOREsync_USCOREresult_USCOREencoded), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREsync_USCOREresult_USCOREencoded(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap_flag_error && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__error_USCOREvalue(soap, "error", &a->error, "ns1:error_value"))
				{	soap_flag_error--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREsync_USCOREresult_USCOREencoded *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREsync_USCOREresult_USCOREencoded, 0, sizeof(struct ns1__get_USCOREsync_USCOREresult_USCOREencoded), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0 || soap_flag_error > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded(struct soap *soap, struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result_USCOREcount);
	soap_default_int(soap, &a->next_USCOREoffset);
	soap_default_int(soap, &a->total_USCOREcount);
	a->field_USCORElist = NULL;
	soap_default_string(soap, &a->entry_USCORElist);
	a->error = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded(struct soap *soap, const struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result_USCOREcount, SOAP_TYPE_int);
	soap_embedded(soap, &a->next_USCOREoffset, SOAP_TYPE_int);
	soap_embedded(soap, &a->total_USCOREcount, SOAP_TYPE_int);
	soap_serialize_PointerToselect_USCOREfields(soap, &a->field_USCORElist);
	soap_serialize_string(soap, &a->entry_USCORElist);
	soap_serialize_PointerTons1__error_USCOREvalue(soap, &a->error);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded(struct soap *soap, const struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded);
	if (soap_out_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded), type))
		return soap->error;
	if (soap_out_int(soap, "result_count", -1, &a->result_USCOREcount, ""))
		return soap->error;
	if (soap_out_int(soap, "next_offset", -1, &a->next_USCOREoffset, ""))
		return soap->error;
	if (soap_out_int(soap, "total_count", -1, &a->total_USCOREcount, ""))
		return soap->error;
	if (soap_out_PointerToselect_USCOREfields(soap, "field_list", -1, &a->field_USCORElist, ""))
		return soap->error;
	if (soap_out_string(soap, "entry_list", -1, &a->entry_USCORElist, ""))
		return soap->error;
	if (soap_out_PointerTons1__error_USCOREvalue(soap, "error", -1, &a->error, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded * SOAP_FMAC4 soap_get_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded(struct soap *soap, struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded * SOAP_FMAC4 soap_in_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded(struct soap *soap, const char *tag, struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded *a, const char *type)
{
	short soap_flag_result_USCOREcount = 1, soap_flag_next_USCOREoffset = 1, soap_flag_total_USCOREcount = 1, soap_flag_field_USCORElist = 1, soap_flag_entry_USCORElist = 1, soap_flag_error = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded, sizeof(struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result_USCOREcount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result_count", &a->result_USCOREcount, "xsd:int"))
				{	soap_flag_result_USCOREcount--;
					continue;
				}
			if (soap_flag_next_USCOREoffset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "next_offset", &a->next_USCOREoffset, "xsd:int"))
				{	soap_flag_next_USCOREoffset--;
					continue;
				}
			if (soap_flag_total_USCOREcount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "total_count", &a->total_USCOREcount, "xsd:int"))
				{	soap_flag_total_USCOREcount--;
					continue;
				}
			if (soap_flag_field_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToselect_USCOREfields(soap, "field_list", &a->field_USCORElist, "xsd:string"))
				{	soap_flag_field_USCORElist--;
					continue;
				}
			if (soap_flag_entry_USCORElist && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "entry_list", &a->entry_USCORElist, "xsd:string"))
				{	soap_flag_entry_USCORElist--;
					continue;
				}
			if (soap_flag_error && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__error_USCOREvalue(soap, "error", &a->error, "ns1:error_value"))
				{	soap_flag_error--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded, 0, sizeof(struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result_USCOREcount > 0 || soap_flag_next_USCOREoffset > 0 || soap_flag_total_USCOREcount > 0 || soap_flag_field_USCORElist > 0 || soap_flag_entry_USCORElist > 0 || soap_flag_error > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__document_USCORErevision(struct soap *soap, struct ns1__document_USCORErevision *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->id);
	soap_default_string(soap, &a->document_USCOREname);
	soap_default_string(soap, &a->revision);
	soap_default_string(soap, &a->filename);
	soap_default_string(soap, &a->file);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__document_USCORErevision(struct soap *soap, const struct ns1__document_USCORErevision *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->id);
	soap_serialize_string(soap, &a->document_USCOREname);
	soap_serialize_string(soap, &a->revision);
	soap_serialize_string(soap, &a->filename);
	soap_serialize_string(soap, &a->file);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__document_USCORErevision(struct soap *soap, const struct ns1__document_USCORErevision *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__document_USCORErevision);
	if (soap_out_ns1__document_USCORErevision(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__document_USCORErevision(struct soap *soap, const char *tag, int id, const struct ns1__document_USCORErevision *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__document_USCORErevision), type))
		return soap->error;
	if (soap_out_string(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_string(soap, "document_name", -1, &a->document_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "revision", -1, &a->revision, ""))
		return soap->error;
	if (soap_out_string(soap, "filename", -1, &a->filename, ""))
		return soap->error;
	if (soap_out_string(soap, "file", -1, &a->file, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__document_USCORErevision * SOAP_FMAC4 soap_get_ns1__document_USCORErevision(struct soap *soap, struct ns1__document_USCORErevision *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__document_USCORErevision(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__document_USCORErevision * SOAP_FMAC4 soap_in_ns1__document_USCORErevision(struct soap *soap, const char *tag, struct ns1__document_USCORErevision *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_document_USCOREname = 1, soap_flag_revision = 1, soap_flag_filename = 1, soap_flag_file = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__document_USCORErevision *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__document_USCORErevision, sizeof(struct ns1__document_USCORErevision), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__document_USCORErevision(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_document_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "document_name", &a->document_USCOREname, "xsd:string"))
				{	soap_flag_document_USCOREname--;
					continue;
				}
			if (soap_flag_revision && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "revision", &a->revision, "xsd:string"))
				{	soap_flag_revision--;
					continue;
				}
			if (soap_flag_filename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "filename", &a->filename, "xsd:string"))
				{	soap_flag_filename--;
					continue;
				}
			if (soap_flag_file && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "file", &a->file, "xsd:string"))
				{	soap_flag_file--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__document_USCORErevision *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__document_USCORErevision, 0, sizeof(struct ns1__document_USCORErevision), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0 || soap_flag_document_USCOREname > 0 || soap_flag_revision > 0 || soap_flag_filename > 0 || soap_flag_file > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__set_USCORErelationship_USCORElist_USCOREresult(struct soap *soap, struct ns1__set_USCORErelationship_USCORElist_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->created);
	soap_default_int(soap, &a->failed);
	a->error = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__set_USCORErelationship_USCORElist_USCOREresult(struct soap *soap, const struct ns1__set_USCORErelationship_USCORElist_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->created, SOAP_TYPE_int);
	soap_embedded(soap, &a->failed, SOAP_TYPE_int);
	soap_serialize_PointerTons1__error_USCOREvalue(soap, &a->error);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__set_USCORErelationship_USCORElist_USCOREresult(struct soap *soap, const struct ns1__set_USCORErelationship_USCORElist_USCOREresult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__set_USCORErelationship_USCORElist_USCOREresult);
	if (soap_out_ns1__set_USCORErelationship_USCORElist_USCOREresult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__set_USCORErelationship_USCORElist_USCOREresult(struct soap *soap, const char *tag, int id, const struct ns1__set_USCORErelationship_USCORElist_USCOREresult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__set_USCORErelationship_USCORElist_USCOREresult), type))
		return soap->error;
	if (soap_out_int(soap, "created", -1, &a->created, ""))
		return soap->error;
	if (soap_out_int(soap, "failed", -1, &a->failed, ""))
		return soap->error;
	if (soap_out_PointerTons1__error_USCOREvalue(soap, "error", -1, &a->error, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__set_USCORErelationship_USCORElist_USCOREresult * SOAP_FMAC4 soap_get_ns1__set_USCORErelationship_USCORElist_USCOREresult(struct soap *soap, struct ns1__set_USCORErelationship_USCORElist_USCOREresult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__set_USCORErelationship_USCORElist_USCOREresult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__set_USCORErelationship_USCORElist_USCOREresult * SOAP_FMAC4 soap_in_ns1__set_USCORErelationship_USCORElist_USCOREresult(struct soap *soap, const char *tag, struct ns1__set_USCORErelationship_USCORElist_USCOREresult *a, const char *type)
{
	short soap_flag_created = 1, soap_flag_failed = 1, soap_flag_error = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__set_USCORErelationship_USCORElist_USCOREresult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__set_USCORErelationship_USCORElist_USCOREresult, sizeof(struct ns1__set_USCORErelationship_USCORElist_USCOREresult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__set_USCORErelationship_USCORElist_USCOREresult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_created && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "created", &a->created, "xsd:int"))
				{	soap_flag_created--;
					continue;
				}
			if (soap_flag_failed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "failed", &a->failed, "xsd:int"))
				{	soap_flag_failed--;
					continue;
				}
			if (soap_flag_error && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__error_USCOREvalue(soap, "error", &a->error, "ns1:error_value"))
				{	soap_flag_error--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCORErelationship_USCORElist_USCOREresult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__set_USCORErelationship_USCORElist_USCOREresult, 0, sizeof(struct ns1__set_USCORErelationship_USCORElist_USCOREresult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_created > 0 || soap_flag_failed > 0 || soap_flag_error > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(struct soap *soap, struct ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->created);
	soap_default_int(soap, &a->failed);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(struct soap *soap, const struct ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->created, SOAP_TYPE_int);
	soap_embedded(soap, &a->failed, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(struct soap *soap, const struct ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult);
	if (soap_out_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(struct soap *soap, const char *tag, int id, const struct ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult), type))
		return soap->error;
	if (soap_out_int(soap, "created", -1, &a->created, ""))
		return soap->error;
	if (soap_out_int(soap, "failed", -1, &a->failed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult * SOAP_FMAC4 soap_get_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(struct soap *soap, struct ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult * SOAP_FMAC4 soap_in_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(struct soap *soap, const char *tag, struct ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult *a, const char *type)
{
	short soap_flag_created = 1, soap_flag_failed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult, sizeof(struct ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_created && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "created", &a->created, "xsd:int"))
				{	soap_flag_created--;
					continue;
				}
			if (soap_flag_failed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "failed", &a->failed, "xsd:int"))
				{	soap_flag_failed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult, 0, sizeof(struct ns1__new_USCOREset_USCORErelationship_USCORElist_USCOREresult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_created > 0 || soap_flag_failed > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__set_USCORErelationship_USCOREvalue(struct soap *soap, struct ns1__set_USCORErelationship_USCOREvalue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->module1);
	soap_default_string(soap, &a->module1_USCOREid);
	soap_default_string(soap, &a->module2);
	soap_default_string(soap, &a->module2_USCOREid);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__set_USCORErelationship_USCOREvalue(struct soap *soap, const struct ns1__set_USCORErelationship_USCOREvalue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->module1);
	soap_serialize_string(soap, &a->module1_USCOREid);
	soap_serialize_string(soap, &a->module2);
	soap_serialize_string(soap, &a->module2_USCOREid);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__set_USCORErelationship_USCOREvalue(struct soap *soap, const struct ns1__set_USCORErelationship_USCOREvalue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__set_USCORErelationship_USCOREvalue);
	if (soap_out_ns1__set_USCORErelationship_USCOREvalue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__set_USCORErelationship_USCOREvalue(struct soap *soap, const char *tag, int id, const struct ns1__set_USCORErelationship_USCOREvalue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__set_USCORErelationship_USCOREvalue), type))
		return soap->error;
	if (soap_out_string(soap, "module1", -1, &a->module1, ""))
		return soap->error;
	if (soap_out_string(soap, "module1_id", -1, &a->module1_USCOREid, ""))
		return soap->error;
	if (soap_out_string(soap, "module2", -1, &a->module2, ""))
		return soap->error;
	if (soap_out_string(soap, "module2_id", -1, &a->module2_USCOREid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__set_USCORErelationship_USCOREvalue * SOAP_FMAC4 soap_get_ns1__set_USCORErelationship_USCOREvalue(struct soap *soap, struct ns1__set_USCORErelationship_USCOREvalue *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__set_USCORErelationship_USCOREvalue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__set_USCORErelationship_USCOREvalue * SOAP_FMAC4 soap_in_ns1__set_USCORErelationship_USCOREvalue(struct soap *soap, const char *tag, struct ns1__set_USCORErelationship_USCOREvalue *a, const char *type)
{
	short soap_flag_module1 = 1, soap_flag_module1_USCOREid = 1, soap_flag_module2 = 1, soap_flag_module2_USCOREid = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__set_USCORErelationship_USCOREvalue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__set_USCORErelationship_USCOREvalue, sizeof(struct ns1__set_USCORErelationship_USCOREvalue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__set_USCORErelationship_USCOREvalue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_module1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module1", &a->module1, "xsd:string"))
				{	soap_flag_module1--;
					continue;
				}
			if (soap_flag_module1_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module1_id", &a->module1_USCOREid, "xsd:string"))
				{	soap_flag_module1_USCOREid--;
					continue;
				}
			if (soap_flag_module2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module2", &a->module2, "xsd:string"))
				{	soap_flag_module2--;
					continue;
				}
			if (soap_flag_module2_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module2_id", &a->module2_USCOREid, "xsd:string"))
				{	soap_flag_module2_USCOREid--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCORErelationship_USCOREvalue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__set_USCORErelationship_USCOREvalue, 0, sizeof(struct ns1__set_USCORErelationship_USCOREvalue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_module1 > 0 || soap_flag_module1_USCOREid > 0 || soap_flag_module2 > 0 || soap_flag_module2_USCOREid > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ids_USCOREmods(struct soap *soap, struct ids_USCOREmods *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ids_USCOREmods(struct soap *soap, struct ids_USCOREmods const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ids_USCOREmods))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__id_USCOREmod(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ids_USCOREmods(struct soap *soap, const struct ids_USCOREmods *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ids_USCOREmods);
	if (soap_out_ids_USCOREmods(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ids_USCOREmods(struct soap *soap, const char *tag, int id, const struct ids_USCOREmods *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:id_mod", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ids_USCOREmods);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__id_USCOREmod(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ids_USCOREmods * SOAP_FMAC4 soap_get_ids_USCOREmods(struct soap *soap, struct ids_USCOREmods *p, const char *tag, const char *type)
{
	if ((p = soap_in_ids_USCOREmods(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ids_USCOREmods * SOAP_FMAC4 soap_in_ids_USCOREmods(struct soap *soap, const char *tag, struct ids_USCOREmods *a, const char *type)
{	int i, j;
	struct ns1__id_USCOREmod **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ids_USCOREmods *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ids_USCOREmods, sizeof(struct ids_USCOREmods), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ids_USCOREmods(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__id_USCOREmod **)soap_malloc(soap, sizeof(struct ns1__id_USCOREmod *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__id_USCOREmod(soap, NULL, a->__ptr + i, "ns1:id_mod"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__id_USCOREmod **)soap_push_block(soap, sizeof(struct ns1__id_USCOREmod *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__id_USCOREmod(soap, NULL, p, "ns1:id_mod"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (struct ns1__id_USCOREmod **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ids_USCOREmods *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ids_USCOREmods, 0, sizeof(struct ids_USCOREmods), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCORErelationships_USCOREresult(struct soap *soap, struct ns1__get_USCORErelationships_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ids = NULL;
	a->error = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCORErelationships_USCOREresult(struct soap *soap, const struct ns1__get_USCORErelationships_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToids_USCOREmods(soap, &a->ids);
	soap_serialize_PointerTons1__error_USCOREvalue(soap, &a->error);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCORErelationships_USCOREresult(struct soap *soap, const struct ns1__get_USCORErelationships_USCOREresult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCORErelationships_USCOREresult);
	if (soap_out_ns1__get_USCORErelationships_USCOREresult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCORErelationships_USCOREresult(struct soap *soap, const char *tag, int id, const struct ns1__get_USCORErelationships_USCOREresult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCORErelationships_USCOREresult), type))
		return soap->error;
	if (soap_out_PointerToids_USCOREmods(soap, "ids", -1, &a->ids, ""))
		return soap->error;
	if (soap_out_PointerTons1__error_USCOREvalue(soap, "error", -1, &a->error, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCORErelationships_USCOREresult * SOAP_FMAC4 soap_get_ns1__get_USCORErelationships_USCOREresult(struct soap *soap, struct ns1__get_USCORErelationships_USCOREresult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCORErelationships_USCOREresult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCORErelationships_USCOREresult * SOAP_FMAC4 soap_in_ns1__get_USCORErelationships_USCOREresult(struct soap *soap, const char *tag, struct ns1__get_USCORErelationships_USCOREresult *a, const char *type)
{
	short soap_flag_ids = 1, soap_flag_error = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCORErelationships_USCOREresult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCORErelationships_USCOREresult, sizeof(struct ns1__get_USCORErelationships_USCOREresult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCORErelationships_USCOREresult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ids && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToids_USCOREmods(soap, "ids", &a->ids, "ns1:id_mod"))
				{	soap_flag_ids--;
					continue;
				}
			if (soap_flag_error && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__error_USCOREvalue(soap, "error", &a->error, "ns1:error_value"))
				{	soap_flag_error--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCORErelationships_USCOREresult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCORErelationships_USCOREresult, 0, sizeof(struct ns1__get_USCORErelationships_USCOREresult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ids > 0 || soap_flag_error > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__id_USCOREmod(struct soap *soap, struct ns1__id_USCOREmod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->id);
	soap_default_string(soap, &a->date_USCOREmodified);
	soap_default_int(soap, &a->deleted);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__id_USCOREmod(struct soap *soap, const struct ns1__id_USCOREmod *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->id);
	soap_serialize_string(soap, &a->date_USCOREmodified);
	soap_embedded(soap, &a->deleted, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__id_USCOREmod(struct soap *soap, const struct ns1__id_USCOREmod *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__id_USCOREmod);
	if (soap_out_ns1__id_USCOREmod(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__id_USCOREmod(struct soap *soap, const char *tag, int id, const struct ns1__id_USCOREmod *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__id_USCOREmod), type))
		return soap->error;
	if (soap_out_string(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_string(soap, "date_modified", -1, &a->date_USCOREmodified, ""))
		return soap->error;
	if (soap_out_int(soap, "deleted", -1, &a->deleted, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__id_USCOREmod * SOAP_FMAC4 soap_get_ns1__id_USCOREmod(struct soap *soap, struct ns1__id_USCOREmod *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__id_USCOREmod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__id_USCOREmod * SOAP_FMAC4 soap_in_ns1__id_USCOREmod(struct soap *soap, const char *tag, struct ns1__id_USCOREmod *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_date_USCOREmodified = 1, soap_flag_deleted = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__id_USCOREmod *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__id_USCOREmod, sizeof(struct ns1__id_USCOREmod), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__id_USCOREmod(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_date_USCOREmodified && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "date_modified", &a->date_USCOREmodified, "xsd:string"))
				{	soap_flag_date_USCOREmodified--;
					continue;
				}
			if (soap_flag_deleted && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "deleted", &a->deleted, "xsd:int"))
				{	soap_flag_deleted--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__id_USCOREmod *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__id_USCOREmod, 0, sizeof(struct ns1__id_USCOREmod), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0 || soap_flag_date_USCOREmodified > 0 || soap_flag_deleted > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__set_USCOREentries_USCOREresult(struct soap *soap, struct ns1__set_USCOREentries_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ids = NULL;
	a->error = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__set_USCOREentries_USCOREresult(struct soap *soap, const struct ns1__set_USCOREentries_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToselect_USCOREfields(soap, &a->ids);
	soap_serialize_PointerTons1__error_USCOREvalue(soap, &a->error);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__set_USCOREentries_USCOREresult(struct soap *soap, const struct ns1__set_USCOREentries_USCOREresult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__set_USCOREentries_USCOREresult);
	if (soap_out_ns1__set_USCOREentries_USCOREresult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__set_USCOREentries_USCOREresult(struct soap *soap, const char *tag, int id, const struct ns1__set_USCOREentries_USCOREresult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__set_USCOREentries_USCOREresult), type))
		return soap->error;
	if (soap_out_PointerToselect_USCOREfields(soap, "ids", -1, &a->ids, ""))
		return soap->error;
	if (soap_out_PointerTons1__error_USCOREvalue(soap, "error", -1, &a->error, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__set_USCOREentries_USCOREresult * SOAP_FMAC4 soap_get_ns1__set_USCOREentries_USCOREresult(struct soap *soap, struct ns1__set_USCOREentries_USCOREresult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__set_USCOREentries_USCOREresult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__set_USCOREentries_USCOREresult * SOAP_FMAC4 soap_in_ns1__set_USCOREentries_USCOREresult(struct soap *soap, const char *tag, struct ns1__set_USCOREentries_USCOREresult *a, const char *type)
{
	short soap_flag_ids = 1, soap_flag_error = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__set_USCOREentries_USCOREresult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__set_USCOREentries_USCOREresult, sizeof(struct ns1__set_USCOREentries_USCOREresult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__set_USCOREentries_USCOREresult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ids && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToselect_USCOREfields(soap, "ids", &a->ids, "xsd:string"))
				{	soap_flag_ids--;
					continue;
				}
			if (soap_flag_error && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__error_USCOREvalue(soap, "error", &a->error, "ns1:error_value"))
				{	soap_flag_error--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCOREentries_USCOREresult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__set_USCOREentries_USCOREresult, 0, sizeof(struct ns1__set_USCOREentries_USCOREresult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ids > 0 || soap_flag_error > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__new_USCOREset_USCOREentries_USCOREresult(struct soap *soap, struct ns1__new_USCOREset_USCOREentries_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ids = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__new_USCOREset_USCOREentries_USCOREresult(struct soap *soap, const struct ns1__new_USCOREset_USCOREentries_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToselect_USCOREfields(soap, &a->ids);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__new_USCOREset_USCOREentries_USCOREresult(struct soap *soap, const struct ns1__new_USCOREset_USCOREentries_USCOREresult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__new_USCOREset_USCOREentries_USCOREresult);
	if (soap_out_ns1__new_USCOREset_USCOREentries_USCOREresult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__new_USCOREset_USCOREentries_USCOREresult(struct soap *soap, const char *tag, int id, const struct ns1__new_USCOREset_USCOREentries_USCOREresult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__new_USCOREset_USCOREentries_USCOREresult), type))
		return soap->error;
	if (soap_out_PointerToselect_USCOREfields(soap, "ids", -1, &a->ids, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__new_USCOREset_USCOREentries_USCOREresult * SOAP_FMAC4 soap_get_ns1__new_USCOREset_USCOREentries_USCOREresult(struct soap *soap, struct ns1__new_USCOREset_USCOREentries_USCOREresult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__new_USCOREset_USCOREentries_USCOREresult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__new_USCOREset_USCOREentries_USCOREresult * SOAP_FMAC4 soap_in_ns1__new_USCOREset_USCOREentries_USCOREresult(struct soap *soap, const char *tag, struct ns1__new_USCOREset_USCOREentries_USCOREresult *a, const char *type)
{
	short soap_flag_ids = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__new_USCOREset_USCOREentries_USCOREresult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__new_USCOREset_USCOREentries_USCOREresult, sizeof(struct ns1__new_USCOREset_USCOREentries_USCOREresult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__new_USCOREset_USCOREentries_USCOREresult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ids && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToselect_USCOREfields(soap, "ids", &a->ids, "xsd:string"))
				{	soap_flag_ids--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__new_USCOREset_USCOREentries_USCOREresult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__new_USCOREset_USCOREentries_USCOREresult, 0, sizeof(struct ns1__new_USCOREset_USCOREentries_USCOREresult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ids > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__new_USCOREset_USCOREentry_USCOREresult(struct soap *soap, struct ns1__new_USCOREset_USCOREentry_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__new_USCOREset_USCOREentry_USCOREresult(struct soap *soap, const struct ns1__new_USCOREset_USCOREentry_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->id);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__new_USCOREset_USCOREentry_USCOREresult(struct soap *soap, const struct ns1__new_USCOREset_USCOREentry_USCOREresult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__new_USCOREset_USCOREentry_USCOREresult);
	if (soap_out_ns1__new_USCOREset_USCOREentry_USCOREresult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__new_USCOREset_USCOREentry_USCOREresult(struct soap *soap, const char *tag, int id, const struct ns1__new_USCOREset_USCOREentry_USCOREresult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__new_USCOREset_USCOREentry_USCOREresult), type))
		return soap->error;
	if (soap_out_string(soap, "id", -1, &a->id, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__new_USCOREset_USCOREentry_USCOREresult * SOAP_FMAC4 soap_get_ns1__new_USCOREset_USCOREentry_USCOREresult(struct soap *soap, struct ns1__new_USCOREset_USCOREentry_USCOREresult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__new_USCOREset_USCOREentry_USCOREresult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__new_USCOREset_USCOREentry_USCOREresult * SOAP_FMAC4 soap_in_ns1__new_USCOREset_USCOREentry_USCOREresult(struct soap *soap, const char *tag, struct ns1__new_USCOREset_USCOREentry_USCOREresult *a, const char *type)
{
	short soap_flag_id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__new_USCOREset_USCOREentry_USCOREresult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__new_USCOREset_USCOREentry_USCOREresult, sizeof(struct ns1__new_USCOREset_USCOREentry_USCOREresult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__new_USCOREset_USCOREentry_USCOREresult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__new_USCOREset_USCOREentry_USCOREresult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__new_USCOREset_USCOREentry_USCOREresult, 0, sizeof(struct ns1__new_USCOREset_USCOREentry_USCOREresult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__set_USCOREentry_USCOREresult(struct soap *soap, struct ns1__set_USCOREentry_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->id);
	a->error = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__set_USCOREentry_USCOREresult(struct soap *soap, const struct ns1__set_USCOREentry_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->id);
	soap_serialize_PointerTons1__error_USCOREvalue(soap, &a->error);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__set_USCOREentry_USCOREresult(struct soap *soap, const struct ns1__set_USCOREentry_USCOREresult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__set_USCOREentry_USCOREresult);
	if (soap_out_ns1__set_USCOREentry_USCOREresult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__set_USCOREentry_USCOREresult(struct soap *soap, const char *tag, int id, const struct ns1__set_USCOREentry_USCOREresult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__set_USCOREentry_USCOREresult), type))
		return soap->error;
	if (soap_out_string(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_PointerTons1__error_USCOREvalue(soap, "error", -1, &a->error, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__set_USCOREentry_USCOREresult * SOAP_FMAC4 soap_get_ns1__set_USCOREentry_USCOREresult(struct soap *soap, struct ns1__set_USCOREentry_USCOREresult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__set_USCOREentry_USCOREresult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__set_USCOREentry_USCOREresult * SOAP_FMAC4 soap_in_ns1__set_USCOREentry_USCOREresult(struct soap *soap, const char *tag, struct ns1__set_USCOREentry_USCOREresult *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_error = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__set_USCOREentry_USCOREresult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__set_USCOREentry_USCOREresult, sizeof(struct ns1__set_USCOREentry_USCOREresult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__set_USCOREentry_USCOREresult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_error && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__error_USCOREvalue(soap, "error", &a->error, "ns1:error_value"))
				{	soap_flag_error--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCOREentry_USCOREresult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__set_USCOREentry_USCOREresult, 0, sizeof(struct ns1__set_USCOREentry_USCOREresult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0 || soap_flag_error > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREserver_USCOREinfo_USCOREresult(struct soap *soap, struct ns1__get_USCOREserver_USCOREinfo_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->flavor);
	soap_default_string(soap, &a->version);
	soap_default_string(soap, &a->gmt_USCOREtime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREserver_USCOREinfo_USCOREresult(struct soap *soap, const struct ns1__get_USCOREserver_USCOREinfo_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->flavor);
	soap_serialize_string(soap, &a->version);
	soap_serialize_string(soap, &a->gmt_USCOREtime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREserver_USCOREinfo_USCOREresult(struct soap *soap, const struct ns1__get_USCOREserver_USCOREinfo_USCOREresult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREserver_USCOREinfo_USCOREresult);
	if (soap_out_ns1__get_USCOREserver_USCOREinfo_USCOREresult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREserver_USCOREinfo_USCOREresult(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREserver_USCOREinfo_USCOREresult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREserver_USCOREinfo_USCOREresult), type))
		return soap->error;
	if (soap_out_string(soap, "flavor", -1, &a->flavor, ""))
		return soap->error;
	if (soap_out_string(soap, "version", -1, &a->version, ""))
		return soap->error;
	if (soap_out_string(soap, "gmt_time", -1, &a->gmt_USCOREtime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREserver_USCOREinfo_USCOREresult * SOAP_FMAC4 soap_get_ns1__get_USCOREserver_USCOREinfo_USCOREresult(struct soap *soap, struct ns1__get_USCOREserver_USCOREinfo_USCOREresult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREserver_USCOREinfo_USCOREresult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREserver_USCOREinfo_USCOREresult * SOAP_FMAC4 soap_in_ns1__get_USCOREserver_USCOREinfo_USCOREresult(struct soap *soap, const char *tag, struct ns1__get_USCOREserver_USCOREinfo_USCOREresult *a, const char *type)
{
	short soap_flag_flavor = 1, soap_flag_version = 1, soap_flag_gmt_USCOREtime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREserver_USCOREinfo_USCOREresult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREserver_USCOREinfo_USCOREresult, sizeof(struct ns1__get_USCOREserver_USCOREinfo_USCOREresult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREserver_USCOREinfo_USCOREresult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_flavor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "flavor", &a->flavor, "xsd:string"))
				{	soap_flag_flavor--;
					continue;
				}
			if (soap_flag_version && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "version", &a->version, "xsd:string"))
				{	soap_flag_version--;
					continue;
				}
			if (soap_flag_gmt_USCOREtime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "gmt_time", &a->gmt_USCOREtime, "xsd:string"))
				{	soap_flag_gmt_USCOREtime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREserver_USCOREinfo_USCOREresult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREserver_USCOREinfo_USCOREresult, 0, sizeof(struct ns1__get_USCOREserver_USCOREinfo_USCOREresult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_flavor > 0 || soap_flag_version > 0 || soap_flag_gmt_USCOREtime > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREentry_USCOREresult(struct soap *soap, struct ns1__get_USCOREentry_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->field_USCORElist = NULL;
	a->entry_USCORElist = NULL;
	a->error = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREentry_USCOREresult(struct soap *soap, const struct ns1__get_USCOREentry_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTofield_USCORElist(soap, &a->field_USCORElist);
	soap_serialize_PointerToentry_USCORElist(soap, &a->entry_USCORElist);
	soap_serialize_PointerTons1__error_USCOREvalue(soap, &a->error);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREentry_USCOREresult(struct soap *soap, const struct ns1__get_USCOREentry_USCOREresult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREentry_USCOREresult);
	if (soap_out_ns1__get_USCOREentry_USCOREresult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREentry_USCOREresult(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREentry_USCOREresult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREentry_USCOREresult), type))
		return soap->error;
	if (soap_out_PointerTofield_USCORElist(soap, "field_list", -1, &a->field_USCORElist, ""))
		return soap->error;
	if (soap_out_PointerToentry_USCORElist(soap, "entry_list", -1, &a->entry_USCORElist, ""))
		return soap->error;
	if (soap_out_PointerTons1__error_USCOREvalue(soap, "error", -1, &a->error, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREentry_USCOREresult * SOAP_FMAC4 soap_get_ns1__get_USCOREentry_USCOREresult(struct soap *soap, struct ns1__get_USCOREentry_USCOREresult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREentry_USCOREresult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREentry_USCOREresult * SOAP_FMAC4 soap_in_ns1__get_USCOREentry_USCOREresult(struct soap *soap, const char *tag, struct ns1__get_USCOREentry_USCOREresult *a, const char *type)
{
	short soap_flag_field_USCORElist = 1, soap_flag_entry_USCORElist = 1, soap_flag_error = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREentry_USCOREresult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREentry_USCOREresult, sizeof(struct ns1__get_USCOREentry_USCOREresult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREentry_USCOREresult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_field_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofield_USCORElist(soap, "field_list", &a->field_USCORElist, "ns1:field"))
				{	soap_flag_field_USCORElist--;
					continue;
				}
			if (soap_flag_entry_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToentry_USCORElist(soap, "entry_list", &a->entry_USCORElist, "ns1:entry_value"))
				{	soap_flag_entry_USCORElist--;
					continue;
				}
			if (soap_flag_error && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__error_USCOREvalue(soap, "error", &a->error, "ns1:error_value"))
				{	soap_flag_error--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREentry_USCOREresult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREentry_USCOREresult, 0, sizeof(struct ns1__get_USCOREentry_USCOREresult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_field_USCORElist > 0 || soap_flag_entry_USCORElist > 0 || soap_flag_error > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2(struct soap *soap, struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result_USCOREcount);
	soap_default_int(soap, &a->next_USCOREoffset);
	a->entry_USCORElist = NULL;
	a->relationship_USCORElist = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2(struct soap *soap, const struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result_USCOREcount, SOAP_TYPE_int);
	soap_embedded(soap, &a->next_USCOREoffset, SOAP_TYPE_int);
	soap_serialize_PointerToentry_USCORElist(soap, &a->entry_USCORElist);
	soap_serialize_PointerTolink_USCORElists(soap, &a->relationship_USCORElist);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2(struct soap *soap, const struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2);
	if (soap_out_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2), type))
		return soap->error;
	if (soap_out_int(soap, "result_count", -1, &a->result_USCOREcount, ""))
		return soap->error;
	if (soap_out_int(soap, "next_offset", -1, &a->next_USCOREoffset, ""))
		return soap->error;
	if (soap_out_PointerToentry_USCORElist(soap, "entry_list", -1, &a->entry_USCORElist, ""))
		return soap->error;
	if (soap_out_PointerTolink_USCORElists(soap, "relationship_list", -1, &a->relationship_USCORElist, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2 * SOAP_FMAC4 soap_get_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2(struct soap *soap, struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2 * SOAP_FMAC4 soap_in_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2(struct soap *soap, const char *tag, struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2 *a, const char *type)
{
	short soap_flag_result_USCOREcount = 1, soap_flag_next_USCOREoffset = 1, soap_flag_entry_USCORElist = 1, soap_flag_relationship_USCORElist = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2, sizeof(struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result_USCOREcount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result_count", &a->result_USCOREcount, "xsd:int"))
				{	soap_flag_result_USCOREcount--;
					continue;
				}
			if (soap_flag_next_USCOREoffset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "next_offset", &a->next_USCOREoffset, "xsd:int"))
				{	soap_flag_next_USCOREoffset--;
					continue;
				}
			if (soap_flag_entry_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToentry_USCORElist(soap, "entry_list", &a->entry_USCORElist, "ns1:entry_value"))
				{	soap_flag_entry_USCORElist--;
					continue;
				}
			if (soap_flag_relationship_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolink_USCORElists(soap, "relationship_list", &a->relationship_USCORElist, "ns1:link_name_value"))
				{	soap_flag_relationship_USCORElist--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2, 0, sizeof(struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREversion2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result_USCOREcount > 0 || soap_flag_next_USCOREoffset > 0 || soap_flag_entry_USCORElist > 0 || soap_flag_relationship_USCORElist > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREentry_USCORElist_USCOREresult(struct soap *soap, struct ns1__get_USCOREentry_USCORElist_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result_USCOREcount);
	soap_default_int(soap, &a->next_USCOREoffset);
	a->field_USCORElist = NULL;
	a->entry_USCORElist = NULL;
	a->error = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREentry_USCORElist_USCOREresult(struct soap *soap, const struct ns1__get_USCOREentry_USCORElist_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result_USCOREcount, SOAP_TYPE_int);
	soap_embedded(soap, &a->next_USCOREoffset, SOAP_TYPE_int);
	soap_serialize_PointerTofield_USCORElist(soap, &a->field_USCORElist);
	soap_serialize_PointerToentry_USCORElist(soap, &a->entry_USCORElist);
	soap_serialize_PointerTons1__error_USCOREvalue(soap, &a->error);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREentry_USCORElist_USCOREresult(struct soap *soap, const struct ns1__get_USCOREentry_USCORElist_USCOREresult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREentry_USCORElist_USCOREresult);
	if (soap_out_ns1__get_USCOREentry_USCORElist_USCOREresult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREentry_USCORElist_USCOREresult(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREentry_USCORElist_USCOREresult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREentry_USCORElist_USCOREresult), type))
		return soap->error;
	if (soap_out_int(soap, "result_count", -1, &a->result_USCOREcount, ""))
		return soap->error;
	if (soap_out_int(soap, "next_offset", -1, &a->next_USCOREoffset, ""))
		return soap->error;
	if (soap_out_PointerTofield_USCORElist(soap, "field_list", -1, &a->field_USCORElist, ""))
		return soap->error;
	if (soap_out_PointerToentry_USCORElist(soap, "entry_list", -1, &a->entry_USCORElist, ""))
		return soap->error;
	if (soap_out_PointerTons1__error_USCOREvalue(soap, "error", -1, &a->error, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREentry_USCORElist_USCOREresult * SOAP_FMAC4 soap_get_ns1__get_USCOREentry_USCORElist_USCOREresult(struct soap *soap, struct ns1__get_USCOREentry_USCORElist_USCOREresult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREentry_USCORElist_USCOREresult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREentry_USCORElist_USCOREresult * SOAP_FMAC4 soap_in_ns1__get_USCOREentry_USCORElist_USCOREresult(struct soap *soap, const char *tag, struct ns1__get_USCOREentry_USCORElist_USCOREresult *a, const char *type)
{
	short soap_flag_result_USCOREcount = 1, soap_flag_next_USCOREoffset = 1, soap_flag_field_USCORElist = 1, soap_flag_entry_USCORElist = 1, soap_flag_error = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREentry_USCORElist_USCOREresult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREentry_USCORElist_USCOREresult, sizeof(struct ns1__get_USCOREentry_USCORElist_USCOREresult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREentry_USCORElist_USCOREresult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result_USCOREcount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result_count", &a->result_USCOREcount, "xsd:int"))
				{	soap_flag_result_USCOREcount--;
					continue;
				}
			if (soap_flag_next_USCOREoffset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "next_offset", &a->next_USCOREoffset, "xsd:int"))
				{	soap_flag_next_USCOREoffset--;
					continue;
				}
			if (soap_flag_field_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofield_USCORElist(soap, "field_list", &a->field_USCORElist, "ns1:field"))
				{	soap_flag_field_USCORElist--;
					continue;
				}
			if (soap_flag_entry_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToentry_USCORElist(soap, "entry_list", &a->entry_USCORElist, "ns1:entry_value"))
				{	soap_flag_entry_USCORElist--;
					continue;
				}
			if (soap_flag_error && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__error_USCOREvalue(soap, "error", &a->error, "ns1:error_value"))
				{	soap_flag_error--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREentry_USCORElist_USCOREresult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREentry_USCORElist_USCOREresult, 0, sizeof(struct ns1__get_USCOREentry_USCORElist_USCOREresult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result_USCOREcount > 0 || soap_flag_next_USCOREoffset > 0 || soap_flag_field_USCORElist > 0 || soap_flag_entry_USCORElist > 0 || soap_flag_error > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_link_USCORElist(struct soap *soap, struct link_USCORElist *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_link_USCORElist(struct soap *soap, struct link_USCORElist const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_link_USCORElist))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__link_USCOREname_USCOREvalue(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_link_USCORElist(struct soap *soap, const struct link_USCORElist *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_link_USCORElist);
	if (soap_out_link_USCORElist(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_link_USCORElist(struct soap *soap, const char *tag, int id, const struct link_USCORElist *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:link_name_value", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_link_USCORElist);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__link_USCOREname_USCOREvalue(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct link_USCORElist * SOAP_FMAC4 soap_get_link_USCORElist(struct soap *soap, struct link_USCORElist *p, const char *tag, const char *type)
{
	if ((p = soap_in_link_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct link_USCORElist * SOAP_FMAC4 soap_in_link_USCORElist(struct soap *soap, const char *tag, struct link_USCORElist *a, const char *type)
{	int i, j;
	struct ns1__link_USCOREname_USCOREvalue **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct link_USCORElist *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_link_USCORElist, sizeof(struct link_USCORElist), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_link_USCORElist(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__link_USCOREname_USCOREvalue **)soap_malloc(soap, sizeof(struct ns1__link_USCOREname_USCOREvalue *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__link_USCOREname_USCOREvalue(soap, NULL, a->__ptr + i, "ns1:link_name_value"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__link_USCOREname_USCOREvalue **)soap_push_block(soap, sizeof(struct ns1__link_USCOREname_USCOREvalue *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__link_USCOREname_USCOREvalue(soap, NULL, p, "ns1:link_name_value"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (struct ns1__link_USCOREname_USCOREvalue **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct link_USCORElist *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_link_USCORElist, 0, sizeof(struct link_USCORElist), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__return_USCOREsearch_USCOREresult(struct soap *soap, struct ns1__return_USCOREsearch_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->entry_USCORElist = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__return_USCOREsearch_USCOREresult(struct soap *soap, const struct ns1__return_USCOREsearch_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTolink_USCORElist(soap, &a->entry_USCORElist);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__return_USCOREsearch_USCOREresult(struct soap *soap, const struct ns1__return_USCOREsearch_USCOREresult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__return_USCOREsearch_USCOREresult);
	if (soap_out_ns1__return_USCOREsearch_USCOREresult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__return_USCOREsearch_USCOREresult(struct soap *soap, const char *tag, int id, const struct ns1__return_USCOREsearch_USCOREresult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__return_USCOREsearch_USCOREresult), type))
		return soap->error;
	if (soap_out_PointerTolink_USCORElist(soap, "entry_list", -1, &a->entry_USCORElist, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__return_USCOREsearch_USCOREresult * SOAP_FMAC4 soap_get_ns1__return_USCOREsearch_USCOREresult(struct soap *soap, struct ns1__return_USCOREsearch_USCOREresult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__return_USCOREsearch_USCOREresult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__return_USCOREsearch_USCOREresult * SOAP_FMAC4 soap_in_ns1__return_USCOREsearch_USCOREresult(struct soap *soap, const char *tag, struct ns1__return_USCOREsearch_USCOREresult *a, const char *type)
{
	short soap_flag_entry_USCORElist = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__return_USCOREsearch_USCOREresult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__return_USCOREsearch_USCOREresult, sizeof(struct ns1__return_USCOREsearch_USCOREresult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__return_USCOREsearch_USCOREresult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_entry_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolink_USCORElist(soap, "entry_list", &a->entry_USCORElist, "ns1:link_name_value"))
				{	soap_flag_entry_USCORElist--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__return_USCOREsearch_USCOREresult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__return_USCOREsearch_USCOREresult, 0, sizeof(struct ns1__return_USCOREsearch_USCOREresult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_entry_USCORElist > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_link_USCORElists(struct soap *soap, struct link_USCORElists *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_link_USCORElists(struct soap *soap, struct link_USCORElists const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_link_USCORElists))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTolink_USCORElist(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_link_USCORElists(struct soap *soap, const struct link_USCORElists *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_link_USCORElists);
	if (soap_out_link_USCORElists(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_link_USCORElists(struct soap *soap, const char *tag, int id, const struct link_USCORElists *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:link_name_value", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_link_USCORElists);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTolink_USCORElist(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct link_USCORElists * SOAP_FMAC4 soap_get_link_USCORElists(struct soap *soap, struct link_USCORElists *p, const char *tag, const char *type)
{
	if ((p = soap_in_link_USCORElists(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct link_USCORElists * SOAP_FMAC4 soap_in_link_USCORElists(struct soap *soap, const char *tag, struct link_USCORElists *a, const char *type)
{	int i, j;
	struct link_USCORElist **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct link_USCORElists *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_link_USCORElists, sizeof(struct link_USCORElists), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_link_USCORElists(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct link_USCORElist **)soap_malloc(soap, sizeof(struct link_USCORElist *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTolink_USCORElist(soap, NULL, a->__ptr + i, "ns1:link_name_value"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (struct link_USCORElist **)soap_push_block(soap, sizeof(struct link_USCORElist *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTolink_USCORElist(soap, NULL, p, "ns1:link_name_value"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (struct link_USCORElist **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct link_USCORElists *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_link_USCORElists, 0, sizeof(struct link_USCORElists), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_entry_USCORElist(struct soap *soap, struct entry_USCORElist *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_entry_USCORElist(struct soap *soap, struct entry_USCORElist const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_entry_USCORElist))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__entry_USCOREvalue(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_entry_USCORElist(struct soap *soap, const struct entry_USCORElist *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_entry_USCORElist);
	if (soap_out_entry_USCORElist(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_entry_USCORElist(struct soap *soap, const char *tag, int id, const struct entry_USCORElist *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:entry_value", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_entry_USCORElist);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__entry_USCOREvalue(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct entry_USCORElist * SOAP_FMAC4 soap_get_entry_USCORElist(struct soap *soap, struct entry_USCORElist *p, const char *tag, const char *type)
{
	if ((p = soap_in_entry_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct entry_USCORElist * SOAP_FMAC4 soap_in_entry_USCORElist(struct soap *soap, const char *tag, struct entry_USCORElist *a, const char *type)
{	int i, j;
	struct ns1__entry_USCOREvalue **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct entry_USCORElist *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_entry_USCORElist, sizeof(struct entry_USCORElist), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_entry_USCORElist(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__entry_USCOREvalue **)soap_malloc(soap, sizeof(struct ns1__entry_USCOREvalue *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__entry_USCOREvalue(soap, NULL, a->__ptr + i, "ns1:entry_value"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__entry_USCOREvalue **)soap_push_block(soap, sizeof(struct ns1__entry_USCOREvalue *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__entry_USCOREvalue(soap, NULL, p, "ns1:entry_value"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (struct ns1__entry_USCOREvalue **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct entry_USCORElist *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_entry_USCORElist, 0, sizeof(struct entry_USCORElist), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREentry_USCOREresult_USCOREversion2(struct soap *soap, struct ns1__get_USCOREentry_USCOREresult_USCOREversion2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->entry_USCORElist = NULL;
	a->relationship_USCORElist = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREentry_USCOREresult_USCOREversion2(struct soap *soap, const struct ns1__get_USCOREentry_USCOREresult_USCOREversion2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToentry_USCORElist(soap, &a->entry_USCORElist);
	soap_serialize_PointerTolink_USCORElists(soap, &a->relationship_USCORElist);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREentry_USCOREresult_USCOREversion2(struct soap *soap, const struct ns1__get_USCOREentry_USCOREresult_USCOREversion2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREentry_USCOREresult_USCOREversion2);
	if (soap_out_ns1__get_USCOREentry_USCOREresult_USCOREversion2(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREentry_USCOREresult_USCOREversion2(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREentry_USCOREresult_USCOREversion2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREentry_USCOREresult_USCOREversion2), type))
		return soap->error;
	if (soap_out_PointerToentry_USCORElist(soap, "entry_list", -1, &a->entry_USCORElist, ""))
		return soap->error;
	if (soap_out_PointerTolink_USCORElists(soap, "relationship_list", -1, &a->relationship_USCORElist, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREentry_USCOREresult_USCOREversion2 * SOAP_FMAC4 soap_get_ns1__get_USCOREentry_USCOREresult_USCOREversion2(struct soap *soap, struct ns1__get_USCOREentry_USCOREresult_USCOREversion2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREentry_USCOREresult_USCOREversion2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREentry_USCOREresult_USCOREversion2 * SOAP_FMAC4 soap_in_ns1__get_USCOREentry_USCOREresult_USCOREversion2(struct soap *soap, const char *tag, struct ns1__get_USCOREentry_USCOREresult_USCOREversion2 *a, const char *type)
{
	short soap_flag_entry_USCORElist = 1, soap_flag_relationship_USCORElist = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREentry_USCOREresult_USCOREversion2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREentry_USCOREresult_USCOREversion2, sizeof(struct ns1__get_USCOREentry_USCOREresult_USCOREversion2), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREentry_USCOREresult_USCOREversion2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_entry_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToentry_USCORElist(soap, "entry_list", &a->entry_USCORElist, "ns1:entry_value"))
				{	soap_flag_entry_USCORElist--;
					continue;
				}
			if (soap_flag_relationship_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolink_USCORElists(soap, "relationship_list", &a->relationship_USCORElist, "ns1:link_name_value"))
				{	soap_flag_relationship_USCORElist--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREentry_USCOREresult_USCOREversion2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREentry_USCOREresult_USCOREversion2, 0, sizeof(struct ns1__get_USCOREentry_USCOREresult_USCOREversion2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_entry_USCORElist > 0 || soap_flag_relationship_USCORElist > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_link_USCOREarray_USCORElist(struct soap *soap, struct link_USCOREarray_USCORElist *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_link_USCOREarray_USCORElist(struct soap *soap, struct link_USCOREarray_USCORElist const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_link_USCOREarray_USCORElist))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTolink_USCOREvalue(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_link_USCOREarray_USCORElist(struct soap *soap, const struct link_USCOREarray_USCORElist *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_link_USCOREarray_USCORElist);
	if (soap_out_link_USCOREarray_USCORElist(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_link_USCOREarray_USCORElist(struct soap *soap, const char *tag, int id, const struct link_USCOREarray_USCORElist *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:name_value", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_link_USCOREarray_USCORElist);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTolink_USCOREvalue(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct link_USCOREarray_USCORElist * SOAP_FMAC4 soap_get_link_USCOREarray_USCORElist(struct soap *soap, struct link_USCOREarray_USCORElist *p, const char *tag, const char *type)
{
	if ((p = soap_in_link_USCOREarray_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct link_USCOREarray_USCORElist * SOAP_FMAC4 soap_in_link_USCOREarray_USCORElist(struct soap *soap, const char *tag, struct link_USCOREarray_USCORElist *a, const char *type)
{	int i, j;
	struct link_USCOREvalue **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct link_USCOREarray_USCORElist *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_link_USCOREarray_USCORElist, sizeof(struct link_USCOREarray_USCORElist), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_link_USCOREarray_USCORElist(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct link_USCOREvalue **)soap_malloc(soap, sizeof(struct link_USCOREvalue *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTolink_USCOREvalue(soap, NULL, a->__ptr + i, "ns1:name_value"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (struct link_USCOREvalue **)soap_push_block(soap, sizeof(struct link_USCOREvalue *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTolink_USCOREvalue(soap, NULL, p, "ns1:name_value"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (struct link_USCOREvalue **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct link_USCOREarray_USCORElist *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_link_USCOREarray_USCORElist, 0, sizeof(struct link_USCOREarray_USCORElist), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__link_USCOREname_USCOREvalue(struct soap *soap, struct ns1__link_USCOREname_USCOREvalue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->name);
	a->records = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__link_USCOREname_USCOREvalue(struct soap *soap, const struct ns1__link_USCOREname_USCOREvalue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->name);
	soap_serialize_PointerTolink_USCOREarray_USCORElist(soap, &a->records);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__link_USCOREname_USCOREvalue(struct soap *soap, const struct ns1__link_USCOREname_USCOREvalue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__link_USCOREname_USCOREvalue);
	if (soap_out_ns1__link_USCOREname_USCOREvalue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__link_USCOREname_USCOREvalue(struct soap *soap, const char *tag, int id, const struct ns1__link_USCOREname_USCOREvalue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__link_USCOREname_USCOREvalue), type))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->name, ""))
		return soap->error;
	if (soap_out_PointerTolink_USCOREarray_USCORElist(soap, "records", -1, &a->records, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__link_USCOREname_USCOREvalue * SOAP_FMAC4 soap_get_ns1__link_USCOREname_USCOREvalue(struct soap *soap, struct ns1__link_USCOREname_USCOREvalue *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__link_USCOREname_USCOREvalue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__link_USCOREname_USCOREvalue * SOAP_FMAC4 soap_in_ns1__link_USCOREname_USCOREvalue(struct soap *soap, const char *tag, struct ns1__link_USCOREname_USCOREvalue *a, const char *type)
{
	short soap_flag_name = 1, soap_flag_records = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__link_USCOREname_USCOREvalue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__link_USCOREname_USCOREvalue, sizeof(struct ns1__link_USCOREname_USCOREvalue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__link_USCOREname_USCOREvalue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_records && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolink_USCOREarray_USCORElist(soap, "records", &a->records, "ns1:name_value"))
				{	soap_flag_records--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__link_USCOREname_USCOREvalue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__link_USCOREname_USCOREvalue, 0, sizeof(struct ns1__link_USCOREname_USCOREvalue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name > 0 || soap_flag_records > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(struct soap *soap, struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->name);
	a->value = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(struct soap *soap, const struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->name);
	soap_serialize_PointerToselect_USCOREfields(soap, &a->value);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(struct soap *soap, const struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray);
	if (soap_out_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(struct soap *soap, const char *tag, int id, const struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray), type))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->name, ""))
		return soap->error;
	if (soap_out_PointerToselect_USCOREfields(soap, "value", -1, &a->value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray * SOAP_FMAC4 soap_get_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(struct soap *soap, struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray * SOAP_FMAC4 soap_in_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(struct soap *soap, const char *tag, struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray *a, const char *type)
{
	short soap_flag_name = 1, soap_flag_value = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray, sizeof(struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToselect_USCOREfields(soap, "value", &a->value, "xsd:string"))
				{	soap_flag_value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray, 0, sizeof(struct ns1__link_USCOREname_USCOREto_USCOREfields_USCOREarray), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name > 0 || soap_flag_value > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult(struct soap *soap, struct ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->html);
	a->name_USCOREvalue_USCORElist = NULL;
	a->error = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult(struct soap *soap, const struct ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->html);
	soap_serialize_PointerToname_USCOREvalue_USCORElist(soap, &a->name_USCOREvalue_USCORElist);
	soap_serialize_PointerTons1__error_USCOREvalue(soap, &a->error);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult(struct soap *soap, const struct ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult);
	if (soap_out_ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult(struct soap *soap, const char *tag, int id, const struct ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult), type))
		return soap->error;
	if (soap_out_string(soap, "html", -1, &a->html, ""))
		return soap->error;
	if (soap_out_PointerToname_USCOREvalue_USCORElist(soap, "name_value_list", -1, &a->name_USCOREvalue_USCORElist, ""))
		return soap->error;
	if (soap_out_PointerTons1__error_USCOREvalue(soap, "error", -1, &a->error, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult * SOAP_FMAC4 soap_get_ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult(struct soap *soap, struct ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult * SOAP_FMAC4 soap_in_ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult(struct soap *soap, const char *tag, struct ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult *a, const char *type)
{
	short soap_flag_html = 1, soap_flag_name_USCOREvalue_USCORElist = 1, soap_flag_error = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult, sizeof(struct ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_html && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "html", &a->html, "xsd:string"))
				{	soap_flag_html--;
					continue;
				}
			if (soap_flag_name_USCOREvalue_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToname_USCOREvalue_USCORElist(soap, "name_value_list", &a->name_USCOREvalue_USCORElist, "ns1:name_value"))
				{	soap_flag_name_USCOREvalue_USCORElist--;
					continue;
				}
			if (soap_flag_error && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__error_USCOREvalue(soap, "error", &a->error, "ns1:error_value"))
				{	soap_flag_error--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult, 0, sizeof(struct ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_html > 0 || soap_flag_name_USCOREvalue_USCORElist > 0 || soap_flag_error > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__entry_USCOREvalue(struct soap *soap, struct ns1__entry_USCOREvalue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->id);
	soap_default_string(soap, &a->module_USCOREname);
	a->name_USCOREvalue_USCORElist = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__entry_USCOREvalue(struct soap *soap, const struct ns1__entry_USCOREvalue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->id);
	soap_serialize_string(soap, &a->module_USCOREname);
	soap_serialize_PointerToname_USCOREvalue_USCORElist(soap, &a->name_USCOREvalue_USCORElist);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__entry_USCOREvalue(struct soap *soap, const struct ns1__entry_USCOREvalue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__entry_USCOREvalue);
	if (soap_out_ns1__entry_USCOREvalue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__entry_USCOREvalue(struct soap *soap, const char *tag, int id, const struct ns1__entry_USCOREvalue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__entry_USCOREvalue), type))
		return soap->error;
	if (soap_out_string(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_string(soap, "module_name", -1, &a->module_USCOREname, ""))
		return soap->error;
	if (soap_out_PointerToname_USCOREvalue_USCORElist(soap, "name_value_list", -1, &a->name_USCOREvalue_USCORElist, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__entry_USCOREvalue * SOAP_FMAC4 soap_get_ns1__entry_USCOREvalue(struct soap *soap, struct ns1__entry_USCOREvalue *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__entry_USCOREvalue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__entry_USCOREvalue * SOAP_FMAC4 soap_in_ns1__entry_USCOREvalue(struct soap *soap, const char *tag, struct ns1__entry_USCOREvalue *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_module_USCOREname = 1, soap_flag_name_USCOREvalue_USCORElist = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__entry_USCOREvalue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__entry_USCOREvalue, sizeof(struct ns1__entry_USCOREvalue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__entry_USCOREvalue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_module_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module_name", &a->module_USCOREname, "xsd:string"))
				{	soap_flag_module_USCOREname--;
					continue;
				}
			if (soap_flag_name_USCOREvalue_USCORElist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToname_USCOREvalue_USCORElist(soap, "name_value_list", &a->name_USCOREvalue_USCORElist, "ns1:name_value"))
				{	soap_flag_name_USCOREvalue_USCORElist--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__entry_USCOREvalue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__entry_USCOREvalue, 0, sizeof(struct ns1__entry_USCOREvalue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0 || soap_flag_module_USCOREname > 0 || soap_flag_name_USCOREvalue_USCORElist > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_select_USCOREfields(struct soap *soap, struct select_USCOREfields *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_select_USCOREfields(struct soap *soap, struct select_USCOREfields const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_select_USCOREfields))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_string(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_select_USCOREfields(struct soap *soap, const struct select_USCOREfields *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_select_USCOREfields);
	if (soap_out_select_USCOREfields(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_select_USCOREfields(struct soap *soap, const char *tag, int id, const struct select_USCOREfields *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "xsd:string", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_select_USCOREfields);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_string(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct select_USCOREfields * SOAP_FMAC4 soap_get_select_USCOREfields(struct soap *soap, struct select_USCOREfields *p, const char *tag, const char *type)
{
	if ((p = soap_in_select_USCOREfields(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct select_USCOREfields * SOAP_FMAC4 soap_in_select_USCOREfields(struct soap *soap, const char *tag, struct select_USCOREfields *a, const char *type)
{	int i, j;
	char **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct select_USCOREfields *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_select_USCOREfields, sizeof(struct select_USCOREfields), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_select_USCOREfields(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (char **)soap_malloc(soap, sizeof(char *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_string(soap, NULL, a->__ptr + i, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (char **)soap_push_block(soap, sizeof(char *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_string(soap, NULL, p, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (char **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct select_USCOREfields *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_select_USCOREfields, 0, sizeof(struct select_USCOREfields), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__module_USCORElist(struct soap *soap, struct ns1__module_USCORElist *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->modules = NULL;
	a->error = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__module_USCORElist(struct soap *soap, const struct ns1__module_USCORElist *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToselect_USCOREfields(soap, &a->modules);
	soap_serialize_PointerTons1__error_USCOREvalue(soap, &a->error);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__module_USCORElist(struct soap *soap, const struct ns1__module_USCORElist *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__module_USCORElist);
	if (soap_out_ns1__module_USCORElist(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__module_USCORElist(struct soap *soap, const char *tag, int id, const struct ns1__module_USCORElist *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__module_USCORElist), type))
		return soap->error;
	if (soap_out_PointerToselect_USCOREfields(soap, "modules", -1, &a->modules, ""))
		return soap->error;
	if (soap_out_PointerTons1__error_USCOREvalue(soap, "error", -1, &a->error, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__module_USCORElist * SOAP_FMAC4 soap_get_ns1__module_USCORElist(struct soap *soap, struct ns1__module_USCORElist *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__module_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__module_USCORElist * SOAP_FMAC4 soap_in_ns1__module_USCORElist(struct soap *soap, const char *tag, struct ns1__module_USCORElist *a, const char *type)
{
	short soap_flag_modules = 1, soap_flag_error = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__module_USCORElist *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__module_USCORElist, sizeof(struct ns1__module_USCORElist), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__module_USCORElist(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_modules && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToselect_USCOREfields(soap, "modules", &a->modules, "xsd:string"))
				{	soap_flag_modules--;
					continue;
				}
			if (soap_flag_error && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__error_USCOREvalue(soap, "error", &a->error, "ns1:error_value"))
				{	soap_flag_error--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__module_USCORElist *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__module_USCORElist, 0, sizeof(struct ns1__module_USCORElist), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_modules > 0 || soap_flag_error > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_link_USCOREfield_USCORElist(struct soap *soap, struct link_USCOREfield_USCORElist *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_link_USCOREfield_USCORElist(struct soap *soap, struct link_USCOREfield_USCORElist const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_link_USCOREfield_USCORElist))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__link_USCOREfield(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_link_USCOREfield_USCORElist(struct soap *soap, const struct link_USCOREfield_USCORElist *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_link_USCOREfield_USCORElist);
	if (soap_out_link_USCOREfield_USCORElist(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_link_USCOREfield_USCORElist(struct soap *soap, const char *tag, int id, const struct link_USCOREfield_USCORElist *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:link_field", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_link_USCOREfield_USCORElist);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__link_USCOREfield(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct link_USCOREfield_USCORElist * SOAP_FMAC4 soap_get_link_USCOREfield_USCORElist(struct soap *soap, struct link_USCOREfield_USCORElist *p, const char *tag, const char *type)
{
	if ((p = soap_in_link_USCOREfield_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct link_USCOREfield_USCORElist * SOAP_FMAC4 soap_in_link_USCOREfield_USCORElist(struct soap *soap, const char *tag, struct link_USCOREfield_USCORElist *a, const char *type)
{	int i, j;
	struct ns1__link_USCOREfield **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct link_USCOREfield_USCORElist *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_link_USCOREfield_USCORElist, sizeof(struct link_USCOREfield_USCORElist), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_link_USCOREfield_USCORElist(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__link_USCOREfield **)soap_malloc(soap, sizeof(struct ns1__link_USCOREfield *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__link_USCOREfield(soap, NULL, a->__ptr + i, "ns1:link_field"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__link_USCOREfield **)soap_push_block(soap, sizeof(struct ns1__link_USCOREfield *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__link_USCOREfield(soap, NULL, p, "ns1:link_field"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (struct ns1__link_USCOREfield **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct link_USCOREfield_USCORElist *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_link_USCOREfield_USCORElist, 0, sizeof(struct link_USCOREfield_USCORElist), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__new_USCOREmodule_USCOREfields(struct soap *soap, struct ns1__new_USCOREmodule_USCOREfields *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->module_USCOREname);
	a->module_USCOREfields = NULL;
	a->link_USCOREfields = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__new_USCOREmodule_USCOREfields(struct soap *soap, const struct ns1__new_USCOREmodule_USCOREfields *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->module_USCOREname);
	soap_serialize_PointerTofield_USCORElist(soap, &a->module_USCOREfields);
	soap_serialize_PointerTolink_USCOREfield_USCORElist(soap, &a->link_USCOREfields);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__new_USCOREmodule_USCOREfields(struct soap *soap, const struct ns1__new_USCOREmodule_USCOREfields *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__new_USCOREmodule_USCOREfields);
	if (soap_out_ns1__new_USCOREmodule_USCOREfields(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__new_USCOREmodule_USCOREfields(struct soap *soap, const char *tag, int id, const struct ns1__new_USCOREmodule_USCOREfields *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__new_USCOREmodule_USCOREfields), type))
		return soap->error;
	if (soap_out_string(soap, "module_name", -1, &a->module_USCOREname, ""))
		return soap->error;
	if (soap_out_PointerTofield_USCORElist(soap, "module_fields", -1, &a->module_USCOREfields, ""))
		return soap->error;
	if (soap_out_PointerTolink_USCOREfield_USCORElist(soap, "link_fields", -1, &a->link_USCOREfields, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__new_USCOREmodule_USCOREfields * SOAP_FMAC4 soap_get_ns1__new_USCOREmodule_USCOREfields(struct soap *soap, struct ns1__new_USCOREmodule_USCOREfields *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__new_USCOREmodule_USCOREfields(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__new_USCOREmodule_USCOREfields * SOAP_FMAC4 soap_in_ns1__new_USCOREmodule_USCOREfields(struct soap *soap, const char *tag, struct ns1__new_USCOREmodule_USCOREfields *a, const char *type)
{
	short soap_flag_module_USCOREname = 1, soap_flag_module_USCOREfields = 1, soap_flag_link_USCOREfields = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__new_USCOREmodule_USCOREfields *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__new_USCOREmodule_USCOREfields, sizeof(struct ns1__new_USCOREmodule_USCOREfields), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__new_USCOREmodule_USCOREfields(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_module_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module_name", &a->module_USCOREname, "xsd:string"))
				{	soap_flag_module_USCOREname--;
					continue;
				}
			if (soap_flag_module_USCOREfields && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofield_USCORElist(soap, "module_fields", &a->module_USCOREfields, "ns1:field"))
				{	soap_flag_module_USCOREfields--;
					continue;
				}
			if (soap_flag_link_USCOREfields && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolink_USCOREfield_USCORElist(soap, "link_fields", &a->link_USCOREfields, "ns1:link_field"))
				{	soap_flag_link_USCOREfields--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__new_USCOREmodule_USCOREfields *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__new_USCOREmodule_USCOREfields, 0, sizeof(struct ns1__new_USCOREmodule_USCOREfields), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_module_USCOREname > 0 || soap_flag_module_USCOREfields > 0 || soap_flag_link_USCOREfields > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_field_USCORElist(struct soap *soap, struct field_USCORElist *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_field_USCORElist(struct soap *soap, struct field_USCORElist const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_field_USCORElist))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__field(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_field_USCORElist(struct soap *soap, const struct field_USCORElist *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_field_USCORElist);
	if (soap_out_field_USCORElist(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_field_USCORElist(struct soap *soap, const char *tag, int id, const struct field_USCORElist *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:field", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_field_USCORElist);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__field(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct field_USCORElist * SOAP_FMAC4 soap_get_field_USCORElist(struct soap *soap, struct field_USCORElist *p, const char *tag, const char *type)
{
	if ((p = soap_in_field_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct field_USCORElist * SOAP_FMAC4 soap_in_field_USCORElist(struct soap *soap, const char *tag, struct field_USCORElist *a, const char *type)
{	int i, j;
	struct ns1__field **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct field_USCORElist *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_field_USCORElist, sizeof(struct field_USCORElist), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_field_USCORElist(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__field **)soap_malloc(soap, sizeof(struct ns1__field *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__field(soap, NULL, a->__ptr + i, "ns1:field"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__field **)soap_push_block(soap, sizeof(struct ns1__field *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__field(soap, NULL, p, "ns1:field"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (struct ns1__field **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct field_USCORElist *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_field_USCORElist, 0, sizeof(struct field_USCORElist), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__module_USCOREfields(struct soap *soap, struct ns1__module_USCOREfields *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->module_USCOREname);
	a->module_USCOREfields = NULL;
	a->error = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__module_USCOREfields(struct soap *soap, const struct ns1__module_USCOREfields *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->module_USCOREname);
	soap_serialize_PointerTofield_USCORElist(soap, &a->module_USCOREfields);
	soap_serialize_PointerTons1__error_USCOREvalue(soap, &a->error);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__module_USCOREfields(struct soap *soap, const struct ns1__module_USCOREfields *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__module_USCOREfields);
	if (soap_out_ns1__module_USCOREfields(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__module_USCOREfields(struct soap *soap, const char *tag, int id, const struct ns1__module_USCOREfields *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__module_USCOREfields), type))
		return soap->error;
	if (soap_out_string(soap, "module_name", -1, &a->module_USCOREname, ""))
		return soap->error;
	if (soap_out_PointerTofield_USCORElist(soap, "module_fields", -1, &a->module_USCOREfields, ""))
		return soap->error;
	if (soap_out_PointerTons1__error_USCOREvalue(soap, "error", -1, &a->error, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__module_USCOREfields * SOAP_FMAC4 soap_get_ns1__module_USCOREfields(struct soap *soap, struct ns1__module_USCOREfields *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__module_USCOREfields(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__module_USCOREfields * SOAP_FMAC4 soap_in_ns1__module_USCOREfields(struct soap *soap, const char *tag, struct ns1__module_USCOREfields *a, const char *type)
{
	short soap_flag_module_USCOREname = 1, soap_flag_module_USCOREfields = 1, soap_flag_error = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__module_USCOREfields *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__module_USCOREfields, sizeof(struct ns1__module_USCOREfields), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__module_USCOREfields(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_module_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module_name", &a->module_USCOREname, "xsd:string"))
				{	soap_flag_module_USCOREname--;
					continue;
				}
			if (soap_flag_module_USCOREfields && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofield_USCORElist(soap, "module_fields", &a->module_USCOREfields, "ns1:field"))
				{	soap_flag_module_USCOREfields--;
					continue;
				}
			if (soap_flag_error && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__error_USCOREvalue(soap, "error", &a->error, "ns1:error_value"))
				{	soap_flag_error--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__module_USCOREfields *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__module_USCOREfields, 0, sizeof(struct ns1__module_USCOREfields), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_module_USCOREname > 0 || soap_flag_module_USCOREfields > 0 || soap_flag_error > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__name_USCOREvalue(struct soap *soap, struct ns1__name_USCOREvalue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->name);
	soap_default_string(soap, &a->value);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__name_USCOREvalue(struct soap *soap, const struct ns1__name_USCOREvalue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->name);
	soap_serialize_string(soap, &a->value);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__name_USCOREvalue(struct soap *soap, const struct ns1__name_USCOREvalue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__name_USCOREvalue);
	if (soap_out_ns1__name_USCOREvalue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__name_USCOREvalue(struct soap *soap, const char *tag, int id, const struct ns1__name_USCOREvalue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__name_USCOREvalue), type))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->name, ""))
		return soap->error;
	if (soap_out_string(soap, "value", -1, &a->value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__name_USCOREvalue * SOAP_FMAC4 soap_get_ns1__name_USCOREvalue(struct soap *soap, struct ns1__name_USCOREvalue *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__name_USCOREvalue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__name_USCOREvalue * SOAP_FMAC4 soap_in_ns1__name_USCOREvalue(struct soap *soap, const char *tag, struct ns1__name_USCOREvalue *a, const char *type)
{
	short soap_flag_name = 1, soap_flag_value = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__name_USCOREvalue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__name_USCOREvalue, sizeof(struct ns1__name_USCOREvalue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__name_USCOREvalue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "value", &a->value, "xsd:string"))
				{	soap_flag_value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__name_USCOREvalue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__name_USCOREvalue, 0, sizeof(struct ns1__name_USCOREvalue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name > 0 || soap_flag_value > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__link_USCOREfield(struct soap *soap, struct ns1__link_USCOREfield *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->name);
	soap_default_string(soap, &a->type);
	soap_default_string(soap, &a->relationship);
	soap_default_string(soap, &a->module);
	soap_default_string(soap, &a->bean_USCOREname);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__link_USCOREfield(struct soap *soap, const struct ns1__link_USCOREfield *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->name);
	soap_serialize_string(soap, &a->type);
	soap_serialize_string(soap, &a->relationship);
	soap_serialize_string(soap, &a->module);
	soap_serialize_string(soap, &a->bean_USCOREname);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__link_USCOREfield(struct soap *soap, const struct ns1__link_USCOREfield *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__link_USCOREfield);
	if (soap_out_ns1__link_USCOREfield(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__link_USCOREfield(struct soap *soap, const char *tag, int id, const struct ns1__link_USCOREfield *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__link_USCOREfield), type))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->name, ""))
		return soap->error;
	if (soap_out_string(soap, "type", -1, &a->type, ""))
		return soap->error;
	if (soap_out_string(soap, "relationship", -1, &a->relationship, ""))
		return soap->error;
	if (soap_out_string(soap, "module", -1, &a->module, ""))
		return soap->error;
	if (soap_out_string(soap, "bean_name", -1, &a->bean_USCOREname, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__link_USCOREfield * SOAP_FMAC4 soap_get_ns1__link_USCOREfield(struct soap *soap, struct ns1__link_USCOREfield *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__link_USCOREfield(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__link_USCOREfield * SOAP_FMAC4 soap_in_ns1__link_USCOREfield(struct soap *soap, const char *tag, struct ns1__link_USCOREfield *a, const char *type)
{
	short soap_flag_name = 1, soap_flag_type = 1, soap_flag_relationship = 1, soap_flag_module = 1, soap_flag_bean_USCOREname = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__link_USCOREfield *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__link_USCOREfield, sizeof(struct ns1__link_USCOREfield), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__link_USCOREfield(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_type && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "type", &a->type, "xsd:string"))
				{	soap_flag_type--;
					continue;
				}
			if (soap_flag_relationship && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "relationship", &a->relationship, "xsd:string"))
				{	soap_flag_relationship--;
					continue;
				}
			if (soap_flag_module && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "module", &a->module, "xsd:string"))
				{	soap_flag_module--;
					continue;
				}
			if (soap_flag_bean_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "bean_name", &a->bean_USCOREname, "xsd:string"))
				{	soap_flag_bean_USCOREname--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__link_USCOREfield *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__link_USCOREfield, 0, sizeof(struct ns1__link_USCOREfield), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name > 0 || soap_flag_type > 0 || soap_flag_relationship > 0 || soap_flag_module > 0 || soap_flag_bean_USCOREname > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_name_USCOREvalue_USCORElist(struct soap *soap, struct name_USCOREvalue_USCORElist *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_name_USCOREvalue_USCORElist(struct soap *soap, struct name_USCOREvalue_USCORElist const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_name_USCOREvalue_USCORElist))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_PointerTons1__name_USCOREvalue(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_name_USCOREvalue_USCORElist(struct soap *soap, const struct name_USCOREvalue_USCORElist *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_name_USCOREvalue_USCORElist);
	if (soap_out_name_USCOREvalue_USCORElist(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_name_USCOREvalue_USCORElist(struct soap *soap, const char *tag, int id, const struct name_USCOREvalue_USCORElist *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:name_value", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_name_USCOREvalue_USCORElist);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__name_USCOREvalue(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct name_USCOREvalue_USCORElist * SOAP_FMAC4 soap_get_name_USCOREvalue_USCORElist(struct soap *soap, struct name_USCOREvalue_USCORElist *p, const char *tag, const char *type)
{
	if ((p = soap_in_name_USCOREvalue_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct name_USCOREvalue_USCORElist * SOAP_FMAC4 soap_in_name_USCOREvalue_USCORElist(struct soap *soap, const char *tag, struct name_USCOREvalue_USCORElist *a, const char *type)
{	int i, j;
	struct ns1__name_USCOREvalue **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct name_USCOREvalue_USCORElist *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_name_USCOREvalue_USCORElist, sizeof(struct name_USCOREvalue_USCORElist), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_name_USCOREvalue_USCORElist(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns1__name_USCOREvalue **)soap_malloc(soap, sizeof(struct ns1__name_USCOREvalue *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__name_USCOREvalue(soap, NULL, a->__ptr + i, "ns1:name_value"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns1__name_USCOREvalue **)soap_push_block(soap, sizeof(struct ns1__name_USCOREvalue *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__name_USCOREvalue(soap, NULL, p, "ns1:name_value"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (struct ns1__name_USCOREvalue **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct name_USCOREvalue_USCORElist *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_name_USCOREvalue_USCORElist, 0, sizeof(struct name_USCOREvalue_USCORElist), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__field(struct soap *soap, struct ns1__field *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->name);
	soap_default_string(soap, &a->type);
	soap_default_string(soap, &a->label);
	soap_default_int(soap, &a->required);
	a->options = NULL;
	soap_default_string(soap, &a->default_USCOREvalue);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__field(struct soap *soap, const struct ns1__field *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->name);
	soap_serialize_string(soap, &a->type);
	soap_serialize_string(soap, &a->label);
	soap_embedded(soap, &a->required, SOAP_TYPE_int);
	soap_serialize_PointerToname_USCOREvalue_USCORElist(soap, &a->options);
	soap_serialize_string(soap, &a->default_USCOREvalue);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__field(struct soap *soap, const struct ns1__field *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__field);
	if (soap_out_ns1__field(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__field(struct soap *soap, const char *tag, int id, const struct ns1__field *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__field), type))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->name, ""))
		return soap->error;
	if (soap_out_string(soap, "type", -1, &a->type, ""))
		return soap->error;
	if (soap_out_string(soap, "label", -1, &a->label, ""))
		return soap->error;
	if (soap_out_int(soap, "required", -1, &a->required, ""))
		return soap->error;
	if (soap_out_PointerToname_USCOREvalue_USCORElist(soap, "options", -1, &a->options, ""))
		return soap->error;
	if (soap_out_string(soap, "default_value", -1, &a->default_USCOREvalue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__field * SOAP_FMAC4 soap_get_ns1__field(struct soap *soap, struct ns1__field *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__field(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__field * SOAP_FMAC4 soap_in_ns1__field(struct soap *soap, const char *tag, struct ns1__field *a, const char *type)
{
	short soap_flag_name = 1, soap_flag_type = 1, soap_flag_label = 1, soap_flag_required = 1, soap_flag_options = 1, soap_flag_default_USCOREvalue = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__field *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__field, sizeof(struct ns1__field), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__field(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_type && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "type", &a->type, "xsd:string"))
				{	soap_flag_type--;
					continue;
				}
			if (soap_flag_label && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "label", &a->label, "xsd:string"))
				{	soap_flag_label--;
					continue;
				}
			if (soap_flag_required && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "required", &a->required, "xsd:int"))
				{	soap_flag_required--;
					continue;
				}
			if (soap_flag_options && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToname_USCOREvalue_USCORElist(soap, "options", &a->options, "ns1:name_value"))
				{	soap_flag_options--;
					continue;
				}
			if (soap_flag_default_USCOREvalue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "default_value", &a->default_USCOREvalue, "xsd:string"))
				{	soap_flag_default_USCOREvalue--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__field *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__field, 0, sizeof(struct ns1__field), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name > 0 || soap_flag_type > 0 || soap_flag_label > 0 || soap_flag_required > 0 || soap_flag_options > 0 || soap_flag_default_USCOREvalue > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__user_USCOREauth(struct soap *soap, struct ns1__user_USCOREauth *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->user_USCOREname);
	soap_default_string(soap, &a->password);
	soap_default_string(soap, &a->version);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__user_USCOREauth(struct soap *soap, const struct ns1__user_USCOREauth *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->user_USCOREname);
	soap_serialize_string(soap, &a->password);
	soap_serialize_string(soap, &a->version);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__user_USCOREauth(struct soap *soap, const struct ns1__user_USCOREauth *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__user_USCOREauth);
	if (soap_out_ns1__user_USCOREauth(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__user_USCOREauth(struct soap *soap, const char *tag, int id, const struct ns1__user_USCOREauth *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__user_USCOREauth), type))
		return soap->error;
	if (soap_out_string(soap, "user_name", -1, &a->user_USCOREname, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	if (soap_out_string(soap, "version", -1, &a->version, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__user_USCOREauth * SOAP_FMAC4 soap_get_ns1__user_USCOREauth(struct soap *soap, struct ns1__user_USCOREauth *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__user_USCOREauth(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__user_USCOREauth * SOAP_FMAC4 soap_in_ns1__user_USCOREauth(struct soap *soap, const char *tag, struct ns1__user_USCOREauth *a, const char *type)
{
	short soap_flag_user_USCOREname = 1, soap_flag_password = 1, soap_flag_version = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__user_USCOREauth *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__user_USCOREauth, sizeof(struct ns1__user_USCOREauth), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__user_USCOREauth(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_user_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "user_name", &a->user_USCOREname, "xsd:string"))
				{	soap_flag_user_USCOREname--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap_flag_version && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "version", &a->version, "xsd:string"))
				{	soap_flag_version--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__user_USCOREauth *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__user_USCOREauth, 0, sizeof(struct ns1__user_USCOREauth), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_user_USCOREname > 0 || soap_flag_password > 0 || soap_flag_version > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__error_USCOREvalue(struct soap *soap, struct ns1__error_USCOREvalue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->number);
	soap_default_string(soap, &a->name);
	soap_default_string(soap, &a->description);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__error_USCOREvalue(struct soap *soap, const struct ns1__error_USCOREvalue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->number);
	soap_serialize_string(soap, &a->name);
	soap_serialize_string(soap, &a->description);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__error_USCOREvalue(struct soap *soap, const struct ns1__error_USCOREvalue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__error_USCOREvalue);
	if (soap_out_ns1__error_USCOREvalue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__error_USCOREvalue(struct soap *soap, const char *tag, int id, const struct ns1__error_USCOREvalue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__error_USCOREvalue), type))
		return soap->error;
	if (soap_out_string(soap, "number", -1, &a->number, ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->name, ""))
		return soap->error;
	if (soap_out_string(soap, "description", -1, &a->description, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__error_USCOREvalue * SOAP_FMAC4 soap_get_ns1__error_USCOREvalue(struct soap *soap, struct ns1__error_USCOREvalue *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__error_USCOREvalue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__error_USCOREvalue * SOAP_FMAC4 soap_in_ns1__error_USCOREvalue(struct soap *soap, const char *tag, struct ns1__error_USCOREvalue *a, const char *type)
{
	short soap_flag_number = 1, soap_flag_name = 1, soap_flag_description = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__error_USCOREvalue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__error_USCOREvalue, sizeof(struct ns1__error_USCOREvalue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__error_USCOREvalue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_number && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "number", &a->number, "xsd:string"))
				{	soap_flag_number--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "description", &a->description, "xsd:string"))
				{	soap_flag_description--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__error_USCOREvalue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__error_USCOREvalue, 0, sizeof(struct ns1__error_USCOREvalue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_number > 0 || soap_flag_name > 0 || soap_flag_description > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__return_USCOREnote_USCOREattachment(struct soap *soap, struct ns1__return_USCOREnote_USCOREattachment *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->note_USCOREattachment = NULL;
	a->error = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__return_USCOREnote_USCOREattachment(struct soap *soap, const struct ns1__return_USCOREnote_USCOREattachment *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__note_USCOREattachment(soap, &a->note_USCOREattachment);
	soap_serialize_PointerTons1__error_USCOREvalue(soap, &a->error);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__return_USCOREnote_USCOREattachment(struct soap *soap, const struct ns1__return_USCOREnote_USCOREattachment *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__return_USCOREnote_USCOREattachment);
	if (soap_out_ns1__return_USCOREnote_USCOREattachment(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__return_USCOREnote_USCOREattachment(struct soap *soap, const char *tag, int id, const struct ns1__return_USCOREnote_USCOREattachment *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__return_USCOREnote_USCOREattachment), type))
		return soap->error;
	if (soap_out_PointerTons1__note_USCOREattachment(soap, "note_attachment", -1, &a->note_USCOREattachment, ""))
		return soap->error;
	if (soap_out_PointerTons1__error_USCOREvalue(soap, "error", -1, &a->error, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__return_USCOREnote_USCOREattachment * SOAP_FMAC4 soap_get_ns1__return_USCOREnote_USCOREattachment(struct soap *soap, struct ns1__return_USCOREnote_USCOREattachment *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__return_USCOREnote_USCOREattachment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__return_USCOREnote_USCOREattachment * SOAP_FMAC4 soap_in_ns1__return_USCOREnote_USCOREattachment(struct soap *soap, const char *tag, struct ns1__return_USCOREnote_USCOREattachment *a, const char *type)
{
	short soap_flag_note_USCOREattachment = 1, soap_flag_error = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__return_USCOREnote_USCOREattachment *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__return_USCOREnote_USCOREattachment, sizeof(struct ns1__return_USCOREnote_USCOREattachment), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__return_USCOREnote_USCOREattachment(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_note_USCOREattachment && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__note_USCOREattachment(soap, "note_attachment", &a->note_USCOREattachment, "ns1:note_attachment"))
				{	soap_flag_note_USCOREattachment--;
					continue;
				}
			if (soap_flag_error && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__error_USCOREvalue(soap, "error", &a->error, "ns1:error_value"))
				{	soap_flag_error--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__return_USCOREnote_USCOREattachment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__return_USCOREnote_USCOREattachment, 0, sizeof(struct ns1__return_USCOREnote_USCOREattachment), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_note_USCOREattachment > 0 || soap_flag_error > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__new_USCOREreturn_USCOREnote_USCOREattachment(struct soap *soap, struct ns1__new_USCOREreturn_USCOREnote_USCOREattachment *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->note_USCOREattachment = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__new_USCOREreturn_USCOREnote_USCOREattachment(struct soap *soap, const struct ns1__new_USCOREreturn_USCOREnote_USCOREattachment *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__new_USCOREnote_USCOREattachment(soap, &a->note_USCOREattachment);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__new_USCOREreturn_USCOREnote_USCOREattachment(struct soap *soap, const struct ns1__new_USCOREreturn_USCOREnote_USCOREattachment *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__new_USCOREreturn_USCOREnote_USCOREattachment);
	if (soap_out_ns1__new_USCOREreturn_USCOREnote_USCOREattachment(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__new_USCOREreturn_USCOREnote_USCOREattachment(struct soap *soap, const char *tag, int id, const struct ns1__new_USCOREreturn_USCOREnote_USCOREattachment *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__new_USCOREreturn_USCOREnote_USCOREattachment), type))
		return soap->error;
	if (soap_out_PointerTons1__new_USCOREnote_USCOREattachment(soap, "note_attachment", -1, &a->note_USCOREattachment, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__new_USCOREreturn_USCOREnote_USCOREattachment * SOAP_FMAC4 soap_get_ns1__new_USCOREreturn_USCOREnote_USCOREattachment(struct soap *soap, struct ns1__new_USCOREreturn_USCOREnote_USCOREattachment *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__new_USCOREreturn_USCOREnote_USCOREattachment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__new_USCOREreturn_USCOREnote_USCOREattachment * SOAP_FMAC4 soap_in_ns1__new_USCOREreturn_USCOREnote_USCOREattachment(struct soap *soap, const char *tag, struct ns1__new_USCOREreturn_USCOREnote_USCOREattachment *a, const char *type)
{
	short soap_flag_note_USCOREattachment = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__new_USCOREreturn_USCOREnote_USCOREattachment *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__new_USCOREreturn_USCOREnote_USCOREattachment, sizeof(struct ns1__new_USCOREreturn_USCOREnote_USCOREattachment), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__new_USCOREreturn_USCOREnote_USCOREattachment(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_note_USCOREattachment && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__new_USCOREnote_USCOREattachment(soap, "note_attachment", &a->note_USCOREattachment, "ns1:new_note_attachment"))
				{	soap_flag_note_USCOREattachment--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__new_USCOREreturn_USCOREnote_USCOREattachment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__new_USCOREreturn_USCOREnote_USCOREattachment, 0, sizeof(struct ns1__new_USCOREreturn_USCOREnote_USCOREattachment), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_note_USCOREattachment > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__new_USCOREnote_USCOREattachment(struct soap *soap, struct ns1__new_USCOREnote_USCOREattachment *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->id);
	soap_default_string(soap, &a->filename);
	soap_default_string(soap, &a->file);
	soap_default_string(soap, &a->related_USCOREmodule_USCOREid);
	soap_default_string(soap, &a->related_USCOREmodule_USCOREname);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__new_USCOREnote_USCOREattachment(struct soap *soap, const struct ns1__new_USCOREnote_USCOREattachment *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->id);
	soap_serialize_string(soap, &a->filename);
	soap_serialize_string(soap, &a->file);
	soap_serialize_string(soap, &a->related_USCOREmodule_USCOREid);
	soap_serialize_string(soap, &a->related_USCOREmodule_USCOREname);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__new_USCOREnote_USCOREattachment(struct soap *soap, const struct ns1__new_USCOREnote_USCOREattachment *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__new_USCOREnote_USCOREattachment);
	if (soap_out_ns1__new_USCOREnote_USCOREattachment(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__new_USCOREnote_USCOREattachment(struct soap *soap, const char *tag, int id, const struct ns1__new_USCOREnote_USCOREattachment *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__new_USCOREnote_USCOREattachment), type))
		return soap->error;
	if (soap_out_string(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_string(soap, "filename", -1, &a->filename, ""))
		return soap->error;
	if (soap_out_string(soap, "file", -1, &a->file, ""))
		return soap->error;
	if (soap_out_string(soap, "related_module_id", -1, &a->related_USCOREmodule_USCOREid, ""))
		return soap->error;
	if (soap_out_string(soap, "related_module_name", -1, &a->related_USCOREmodule_USCOREname, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__new_USCOREnote_USCOREattachment * SOAP_FMAC4 soap_get_ns1__new_USCOREnote_USCOREattachment(struct soap *soap, struct ns1__new_USCOREnote_USCOREattachment *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__new_USCOREnote_USCOREattachment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__new_USCOREnote_USCOREattachment * SOAP_FMAC4 soap_in_ns1__new_USCOREnote_USCOREattachment(struct soap *soap, const char *tag, struct ns1__new_USCOREnote_USCOREattachment *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_filename = 1, soap_flag_file = 1, soap_flag_related_USCOREmodule_USCOREid = 1, soap_flag_related_USCOREmodule_USCOREname = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__new_USCOREnote_USCOREattachment *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__new_USCOREnote_USCOREattachment, sizeof(struct ns1__new_USCOREnote_USCOREattachment), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__new_USCOREnote_USCOREattachment(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_filename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "filename", &a->filename, "xsd:string"))
				{	soap_flag_filename--;
					continue;
				}
			if (soap_flag_file && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "file", &a->file, "xsd:string"))
				{	soap_flag_file--;
					continue;
				}
			if (soap_flag_related_USCOREmodule_USCOREid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "related_module_id", &a->related_USCOREmodule_USCOREid, "xsd:string"))
				{	soap_flag_related_USCOREmodule_USCOREid--;
					continue;
				}
			if (soap_flag_related_USCOREmodule_USCOREname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "related_module_name", &a->related_USCOREmodule_USCOREname, "xsd:string"))
				{	soap_flag_related_USCOREmodule_USCOREname--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__new_USCOREnote_USCOREattachment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__new_USCOREnote_USCOREattachment, 0, sizeof(struct ns1__new_USCOREnote_USCOREattachment), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0 || soap_flag_filename > 0 || soap_flag_file > 0 || soap_flag_related_USCOREmodule_USCOREid > 0 || soap_flag_related_USCOREmodule_USCOREname > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__note_USCOREattachment(struct soap *soap, struct ns1__note_USCOREattachment *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->id);
	soap_default_string(soap, &a->filename);
	soap_default_string(soap, &a->file);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__note_USCOREattachment(struct soap *soap, const struct ns1__note_USCOREattachment *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->id);
	soap_serialize_string(soap, &a->filename);
	soap_serialize_string(soap, &a->file);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__note_USCOREattachment(struct soap *soap, const struct ns1__note_USCOREattachment *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__note_USCOREattachment);
	if (soap_out_ns1__note_USCOREattachment(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__note_USCOREattachment(struct soap *soap, const char *tag, int id, const struct ns1__note_USCOREattachment *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__note_USCOREattachment), type))
		return soap->error;
	if (soap_out_string(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_string(soap, "filename", -1, &a->filename, ""))
		return soap->error;
	if (soap_out_string(soap, "file", -1, &a->file, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__note_USCOREattachment * SOAP_FMAC4 soap_get_ns1__note_USCOREattachment(struct soap *soap, struct ns1__note_USCOREattachment *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__note_USCOREattachment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__note_USCOREattachment * SOAP_FMAC4 soap_in_ns1__note_USCOREattachment(struct soap *soap, const char *tag, struct ns1__note_USCOREattachment *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_filename = 1, soap_flag_file = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__note_USCOREattachment *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__note_USCOREattachment, sizeof(struct ns1__note_USCOREattachment), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__note_USCOREattachment(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_filename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "filename", &a->filename, "xsd:string"))
				{	soap_flag_filename--;
					continue;
				}
			if (soap_flag_file && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "file", &a->file, "xsd:string"))
				{	soap_flag_file--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__note_USCOREattachment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__note_USCOREattachment, 0, sizeof(struct ns1__note_USCOREattachment), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0 || soap_flag_filename > 0 || soap_flag_file > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__searchResponse(struct soap *soap, struct ns1__searchResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__searchResponse))
		soap_serialize_ns1__searchResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__searchResponse(struct soap *soap, struct ns1__searchResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__searchResponse);
	if (soap_out_PointerTons1__searchResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__searchResponse(struct soap *soap, const char *tag, int id, struct ns1__searchResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__searchResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__searchResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__searchResponse ** SOAP_FMAC4 soap_get_PointerTons1__searchResponse(struct soap *soap, struct ns1__searchResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__searchResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__searchResponse ** SOAP_FMAC4 soap_in_PointerTons1__searchResponse(struct soap *soap, const char *tag, struct ns1__searchResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__searchResponse **)soap_malloc(soap, sizeof(struct ns1__searchResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__searchResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__searchResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchResponse, sizeof(struct ns1__searchResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__user_USCORElistResponse(struct soap *soap, struct ns1__user_USCORElistResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__user_USCORElistResponse))
		soap_serialize_ns1__user_USCORElistResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__user_USCORElistResponse(struct soap *soap, struct ns1__user_USCORElistResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__user_USCORElistResponse);
	if (soap_out_PointerTons1__user_USCORElistResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__user_USCORElistResponse(struct soap *soap, const char *tag, int id, struct ns1__user_USCORElistResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__user_USCORElistResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__user_USCORElistResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__user_USCORElistResponse ** SOAP_FMAC4 soap_get_PointerTons1__user_USCORElistResponse(struct soap *soap, struct ns1__user_USCORElistResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__user_USCORElistResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__user_USCORElistResponse ** SOAP_FMAC4 soap_in_PointerTons1__user_USCORElistResponse(struct soap *soap, const char *tag, struct ns1__user_USCORElistResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__user_USCORElistResponse **)soap_malloc(soap, sizeof(struct ns1__user_USCORElistResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__user_USCORElistResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__user_USCORElistResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__user_USCORElistResponse, sizeof(struct ns1__user_USCORElistResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTouser_USCOREdetail_USCOREarray(struct soap *soap, struct user_USCOREdetail_USCOREarray *const*a)
{
	if (*a)
		soap_serialize_user_USCOREdetail_USCOREarray(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTouser_USCOREdetail_USCOREarray(struct soap *soap, struct user_USCOREdetail_USCOREarray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTouser_USCOREdetail_USCOREarray);
	if (soap_out_PointerTouser_USCOREdetail_USCOREarray(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTouser_USCOREdetail_USCOREarray(struct soap *soap, const char *tag, int id, struct user_USCOREdetail_USCOREarray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_user_USCOREdetail_USCOREarray);
	if (id < 0)
		return soap->error;
	return soap_out_user_USCOREdetail_USCOREarray(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct user_USCOREdetail_USCOREarray ** SOAP_FMAC4 soap_get_PointerTouser_USCOREdetail_USCOREarray(struct soap *soap, struct user_USCOREdetail_USCOREarray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTouser_USCOREdetail_USCOREarray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct user_USCOREdetail_USCOREarray ** SOAP_FMAC4 soap_in_PointerTouser_USCOREdetail_USCOREarray(struct soap *soap, const char *tag, struct user_USCOREdetail_USCOREarray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct user_USCOREdetail_USCOREarray **)soap_malloc(soap, sizeof(struct user_USCOREdetail_USCOREarray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_user_USCOREdetail_USCOREarray(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct user_USCOREdetail_USCOREarray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_user_USCOREdetail_USCOREarray, sizeof(struct user_USCOREdetail_USCOREarray), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__get_USCOREcontact_USCORErelationshipsResponse(struct soap *soap, struct ns1__get_USCOREcontact_USCORErelationshipsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__get_USCOREcontact_USCORErelationshipsResponse))
		soap_serialize_ns1__get_USCOREcontact_USCORErelationshipsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__get_USCOREcontact_USCORErelationshipsResponse(struct soap *soap, struct ns1__get_USCOREcontact_USCORErelationshipsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__get_USCOREcontact_USCORErelationshipsResponse);
	if (soap_out_PointerTons1__get_USCOREcontact_USCORErelationshipsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__get_USCOREcontact_USCORErelationshipsResponse(struct soap *soap, const char *tag, int id, struct ns1__get_USCOREcontact_USCORErelationshipsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__get_USCOREcontact_USCORErelationshipsResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__get_USCOREcontact_USCORErelationshipsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__get_USCOREcontact_USCORErelationshipsResponse ** SOAP_FMAC4 soap_get_PointerTons1__get_USCOREcontact_USCORErelationshipsResponse(struct soap *soap, struct ns1__get_USCOREcontact_USCORErelationshipsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__get_USCOREcontact_USCORErelationshipsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREcontact_USCORErelationshipsResponse ** SOAP_FMAC4 soap_in_PointerTons1__get_USCOREcontact_USCORErelationshipsResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREcontact_USCORErelationshipsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__get_USCOREcontact_USCORErelationshipsResponse **)soap_malloc(soap, sizeof(struct ns1__get_USCOREcontact_USCORErelationshipsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__get_USCOREcontact_USCORErelationshipsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREcontact_USCORErelationshipsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__get_USCOREcontact_USCORErelationshipsResponse, sizeof(struct ns1__get_USCOREcontact_USCORErelationshipsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__contact_USCOREby_USCOREemailResponse(struct soap *soap, struct ns1__contact_USCOREby_USCOREemailResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__contact_USCOREby_USCOREemailResponse))
		soap_serialize_ns1__contact_USCOREby_USCOREemailResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__contact_USCOREby_USCOREemailResponse(struct soap *soap, struct ns1__contact_USCOREby_USCOREemailResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__contact_USCOREby_USCOREemailResponse);
	if (soap_out_PointerTons1__contact_USCOREby_USCOREemailResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__contact_USCOREby_USCOREemailResponse(struct soap *soap, const char *tag, int id, struct ns1__contact_USCOREby_USCOREemailResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__contact_USCOREby_USCOREemailResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__contact_USCOREby_USCOREemailResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__contact_USCOREby_USCOREemailResponse ** SOAP_FMAC4 soap_get_PointerTons1__contact_USCOREby_USCOREemailResponse(struct soap *soap, struct ns1__contact_USCOREby_USCOREemailResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__contact_USCOREby_USCOREemailResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__contact_USCOREby_USCOREemailResponse ** SOAP_FMAC4 soap_in_PointerTons1__contact_USCOREby_USCOREemailResponse(struct soap *soap, const char *tag, struct ns1__contact_USCOREby_USCOREemailResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__contact_USCOREby_USCOREemailResponse **)soap_malloc(soap, sizeof(struct ns1__contact_USCOREby_USCOREemailResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__contact_USCOREby_USCOREemailResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__contact_USCOREby_USCOREemailResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__contact_USCOREby_USCOREemailResponse, sizeof(struct ns1__contact_USCOREby_USCOREemailResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTocontact_USCOREdetail_USCOREarray(struct soap *soap, struct contact_USCOREdetail_USCOREarray *const*a)
{
	if (*a)
		soap_serialize_contact_USCOREdetail_USCOREarray(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTocontact_USCOREdetail_USCOREarray(struct soap *soap, struct contact_USCOREdetail_USCOREarray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTocontact_USCOREdetail_USCOREarray);
	if (soap_out_PointerTocontact_USCOREdetail_USCOREarray(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTocontact_USCOREdetail_USCOREarray(struct soap *soap, const char *tag, int id, struct contact_USCOREdetail_USCOREarray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_contact_USCOREdetail_USCOREarray);
	if (id < 0)
		return soap->error;
	return soap_out_contact_USCOREdetail_USCOREarray(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct contact_USCOREdetail_USCOREarray ** SOAP_FMAC4 soap_get_PointerTocontact_USCOREdetail_USCOREarray(struct soap *soap, struct contact_USCOREdetail_USCOREarray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTocontact_USCOREdetail_USCOREarray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct contact_USCOREdetail_USCOREarray ** SOAP_FMAC4 soap_in_PointerTocontact_USCOREdetail_USCOREarray(struct soap *soap, const char *tag, struct contact_USCOREdetail_USCOREarray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct contact_USCOREdetail_USCOREarray **)soap_malloc(soap, sizeof(struct contact_USCOREdetail_USCOREarray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_contact_USCOREdetail_USCOREarray(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct contact_USCOREdetail_USCOREarray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_contact_USCOREdetail_USCOREarray, sizeof(struct contact_USCOREdetail_USCOREarray), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__get_USCOREattendee_USCORElistResponse(struct soap *soap, struct ns1__get_USCOREattendee_USCORElistResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__get_USCOREattendee_USCORElistResponse))
		soap_serialize_ns1__get_USCOREattendee_USCORElistResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__get_USCOREattendee_USCORElistResponse(struct soap *soap, struct ns1__get_USCOREattendee_USCORElistResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__get_USCOREattendee_USCORElistResponse);
	if (soap_out_PointerTons1__get_USCOREattendee_USCORElistResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__get_USCOREattendee_USCORElistResponse(struct soap *soap, const char *tag, int id, struct ns1__get_USCOREattendee_USCORElistResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__get_USCOREattendee_USCORElistResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__get_USCOREattendee_USCORElistResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__get_USCOREattendee_USCORElistResponse ** SOAP_FMAC4 soap_get_PointerTons1__get_USCOREattendee_USCORElistResponse(struct soap *soap, struct ns1__get_USCOREattendee_USCORElistResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__get_USCOREattendee_USCORElistResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREattendee_USCORElistResponse ** SOAP_FMAC4 soap_in_PointerTons1__get_USCOREattendee_USCORElistResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREattendee_USCORElistResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__get_USCOREattendee_USCORElistResponse **)soap_malloc(soap, sizeof(struct ns1__get_USCOREattendee_USCORElistResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__get_USCOREattendee_USCORElistResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREattendee_USCORElistResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__get_USCOREattendee_USCORElistResponse, sizeof(struct ns1__get_USCOREattendee_USCORElistResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__get_USCOREmodified_USCOREentriesResponse(struct soap *soap, struct ns1__get_USCOREmodified_USCOREentriesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__get_USCOREmodified_USCOREentriesResponse))
		soap_serialize_ns1__get_USCOREmodified_USCOREentriesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__get_USCOREmodified_USCOREentriesResponse(struct soap *soap, struct ns1__get_USCOREmodified_USCOREentriesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__get_USCOREmodified_USCOREentriesResponse);
	if (soap_out_PointerTons1__get_USCOREmodified_USCOREentriesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__get_USCOREmodified_USCOREentriesResponse(struct soap *soap, const char *tag, int id, struct ns1__get_USCOREmodified_USCOREentriesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__get_USCOREmodified_USCOREentriesResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__get_USCOREmodified_USCOREentriesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__get_USCOREmodified_USCOREentriesResponse ** SOAP_FMAC4 soap_get_PointerTons1__get_USCOREmodified_USCOREentriesResponse(struct soap *soap, struct ns1__get_USCOREmodified_USCOREentriesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__get_USCOREmodified_USCOREentriesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREmodified_USCOREentriesResponse ** SOAP_FMAC4 soap_in_PointerTons1__get_USCOREmodified_USCOREentriesResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREmodified_USCOREentriesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__get_USCOREmodified_USCOREentriesResponse **)soap_malloc(soap, sizeof(struct ns1__get_USCOREmodified_USCOREentriesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__get_USCOREmodified_USCOREentriesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREmodified_USCOREentriesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__get_USCOREmodified_USCOREentriesResponse, sizeof(struct ns1__get_USCOREmodified_USCOREentriesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse(struct soap *soap, struct ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse))
		soap_serialize_ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse(struct soap *soap, struct ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse);
	if (soap_out_PointerTons1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse(struct soap *soap, const char *tag, int id, struct ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse ** SOAP_FMAC4 soap_get_PointerTons1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse(struct soap *soap, struct ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse ** SOAP_FMAC4 soap_in_PointerTons1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse(struct soap *soap, const char *tag, struct ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse **)soap_malloc(soap, sizeof(struct ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse, sizeof(struct ns1__sync_USCOREget_USCOREmodified_USCORErelationshipsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded(struct soap *soap, struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded))
		soap_serialize_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded(struct soap *soap, struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded);
	if (soap_out_PointerTons1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded(struct soap *soap, const char *tag, int id, struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded ** SOAP_FMAC4 soap_get_PointerTons1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded(struct soap *soap, struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded ** SOAP_FMAC4 soap_in_PointerTons1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded(struct soap *soap, const char *tag, struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded **)soap_malloc(soap, sizeof(struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded, sizeof(struct ns1__get_USCOREentry_USCORElist_USCOREresult_USCOREencoded), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__set_USCOREentries_USCOREdetailsResponse(struct soap *soap, struct ns1__set_USCOREentries_USCOREdetailsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__set_USCOREentries_USCOREdetailsResponse))
		soap_serialize_ns1__set_USCOREentries_USCOREdetailsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__set_USCOREentries_USCOREdetailsResponse(struct soap *soap, struct ns1__set_USCOREentries_USCOREdetailsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__set_USCOREentries_USCOREdetailsResponse);
	if (soap_out_PointerTons1__set_USCOREentries_USCOREdetailsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__set_USCOREentries_USCOREdetailsResponse(struct soap *soap, const char *tag, int id, struct ns1__set_USCOREentries_USCOREdetailsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__set_USCOREentries_USCOREdetailsResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__set_USCOREentries_USCOREdetailsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__set_USCOREentries_USCOREdetailsResponse ** SOAP_FMAC4 soap_get_PointerTons1__set_USCOREentries_USCOREdetailsResponse(struct soap *soap, struct ns1__set_USCOREentries_USCOREdetailsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__set_USCOREentries_USCOREdetailsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__set_USCOREentries_USCOREdetailsResponse ** SOAP_FMAC4 soap_in_PointerTons1__set_USCOREentries_USCOREdetailsResponse(struct soap *soap, const char *tag, struct ns1__set_USCOREentries_USCOREdetailsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__set_USCOREentries_USCOREdetailsResponse **)soap_malloc(soap, sizeof(struct ns1__set_USCOREentries_USCOREdetailsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__set_USCOREentries_USCOREdetailsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCOREentries_USCOREdetailsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__set_USCOREentries_USCOREdetailsResponse, sizeof(struct ns1__set_USCOREentries_USCOREdetailsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__set_USCOREentries_USCOREdetail_USCOREresult(struct soap *soap, struct ns1__set_USCOREentries_USCOREdetail_USCOREresult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__set_USCOREentries_USCOREdetail_USCOREresult))
		soap_serialize_ns1__set_USCOREentries_USCOREdetail_USCOREresult(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__set_USCOREentries_USCOREdetail_USCOREresult(struct soap *soap, struct ns1__set_USCOREentries_USCOREdetail_USCOREresult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__set_USCOREentries_USCOREdetail_USCOREresult);
	if (soap_out_PointerTons1__set_USCOREentries_USCOREdetail_USCOREresult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__set_USCOREentries_USCOREdetail_USCOREresult(struct soap *soap, const char *tag, int id, struct ns1__set_USCOREentries_USCOREdetail_USCOREresult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__set_USCOREentries_USCOREdetail_USCOREresult);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__set_USCOREentries_USCOREdetail_USCOREresult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__set_USCOREentries_USCOREdetail_USCOREresult ** SOAP_FMAC4 soap_get_PointerTons1__set_USCOREentries_USCOREdetail_USCOREresult(struct soap *soap, struct ns1__set_USCOREentries_USCOREdetail_USCOREresult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__set_USCOREentries_USCOREdetail_USCOREresult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__set_USCOREentries_USCOREdetail_USCOREresult ** SOAP_FMAC4 soap_in_PointerTons1__set_USCOREentries_USCOREdetail_USCOREresult(struct soap *soap, const char *tag, struct ns1__set_USCOREentries_USCOREdetail_USCOREresult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__set_USCOREentries_USCOREdetail_USCOREresult **)soap_malloc(soap, sizeof(struct ns1__set_USCOREentries_USCOREdetail_USCOREresult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__set_USCOREentries_USCOREdetail_USCOREresult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCOREentries_USCOREdetail_USCOREresult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__set_USCOREentries_USCOREdetail_USCOREresult, sizeof(struct ns1__set_USCOREentries_USCOREdetail_USCOREresult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__get_USCOREentries_USCOREcountResponse(struct soap *soap, struct ns1__get_USCOREentries_USCOREcountResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__get_USCOREentries_USCOREcountResponse))
		soap_serialize_ns1__get_USCOREentries_USCOREcountResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__get_USCOREentries_USCOREcountResponse(struct soap *soap, struct ns1__get_USCOREentries_USCOREcountResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__get_USCOREentries_USCOREcountResponse);
	if (soap_out_PointerTons1__get_USCOREentries_USCOREcountResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__get_USCOREentries_USCOREcountResponse(struct soap *soap, const char *tag, int id, struct ns1__get_USCOREentries_USCOREcountResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__get_USCOREentries_USCOREcountResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__get_USCOREentries_USCOREcountResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__get_USCOREentries_USCOREcountResponse ** SOAP_FMAC4 soap_get_PointerTons1__get_USCOREentries_USCOREcountResponse(struct soap *soap, struct ns1__get_USCOREentries_USCOREcountResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__get_USCOREentries_USCOREcountResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREentries_USCOREcountResponse ** SOAP_FMAC4 soap_in_PointerTons1__get_USCOREentries_USCOREcountResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREentries_USCOREcountResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__get_USCOREentries_USCOREcountResponse **)soap_malloc(soap, sizeof(struct ns1__get_USCOREentries_USCOREcountResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__get_USCOREentries_USCOREcountResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREentries_USCOREcountResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__get_USCOREentries_USCOREcountResponse, sizeof(struct ns1__get_USCOREentries_USCOREcountResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__get_USCOREentries_USCOREcount_USCOREresult(struct soap *soap, struct ns1__get_USCOREentries_USCOREcount_USCOREresult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__get_USCOREentries_USCOREcount_USCOREresult))
		soap_serialize_ns1__get_USCOREentries_USCOREcount_USCOREresult(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__get_USCOREentries_USCOREcount_USCOREresult(struct soap *soap, struct ns1__get_USCOREentries_USCOREcount_USCOREresult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__get_USCOREentries_USCOREcount_USCOREresult);
	if (soap_out_PointerTons1__get_USCOREentries_USCOREcount_USCOREresult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__get_USCOREentries_USCOREcount_USCOREresult(struct soap *soap, const char *tag, int id, struct ns1__get_USCOREentries_USCOREcount_USCOREresult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__get_USCOREentries_USCOREcount_USCOREresult);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__get_USCOREentries_USCOREcount_USCOREresult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__get_USCOREentries_USCOREcount_USCOREresult ** SOAP_FMAC4 soap_get_PointerTons1__get_USCOREentries_USCOREcount_USCOREresult(struct soap *soap, struct ns1__get_USCOREentries_USCOREcount_USCOREresult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__get_USCOREentries_USCOREcount_USCOREresult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREentries_USCOREcount_USCOREresult ** SOAP_FMAC4 soap_in_PointerTons1__get_USCOREentries_USCOREcount_USCOREresult(struct soap *soap, const char *tag, struct ns1__get_USCOREentries_USCOREcount_USCOREresult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__get_USCOREentries_USCOREcount_USCOREresult **)soap_malloc(soap, sizeof(struct ns1__get_USCOREentries_USCOREcount_USCOREresult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__get_USCOREentries_USCOREcount_USCOREresult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREentries_USCOREcount_USCOREresult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__get_USCOREentries_USCOREcount_USCOREresult, sizeof(struct ns1__get_USCOREentries_USCOREcount_USCOREresult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__set_USCOREcampaign_USCOREmergeResponse(struct soap *soap, struct ns1__set_USCOREcampaign_USCOREmergeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__set_USCOREcampaign_USCOREmergeResponse))
		soap_serialize_ns1__set_USCOREcampaign_USCOREmergeResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__set_USCOREcampaign_USCOREmergeResponse(struct soap *soap, struct ns1__set_USCOREcampaign_USCOREmergeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__set_USCOREcampaign_USCOREmergeResponse);
	if (soap_out_PointerTons1__set_USCOREcampaign_USCOREmergeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__set_USCOREcampaign_USCOREmergeResponse(struct soap *soap, const char *tag, int id, struct ns1__set_USCOREcampaign_USCOREmergeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__set_USCOREcampaign_USCOREmergeResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__set_USCOREcampaign_USCOREmergeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__set_USCOREcampaign_USCOREmergeResponse ** SOAP_FMAC4 soap_get_PointerTons1__set_USCOREcampaign_USCOREmergeResponse(struct soap *soap, struct ns1__set_USCOREcampaign_USCOREmergeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__set_USCOREcampaign_USCOREmergeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__set_USCOREcampaign_USCOREmergeResponse ** SOAP_FMAC4 soap_in_PointerTons1__set_USCOREcampaign_USCOREmergeResponse(struct soap *soap, const char *tag, struct ns1__set_USCOREcampaign_USCOREmergeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__set_USCOREcampaign_USCOREmergeResponse **)soap_malloc(soap, sizeof(struct ns1__set_USCOREcampaign_USCOREmergeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__set_USCOREcampaign_USCOREmergeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCOREcampaign_USCOREmergeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__set_USCOREcampaign_USCOREmergeResponse, sizeof(struct ns1__set_USCOREcampaign_USCOREmergeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__get_USCOREdocument_USCORErevisionResponse(struct soap *soap, struct ns1__get_USCOREdocument_USCORErevisionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__get_USCOREdocument_USCORErevisionResponse))
		soap_serialize_ns1__get_USCOREdocument_USCORErevisionResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__get_USCOREdocument_USCORErevisionResponse(struct soap *soap, struct ns1__get_USCOREdocument_USCORErevisionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__get_USCOREdocument_USCORErevisionResponse);
	if (soap_out_PointerTons1__get_USCOREdocument_USCORErevisionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__get_USCOREdocument_USCORErevisionResponse(struct soap *soap, const char *tag, int id, struct ns1__get_USCOREdocument_USCORErevisionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__get_USCOREdocument_USCORErevisionResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__get_USCOREdocument_USCORErevisionResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__get_USCOREdocument_USCORErevisionResponse ** SOAP_FMAC4 soap_get_PointerTons1__get_USCOREdocument_USCORErevisionResponse(struct soap *soap, struct ns1__get_USCOREdocument_USCORErevisionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__get_USCOREdocument_USCORErevisionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREdocument_USCORErevisionResponse ** SOAP_FMAC4 soap_in_PointerTons1__get_USCOREdocument_USCORErevisionResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREdocument_USCORErevisionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__get_USCOREdocument_USCORErevisionResponse **)soap_malloc(soap, sizeof(struct ns1__get_USCOREdocument_USCORErevisionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__get_USCOREdocument_USCORErevisionResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREdocument_USCORErevisionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__get_USCOREdocument_USCORErevisionResponse, sizeof(struct ns1__get_USCOREdocument_USCORErevisionResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__return_USCOREdocument_USCORErevision(struct soap *soap, struct ns1__return_USCOREdocument_USCORErevision *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__return_USCOREdocument_USCORErevision))
		soap_serialize_ns1__return_USCOREdocument_USCORErevision(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__return_USCOREdocument_USCORErevision(struct soap *soap, struct ns1__return_USCOREdocument_USCORErevision *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__return_USCOREdocument_USCORErevision);
	if (soap_out_PointerTons1__return_USCOREdocument_USCORErevision(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__return_USCOREdocument_USCORErevision(struct soap *soap, const char *tag, int id, struct ns1__return_USCOREdocument_USCORErevision *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__return_USCOREdocument_USCORErevision);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__return_USCOREdocument_USCORErevision(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__return_USCOREdocument_USCORErevision ** SOAP_FMAC4 soap_get_PointerTons1__return_USCOREdocument_USCORErevision(struct soap *soap, struct ns1__return_USCOREdocument_USCORErevision **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__return_USCOREdocument_USCORErevision(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__return_USCOREdocument_USCORErevision ** SOAP_FMAC4 soap_in_PointerTons1__return_USCOREdocument_USCORErevision(struct soap *soap, const char *tag, struct ns1__return_USCOREdocument_USCORErevision **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__return_USCOREdocument_USCORErevision **)soap_malloc(soap, sizeof(struct ns1__return_USCOREdocument_USCORErevision *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__return_USCOREdocument_USCORErevision(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__return_USCOREdocument_USCORErevision **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__return_USCOREdocument_USCORErevision, sizeof(struct ns1__return_USCOREdocument_USCORErevision), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__get_USCOREmailmerge_USCOREdocument2Response(struct soap *soap, struct ns1__get_USCOREmailmerge_USCOREdocument2Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocument2Response))
		soap_serialize_ns1__get_USCOREmailmerge_USCOREdocument2Response(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__get_USCOREmailmerge_USCOREdocument2Response(struct soap *soap, struct ns1__get_USCOREmailmerge_USCOREdocument2Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__get_USCOREmailmerge_USCOREdocument2Response);
	if (soap_out_PointerTons1__get_USCOREmailmerge_USCOREdocument2Response(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__get_USCOREmailmerge_USCOREdocument2Response(struct soap *soap, const char *tag, int id, struct ns1__get_USCOREmailmerge_USCOREdocument2Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocument2Response);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__get_USCOREmailmerge_USCOREdocument2Response(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__get_USCOREmailmerge_USCOREdocument2Response ** SOAP_FMAC4 soap_get_PointerTons1__get_USCOREmailmerge_USCOREdocument2Response(struct soap *soap, struct ns1__get_USCOREmailmerge_USCOREdocument2Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__get_USCOREmailmerge_USCOREdocument2Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREmailmerge_USCOREdocument2Response ** SOAP_FMAC4 soap_in_PointerTons1__get_USCOREmailmerge_USCOREdocument2Response(struct soap *soap, const char *tag, struct ns1__get_USCOREmailmerge_USCOREdocument2Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__get_USCOREmailmerge_USCOREdocument2Response **)soap_malloc(soap, sizeof(struct ns1__get_USCOREmailmerge_USCOREdocument2Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__get_USCOREmailmerge_USCOREdocument2Response(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREmailmerge_USCOREdocument2Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocument2Response, sizeof(struct ns1__get_USCOREmailmerge_USCOREdocument2Response), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__get_USCOREmailmerge_USCOREdocument_USCOREresult(struct soap *soap, struct ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult))
		soap_serialize_ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__get_USCOREmailmerge_USCOREdocument_USCOREresult(struct soap *soap, struct ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__get_USCOREmailmerge_USCOREdocument_USCOREresult);
	if (soap_out_PointerTons1__get_USCOREmailmerge_USCOREdocument_USCOREresult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__get_USCOREmailmerge_USCOREdocument_USCOREresult(struct soap *soap, const char *tag, int id, struct ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult ** SOAP_FMAC4 soap_get_PointerTons1__get_USCOREmailmerge_USCOREdocument_USCOREresult(struct soap *soap, struct ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__get_USCOREmailmerge_USCOREdocument_USCOREresult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult ** SOAP_FMAC4 soap_in_PointerTons1__get_USCOREmailmerge_USCOREdocument_USCOREresult(struct soap *soap, const char *tag, struct ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult **)soap_malloc(soap, sizeof(struct ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult, sizeof(struct ns1__get_USCOREmailmerge_USCOREdocument_USCOREresult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__get_USCOREmailmerge_USCOREdocumentResponse(struct soap *soap, struct ns1__get_USCOREmailmerge_USCOREdocumentResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocumentResponse))
		soap_serialize_ns1__get_USCOREmailmerge_USCOREdocumentResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__get_USCOREmailmerge_USCOREdocumentResponse(struct soap *soap, struct ns1__get_USCOREmailmerge_USCOREdocumentResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__get_USCOREmailmerge_USCOREdocumentResponse);
	if (soap_out_PointerTons1__get_USCOREmailmerge_USCOREdocumentResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__get_USCOREmailmerge_USCOREdocumentResponse(struct soap *soap, const char *tag, int id, struct ns1__get_USCOREmailmerge_USCOREdocumentResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocumentResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__get_USCOREmailmerge_USCOREdocumentResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__get_USCOREmailmerge_USCOREdocumentResponse ** SOAP_FMAC4 soap_get_PointerTons1__get_USCOREmailmerge_USCOREdocumentResponse(struct soap *soap, struct ns1__get_USCOREmailmerge_USCOREdocumentResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__get_USCOREmailmerge_USCOREdocumentResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREmailmerge_USCOREdocumentResponse ** SOAP_FMAC4 soap_in_PointerTons1__get_USCOREmailmerge_USCOREdocumentResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREmailmerge_USCOREdocumentResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__get_USCOREmailmerge_USCOREdocumentResponse **)soap_malloc(soap, sizeof(struct ns1__get_USCOREmailmerge_USCOREdocumentResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__get_USCOREmailmerge_USCOREdocumentResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREmailmerge_USCOREdocumentResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__get_USCOREmailmerge_USCOREdocumentResponse, sizeof(struct ns1__get_USCOREmailmerge_USCOREdocumentResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__get_USCOREsync_USCOREresult_USCOREencoded(struct soap *soap, struct ns1__get_USCOREsync_USCOREresult_USCOREencoded *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__get_USCOREsync_USCOREresult_USCOREencoded))
		soap_serialize_ns1__get_USCOREsync_USCOREresult_USCOREencoded(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__get_USCOREsync_USCOREresult_USCOREencoded(struct soap *soap, struct ns1__get_USCOREsync_USCOREresult_USCOREencoded *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__get_USCOREsync_USCOREresult_USCOREencoded);
	if (soap_out_PointerTons1__get_USCOREsync_USCOREresult_USCOREencoded(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__get_USCOREsync_USCOREresult_USCOREencoded(struct soap *soap, const char *tag, int id, struct ns1__get_USCOREsync_USCOREresult_USCOREencoded *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__get_USCOREsync_USCOREresult_USCOREencoded);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__get_USCOREsync_USCOREresult_USCOREencoded(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__get_USCOREsync_USCOREresult_USCOREencoded ** SOAP_FMAC4 soap_get_PointerTons1__get_USCOREsync_USCOREresult_USCOREencoded(struct soap *soap, struct ns1__get_USCOREsync_USCOREresult_USCOREencoded **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__get_USCOREsync_USCOREresult_USCOREencoded(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREsync_USCOREresult_USCOREencoded ** SOAP_FMAC4 soap_in_PointerTons1__get_USCOREsync_USCOREresult_USCOREencoded(struct soap *soap, const char *tag, struct ns1__get_USCOREsync_USCOREresult_USCOREencoded **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__get_USCOREsync_USCOREresult_USCOREencoded **)soap_malloc(soap, sizeof(struct ns1__get_USCOREsync_USCOREresult_USCOREencoded *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__get_USCOREsync_USCOREresult_USCOREencoded(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREsync_USCOREresult_USCOREencoded **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__get_USCOREsync_USCOREresult_USCOREencoded, sizeof(struct ns1__get_USCOREsync_USCOREresult_USCOREencoded), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__search_USCOREby_USCOREmoduleResponse(struct soap *soap, struct ns1__search_USCOREby_USCOREmoduleResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__search_USCOREby_USCOREmoduleResponse))
		soap_serialize_ns1__search_USCOREby_USCOREmoduleResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__search_USCOREby_USCOREmoduleResponse(struct soap *soap, struct ns1__search_USCOREby_USCOREmoduleResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__search_USCOREby_USCOREmoduleResponse);
	if (soap_out_PointerTons1__search_USCOREby_USCOREmoduleResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__search_USCOREby_USCOREmoduleResponse(struct soap *soap, const char *tag, int id, struct ns1__search_USCOREby_USCOREmoduleResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__search_USCOREby_USCOREmoduleResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__search_USCOREby_USCOREmoduleResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__search_USCOREby_USCOREmoduleResponse ** SOAP_FMAC4 soap_get_PointerTons1__search_USCOREby_USCOREmoduleResponse(struct soap *soap, struct ns1__search_USCOREby_USCOREmoduleResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__search_USCOREby_USCOREmoduleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__search_USCOREby_USCOREmoduleResponse ** SOAP_FMAC4 soap_in_PointerTons1__search_USCOREby_USCOREmoduleResponse(struct soap *soap, const char *tag, struct ns1__search_USCOREby_USCOREmoduleResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__search_USCOREby_USCOREmoduleResponse **)soap_malloc(soap, sizeof(struct ns1__search_USCOREby_USCOREmoduleResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__search_USCOREby_USCOREmoduleResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__search_USCOREby_USCOREmoduleResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__search_USCOREby_USCOREmoduleResponse, sizeof(struct ns1__search_USCOREby_USCOREmoduleResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__set_USCOREdocument_USCORErevisionResponse(struct soap *soap, struct ns1__set_USCOREdocument_USCORErevisionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__set_USCOREdocument_USCORErevisionResponse))
		soap_serialize_ns1__set_USCOREdocument_USCORErevisionResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__set_USCOREdocument_USCORErevisionResponse(struct soap *soap, struct ns1__set_USCOREdocument_USCORErevisionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__set_USCOREdocument_USCORErevisionResponse);
	if (soap_out_PointerTons1__set_USCOREdocument_USCORErevisionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__set_USCOREdocument_USCORErevisionResponse(struct soap *soap, const char *tag, int id, struct ns1__set_USCOREdocument_USCORErevisionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__set_USCOREdocument_USCORErevisionResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__set_USCOREdocument_USCORErevisionResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__set_USCOREdocument_USCORErevisionResponse ** SOAP_FMAC4 soap_get_PointerTons1__set_USCOREdocument_USCORErevisionResponse(struct soap *soap, struct ns1__set_USCOREdocument_USCORErevisionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__set_USCOREdocument_USCORErevisionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__set_USCOREdocument_USCORErevisionResponse ** SOAP_FMAC4 soap_in_PointerTons1__set_USCOREdocument_USCORErevisionResponse(struct soap *soap, const char *tag, struct ns1__set_USCOREdocument_USCORErevisionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__set_USCOREdocument_USCORErevisionResponse **)soap_malloc(soap, sizeof(struct ns1__set_USCOREdocument_USCORErevisionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__set_USCOREdocument_USCORErevisionResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCOREdocument_USCORErevisionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__set_USCOREdocument_USCORErevisionResponse, sizeof(struct ns1__set_USCOREdocument_USCORErevisionResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__set_USCORErelationshipsResponse(struct soap *soap, struct ns1__set_USCORErelationshipsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__set_USCORErelationshipsResponse))
		soap_serialize_ns1__set_USCORErelationshipsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__set_USCORErelationshipsResponse(struct soap *soap, struct ns1__set_USCORErelationshipsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__set_USCORErelationshipsResponse);
	if (soap_out_PointerTons1__set_USCORErelationshipsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__set_USCORErelationshipsResponse(struct soap *soap, const char *tag, int id, struct ns1__set_USCORErelationshipsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__set_USCORErelationshipsResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__set_USCORErelationshipsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__set_USCORErelationshipsResponse ** SOAP_FMAC4 soap_get_PointerTons1__set_USCORErelationshipsResponse(struct soap *soap, struct ns1__set_USCORErelationshipsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__set_USCORErelationshipsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__set_USCORErelationshipsResponse ** SOAP_FMAC4 soap_in_PointerTons1__set_USCORErelationshipsResponse(struct soap *soap, const char *tag, struct ns1__set_USCORErelationshipsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__set_USCORErelationshipsResponse **)soap_malloc(soap, sizeof(struct ns1__set_USCORErelationshipsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__set_USCORErelationshipsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCORErelationshipsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__set_USCORErelationshipsResponse, sizeof(struct ns1__set_USCORErelationshipsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToset_USCORErelationship_USCORElist(struct soap *soap, struct set_USCORErelationship_USCORElist *const*a)
{
	if (*a)
		soap_serialize_set_USCORErelationship_USCORElist(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToset_USCORErelationship_USCORElist(struct soap *soap, struct set_USCORErelationship_USCORElist *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToset_USCORErelationship_USCORElist);
	if (soap_out_PointerToset_USCORErelationship_USCORElist(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToset_USCORErelationship_USCORElist(struct soap *soap, const char *tag, int id, struct set_USCORErelationship_USCORElist *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_set_USCORErelationship_USCORElist);
	if (id < 0)
		return soap->error;
	return soap_out_set_USCORErelationship_USCORElist(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct set_USCORErelationship_USCORElist ** SOAP_FMAC4 soap_get_PointerToset_USCORErelationship_USCORElist(struct soap *soap, struct set_USCORErelationship_USCORElist **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToset_USCORErelationship_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct set_USCORErelationship_USCORElist ** SOAP_FMAC4 soap_in_PointerToset_USCORErelationship_USCORElist(struct soap *soap, const char *tag, struct set_USCORErelationship_USCORElist **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct set_USCORErelationship_USCORElist **)soap_malloc(soap, sizeof(struct set_USCORErelationship_USCORElist *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_set_USCORErelationship_USCORElist(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct set_USCORErelationship_USCORElist **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_set_USCORErelationship_USCORElist, sizeof(struct set_USCORErelationship_USCORElist), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__set_USCORErelationship_USCORElist_USCOREresult(struct soap *soap, struct ns1__set_USCORErelationship_USCORElist_USCOREresult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__set_USCORErelationship_USCORElist_USCOREresult))
		soap_serialize_ns1__set_USCORErelationship_USCORElist_USCOREresult(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__set_USCORErelationship_USCORElist_USCOREresult(struct soap *soap, struct ns1__set_USCORErelationship_USCORElist_USCOREresult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__set_USCORErelationship_USCORElist_USCOREresult);
	if (soap_out_PointerTons1__set_USCORErelationship_USCORElist_USCOREresult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__set_USCORErelationship_USCORElist_USCOREresult(struct soap *soap, const char *tag, int id, struct ns1__set_USCORErelationship_USCORElist_USCOREresult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__set_USCORErelationship_USCORElist_USCOREresult);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__set_USCORErelationship_USCORElist_USCOREresult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__set_USCORErelationship_USCORElist_USCOREresult ** SOAP_FMAC4 soap_get_PointerTons1__set_USCORErelationship_USCORElist_USCOREresult(struct soap *soap, struct ns1__set_USCORErelationship_USCORElist_USCOREresult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__set_USCORErelationship_USCORElist_USCOREresult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__set_USCORErelationship_USCORElist_USCOREresult ** SOAP_FMAC4 soap_in_PointerTons1__set_USCORErelationship_USCORElist_USCOREresult(struct soap *soap, const char *tag, struct ns1__set_USCORErelationship_USCORElist_USCOREresult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__set_USCORErelationship_USCORElist_USCOREresult **)soap_malloc(soap, sizeof(struct ns1__set_USCORErelationship_USCORElist_USCOREresult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__set_USCORErelationship_USCORElist_USCOREresult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCORErelationship_USCORElist_USCOREresult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__set_USCORErelationship_USCORElist_USCOREresult, sizeof(struct ns1__set_USCORErelationship_USCORElist_USCOREresult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__set_USCORErelationshipResponse(struct soap *soap, struct ns1__set_USCORErelationshipResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__set_USCORErelationshipResponse))
		soap_serialize_ns1__set_USCORErelationshipResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__set_USCORErelationshipResponse(struct soap *soap, struct ns1__set_USCORErelationshipResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__set_USCORErelationshipResponse);
	if (soap_out_PointerTons1__set_USCORErelationshipResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__set_USCORErelationshipResponse(struct soap *soap, const char *tag, int id, struct ns1__set_USCORErelationshipResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__set_USCORErelationshipResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__set_USCORErelationshipResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__set_USCORErelationshipResponse ** SOAP_FMAC4 soap_get_PointerTons1__set_USCORErelationshipResponse(struct soap *soap, struct ns1__set_USCORErelationshipResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__set_USCORErelationshipResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__set_USCORErelationshipResponse ** SOAP_FMAC4 soap_in_PointerTons1__set_USCORErelationshipResponse(struct soap *soap, const char *tag, struct ns1__set_USCORErelationshipResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__set_USCORErelationshipResponse **)soap_malloc(soap, sizeof(struct ns1__set_USCORErelationshipResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__set_USCORErelationshipResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCORErelationshipResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__set_USCORErelationshipResponse, sizeof(struct ns1__set_USCORErelationshipResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__get_USCORErelationshipsResponse(struct soap *soap, struct ns1__get_USCORErelationshipsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__get_USCORErelationshipsResponse))
		soap_serialize_ns1__get_USCORErelationshipsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__get_USCORErelationshipsResponse(struct soap *soap, struct ns1__get_USCORErelationshipsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__get_USCORErelationshipsResponse);
	if (soap_out_PointerTons1__get_USCORErelationshipsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__get_USCORErelationshipsResponse(struct soap *soap, const char *tag, int id, struct ns1__get_USCORErelationshipsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__get_USCORErelationshipsResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__get_USCORErelationshipsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__get_USCORErelationshipsResponse ** SOAP_FMAC4 soap_get_PointerTons1__get_USCORErelationshipsResponse(struct soap *soap, struct ns1__get_USCORErelationshipsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__get_USCORErelationshipsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCORErelationshipsResponse ** SOAP_FMAC4 soap_in_PointerTons1__get_USCORErelationshipsResponse(struct soap *soap, const char *tag, struct ns1__get_USCORErelationshipsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__get_USCORErelationshipsResponse **)soap_malloc(soap, sizeof(struct ns1__get_USCORErelationshipsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__get_USCORErelationshipsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCORErelationshipsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__get_USCORErelationshipsResponse, sizeof(struct ns1__get_USCORErelationshipsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__get_USCORErelationships_USCOREresult(struct soap *soap, struct ns1__get_USCORErelationships_USCOREresult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__get_USCORErelationships_USCOREresult))
		soap_serialize_ns1__get_USCORErelationships_USCOREresult(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__get_USCORErelationships_USCOREresult(struct soap *soap, struct ns1__get_USCORErelationships_USCOREresult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__get_USCORErelationships_USCOREresult);
	if (soap_out_PointerTons1__get_USCORErelationships_USCOREresult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__get_USCORErelationships_USCOREresult(struct soap *soap, const char *tag, int id, struct ns1__get_USCORErelationships_USCOREresult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__get_USCORErelationships_USCOREresult);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__get_USCORErelationships_USCOREresult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__get_USCORErelationships_USCOREresult ** SOAP_FMAC4 soap_get_PointerTons1__get_USCORErelationships_USCOREresult(struct soap *soap, struct ns1__get_USCORErelationships_USCOREresult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__get_USCORErelationships_USCOREresult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCORErelationships_USCOREresult ** SOAP_FMAC4 soap_in_PointerTons1__get_USCORErelationships_USCOREresult(struct soap *soap, const char *tag, struct ns1__get_USCORErelationships_USCOREresult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__get_USCORErelationships_USCOREresult **)soap_malloc(soap, sizeof(struct ns1__get_USCORErelationships_USCOREresult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__get_USCORErelationships_USCOREresult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCORErelationships_USCOREresult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__get_USCORErelationships_USCOREresult, sizeof(struct ns1__get_USCORErelationships_USCOREresult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__update_USCOREportal_USCOREuserResponse(struct soap *soap, struct ns1__update_USCOREportal_USCOREuserResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__update_USCOREportal_USCOREuserResponse))
		soap_serialize_ns1__update_USCOREportal_USCOREuserResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__update_USCOREportal_USCOREuserResponse(struct soap *soap, struct ns1__update_USCOREportal_USCOREuserResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__update_USCOREportal_USCOREuserResponse);
	if (soap_out_PointerTons1__update_USCOREportal_USCOREuserResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__update_USCOREportal_USCOREuserResponse(struct soap *soap, const char *tag, int id, struct ns1__update_USCOREportal_USCOREuserResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__update_USCOREportal_USCOREuserResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__update_USCOREportal_USCOREuserResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__update_USCOREportal_USCOREuserResponse ** SOAP_FMAC4 soap_get_PointerTons1__update_USCOREportal_USCOREuserResponse(struct soap *soap, struct ns1__update_USCOREportal_USCOREuserResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__update_USCOREportal_USCOREuserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__update_USCOREportal_USCOREuserResponse ** SOAP_FMAC4 soap_in_PointerTons1__update_USCOREportal_USCOREuserResponse(struct soap *soap, const char *tag, struct ns1__update_USCOREportal_USCOREuserResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__update_USCOREportal_USCOREuserResponse **)soap_malloc(soap, sizeof(struct ns1__update_USCOREportal_USCOREuserResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__update_USCOREportal_USCOREuserResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__update_USCOREportal_USCOREuserResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__update_USCOREportal_USCOREuserResponse, sizeof(struct ns1__update_USCOREportal_USCOREuserResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__get_USCOREavailable_USCOREmodulesResponse(struct soap *soap, struct ns1__get_USCOREavailable_USCOREmodulesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__get_USCOREavailable_USCOREmodulesResponse))
		soap_serialize_ns1__get_USCOREavailable_USCOREmodulesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__get_USCOREavailable_USCOREmodulesResponse(struct soap *soap, struct ns1__get_USCOREavailable_USCOREmodulesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__get_USCOREavailable_USCOREmodulesResponse);
	if (soap_out_PointerTons1__get_USCOREavailable_USCOREmodulesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__get_USCOREavailable_USCOREmodulesResponse(struct soap *soap, const char *tag, int id, struct ns1__get_USCOREavailable_USCOREmodulesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__get_USCOREavailable_USCOREmodulesResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__get_USCOREavailable_USCOREmodulesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__get_USCOREavailable_USCOREmodulesResponse ** SOAP_FMAC4 soap_get_PointerTons1__get_USCOREavailable_USCOREmodulesResponse(struct soap *soap, struct ns1__get_USCOREavailable_USCOREmodulesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__get_USCOREavailable_USCOREmodulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREavailable_USCOREmodulesResponse ** SOAP_FMAC4 soap_in_PointerTons1__get_USCOREavailable_USCOREmodulesResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREavailable_USCOREmodulesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__get_USCOREavailable_USCOREmodulesResponse **)soap_malloc(soap, sizeof(struct ns1__get_USCOREavailable_USCOREmodulesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__get_USCOREavailable_USCOREmodulesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREavailable_USCOREmodulesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__get_USCOREavailable_USCOREmodulesResponse, sizeof(struct ns1__get_USCOREavailable_USCOREmodulesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__module_USCORElist(struct soap *soap, struct ns1__module_USCORElist *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__module_USCORElist))
		soap_serialize_ns1__module_USCORElist(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__module_USCORElist(struct soap *soap, struct ns1__module_USCORElist *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__module_USCORElist);
	if (soap_out_PointerTons1__module_USCORElist(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__module_USCORElist(struct soap *soap, const char *tag, int id, struct ns1__module_USCORElist *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__module_USCORElist);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__module_USCORElist(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__module_USCORElist ** SOAP_FMAC4 soap_get_PointerTons1__module_USCORElist(struct soap *soap, struct ns1__module_USCORElist **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__module_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__module_USCORElist ** SOAP_FMAC4 soap_in_PointerTons1__module_USCORElist(struct soap *soap, const char *tag, struct ns1__module_USCORElist **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__module_USCORElist **)soap_malloc(soap, sizeof(struct ns1__module_USCORElist *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__module_USCORElist(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__module_USCORElist **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__module_USCORElist, sizeof(struct ns1__module_USCORElist), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__get_USCOREmodule_USCOREfieldsResponse(struct soap *soap, struct ns1__get_USCOREmodule_USCOREfieldsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__get_USCOREmodule_USCOREfieldsResponse))
		soap_serialize_ns1__get_USCOREmodule_USCOREfieldsResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__get_USCOREmodule_USCOREfieldsResponse(struct soap *soap, struct ns1__get_USCOREmodule_USCOREfieldsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__get_USCOREmodule_USCOREfieldsResponse);
	if (soap_out_PointerTons1__get_USCOREmodule_USCOREfieldsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__get_USCOREmodule_USCOREfieldsResponse(struct soap *soap, const char *tag, int id, struct ns1__get_USCOREmodule_USCOREfieldsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__get_USCOREmodule_USCOREfieldsResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__get_USCOREmodule_USCOREfieldsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__get_USCOREmodule_USCOREfieldsResponse ** SOAP_FMAC4 soap_get_PointerTons1__get_USCOREmodule_USCOREfieldsResponse(struct soap *soap, struct ns1__get_USCOREmodule_USCOREfieldsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__get_USCOREmodule_USCOREfieldsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREmodule_USCOREfieldsResponse ** SOAP_FMAC4 soap_in_PointerTons1__get_USCOREmodule_USCOREfieldsResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREmodule_USCOREfieldsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__get_USCOREmodule_USCOREfieldsResponse **)soap_malloc(soap, sizeof(struct ns1__get_USCOREmodule_USCOREfieldsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__get_USCOREmodule_USCOREfieldsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREmodule_USCOREfieldsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__get_USCOREmodule_USCOREfieldsResponse, sizeof(struct ns1__get_USCOREmodule_USCOREfieldsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__module_USCOREfields(struct soap *soap, struct ns1__module_USCOREfields *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__module_USCOREfields))
		soap_serialize_ns1__module_USCOREfields(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__module_USCOREfields(struct soap *soap, struct ns1__module_USCOREfields *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__module_USCOREfields);
	if (soap_out_PointerTons1__module_USCOREfields(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__module_USCOREfields(struct soap *soap, const char *tag, int id, struct ns1__module_USCOREfields *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__module_USCOREfields);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__module_USCOREfields(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__module_USCOREfields ** SOAP_FMAC4 soap_get_PointerTons1__module_USCOREfields(struct soap *soap, struct ns1__module_USCOREfields **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__module_USCOREfields(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__module_USCOREfields ** SOAP_FMAC4 soap_in_PointerTons1__module_USCOREfields(struct soap *soap, const char *tag, struct ns1__module_USCOREfields **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__module_USCOREfields **)soap_malloc(soap, sizeof(struct ns1__module_USCOREfields *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__module_USCOREfields(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__module_USCOREfields **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__module_USCOREfields, sizeof(struct ns1__module_USCOREfields), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__logoutResponse(struct soap *soap, struct ns1__logoutResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__logoutResponse))
		soap_serialize_ns1__logoutResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__logoutResponse(struct soap *soap, struct ns1__logoutResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__logoutResponse);
	if (soap_out_PointerTons1__logoutResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__logoutResponse(struct soap *soap, const char *tag, int id, struct ns1__logoutResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__logoutResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__logoutResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__logoutResponse ** SOAP_FMAC4 soap_get_PointerTons1__logoutResponse(struct soap *soap, struct ns1__logoutResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__logoutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__logoutResponse ** SOAP_FMAC4 soap_in_PointerTons1__logoutResponse(struct soap *soap, const char *tag, struct ns1__logoutResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__logoutResponse **)soap_malloc(soap, sizeof(struct ns1__logoutResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__logoutResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__logoutResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__logoutResponse, sizeof(struct ns1__logoutResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__get_USCORErelated_USCOREnotesResponse(struct soap *soap, struct ns1__get_USCORErelated_USCOREnotesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__get_USCORErelated_USCOREnotesResponse))
		soap_serialize_ns1__get_USCORErelated_USCOREnotesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__get_USCORErelated_USCOREnotesResponse(struct soap *soap, struct ns1__get_USCORErelated_USCOREnotesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__get_USCORErelated_USCOREnotesResponse);
	if (soap_out_PointerTons1__get_USCORErelated_USCOREnotesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__get_USCORErelated_USCOREnotesResponse(struct soap *soap, const char *tag, int id, struct ns1__get_USCORErelated_USCOREnotesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__get_USCORErelated_USCOREnotesResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__get_USCORErelated_USCOREnotesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__get_USCORErelated_USCOREnotesResponse ** SOAP_FMAC4 soap_get_PointerTons1__get_USCORErelated_USCOREnotesResponse(struct soap *soap, struct ns1__get_USCORErelated_USCOREnotesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__get_USCORErelated_USCOREnotesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCORErelated_USCOREnotesResponse ** SOAP_FMAC4 soap_in_PointerTons1__get_USCORErelated_USCOREnotesResponse(struct soap *soap, const char *tag, struct ns1__get_USCORErelated_USCOREnotesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__get_USCORErelated_USCOREnotesResponse **)soap_malloc(soap, sizeof(struct ns1__get_USCORErelated_USCOREnotesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__get_USCORErelated_USCOREnotesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCORErelated_USCOREnotesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__get_USCORErelated_USCOREnotesResponse, sizeof(struct ns1__get_USCORErelated_USCOREnotesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__relate_USCOREnote_USCOREto_USCOREmoduleResponse(struct soap *soap, struct ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse))
		soap_serialize_ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__relate_USCOREnote_USCOREto_USCOREmoduleResponse(struct soap *soap, struct ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__relate_USCOREnote_USCOREto_USCOREmoduleResponse);
	if (soap_out_PointerTons1__relate_USCOREnote_USCOREto_USCOREmoduleResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__relate_USCOREnote_USCOREto_USCOREmoduleResponse(struct soap *soap, const char *tag, int id, struct ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse ** SOAP_FMAC4 soap_get_PointerTons1__relate_USCOREnote_USCOREto_USCOREmoduleResponse(struct soap *soap, struct ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__relate_USCOREnote_USCOREto_USCOREmoduleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse ** SOAP_FMAC4 soap_in_PointerTons1__relate_USCOREnote_USCOREto_USCOREmoduleResponse(struct soap *soap, const char *tag, struct ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse **)soap_malloc(soap, sizeof(struct ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse, sizeof(struct ns1__relate_USCOREnote_USCOREto_USCOREmoduleResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__get_USCOREnote_USCOREattachmentResponse(struct soap *soap, struct ns1__get_USCOREnote_USCOREattachmentResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__get_USCOREnote_USCOREattachmentResponse))
		soap_serialize_ns1__get_USCOREnote_USCOREattachmentResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__get_USCOREnote_USCOREattachmentResponse(struct soap *soap, struct ns1__get_USCOREnote_USCOREattachmentResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__get_USCOREnote_USCOREattachmentResponse);
	if (soap_out_PointerTons1__get_USCOREnote_USCOREattachmentResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__get_USCOREnote_USCOREattachmentResponse(struct soap *soap, const char *tag, int id, struct ns1__get_USCOREnote_USCOREattachmentResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__get_USCOREnote_USCOREattachmentResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__get_USCOREnote_USCOREattachmentResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__get_USCOREnote_USCOREattachmentResponse ** SOAP_FMAC4 soap_get_PointerTons1__get_USCOREnote_USCOREattachmentResponse(struct soap *soap, struct ns1__get_USCOREnote_USCOREattachmentResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__get_USCOREnote_USCOREattachmentResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREnote_USCOREattachmentResponse ** SOAP_FMAC4 soap_in_PointerTons1__get_USCOREnote_USCOREattachmentResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREnote_USCOREattachmentResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__get_USCOREnote_USCOREattachmentResponse **)soap_malloc(soap, sizeof(struct ns1__get_USCOREnote_USCOREattachmentResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__get_USCOREnote_USCOREattachmentResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREnote_USCOREattachmentResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__get_USCOREnote_USCOREattachmentResponse, sizeof(struct ns1__get_USCOREnote_USCOREattachmentResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__return_USCOREnote_USCOREattachment(struct soap *soap, struct ns1__return_USCOREnote_USCOREattachment *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__return_USCOREnote_USCOREattachment))
		soap_serialize_ns1__return_USCOREnote_USCOREattachment(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__return_USCOREnote_USCOREattachment(struct soap *soap, struct ns1__return_USCOREnote_USCOREattachment *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__return_USCOREnote_USCOREattachment);
	if (soap_out_PointerTons1__return_USCOREnote_USCOREattachment(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__return_USCOREnote_USCOREattachment(struct soap *soap, const char *tag, int id, struct ns1__return_USCOREnote_USCOREattachment *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__return_USCOREnote_USCOREattachment);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__return_USCOREnote_USCOREattachment(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__return_USCOREnote_USCOREattachment ** SOAP_FMAC4 soap_get_PointerTons1__return_USCOREnote_USCOREattachment(struct soap *soap, struct ns1__return_USCOREnote_USCOREattachment **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__return_USCOREnote_USCOREattachment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__return_USCOREnote_USCOREattachment ** SOAP_FMAC4 soap_in_PointerTons1__return_USCOREnote_USCOREattachment(struct soap *soap, const char *tag, struct ns1__return_USCOREnote_USCOREattachment **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__return_USCOREnote_USCOREattachment **)soap_malloc(soap, sizeof(struct ns1__return_USCOREnote_USCOREattachment *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__return_USCOREnote_USCOREattachment(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__return_USCOREnote_USCOREattachment **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__return_USCOREnote_USCOREattachment, sizeof(struct ns1__return_USCOREnote_USCOREattachment), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__set_USCOREnote_USCOREattachmentResponse(struct soap *soap, struct ns1__set_USCOREnote_USCOREattachmentResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__set_USCOREnote_USCOREattachmentResponse))
		soap_serialize_ns1__set_USCOREnote_USCOREattachmentResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__set_USCOREnote_USCOREattachmentResponse(struct soap *soap, struct ns1__set_USCOREnote_USCOREattachmentResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__set_USCOREnote_USCOREattachmentResponse);
	if (soap_out_PointerTons1__set_USCOREnote_USCOREattachmentResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__set_USCOREnote_USCOREattachmentResponse(struct soap *soap, const char *tag, int id, struct ns1__set_USCOREnote_USCOREattachmentResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__set_USCOREnote_USCOREattachmentResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__set_USCOREnote_USCOREattachmentResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__set_USCOREnote_USCOREattachmentResponse ** SOAP_FMAC4 soap_get_PointerTons1__set_USCOREnote_USCOREattachmentResponse(struct soap *soap, struct ns1__set_USCOREnote_USCOREattachmentResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__set_USCOREnote_USCOREattachmentResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__set_USCOREnote_USCOREattachmentResponse ** SOAP_FMAC4 soap_in_PointerTons1__set_USCOREnote_USCOREattachmentResponse(struct soap *soap, const char *tag, struct ns1__set_USCOREnote_USCOREattachmentResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__set_USCOREnote_USCOREattachmentResponse **)soap_malloc(soap, sizeof(struct ns1__set_USCOREnote_USCOREattachmentResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__set_USCOREnote_USCOREattachmentResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCOREnote_USCOREattachmentResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__set_USCOREnote_USCOREattachmentResponse, sizeof(struct ns1__set_USCOREnote_USCOREattachmentResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__set_USCOREentriesResponse(struct soap *soap, struct ns1__set_USCOREentriesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__set_USCOREentriesResponse))
		soap_serialize_ns1__set_USCOREentriesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__set_USCOREentriesResponse(struct soap *soap, struct ns1__set_USCOREentriesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__set_USCOREentriesResponse);
	if (soap_out_PointerTons1__set_USCOREentriesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__set_USCOREentriesResponse(struct soap *soap, const char *tag, int id, struct ns1__set_USCOREentriesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__set_USCOREentriesResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__set_USCOREentriesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__set_USCOREentriesResponse ** SOAP_FMAC4 soap_get_PointerTons1__set_USCOREentriesResponse(struct soap *soap, struct ns1__set_USCOREentriesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__set_USCOREentriesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__set_USCOREentriesResponse ** SOAP_FMAC4 soap_in_PointerTons1__set_USCOREentriesResponse(struct soap *soap, const char *tag, struct ns1__set_USCOREentriesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__set_USCOREentriesResponse **)soap_malloc(soap, sizeof(struct ns1__set_USCOREentriesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__set_USCOREentriesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCOREentriesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__set_USCOREentriesResponse, sizeof(struct ns1__set_USCOREentriesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__set_USCOREentries_USCOREresult(struct soap *soap, struct ns1__set_USCOREentries_USCOREresult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__set_USCOREentries_USCOREresult))
		soap_serialize_ns1__set_USCOREentries_USCOREresult(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__set_USCOREentries_USCOREresult(struct soap *soap, struct ns1__set_USCOREentries_USCOREresult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__set_USCOREentries_USCOREresult);
	if (soap_out_PointerTons1__set_USCOREentries_USCOREresult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__set_USCOREentries_USCOREresult(struct soap *soap, const char *tag, int id, struct ns1__set_USCOREentries_USCOREresult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__set_USCOREentries_USCOREresult);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__set_USCOREentries_USCOREresult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__set_USCOREentries_USCOREresult ** SOAP_FMAC4 soap_get_PointerTons1__set_USCOREentries_USCOREresult(struct soap *soap, struct ns1__set_USCOREentries_USCOREresult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__set_USCOREentries_USCOREresult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__set_USCOREentries_USCOREresult ** SOAP_FMAC4 soap_in_PointerTons1__set_USCOREentries_USCOREresult(struct soap *soap, const char *tag, struct ns1__set_USCOREentries_USCOREresult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__set_USCOREentries_USCOREresult **)soap_malloc(soap, sizeof(struct ns1__set_USCOREentries_USCOREresult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__set_USCOREentries_USCOREresult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCOREentries_USCOREresult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__set_USCOREentries_USCOREresult, sizeof(struct ns1__set_USCOREentries_USCOREresult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__set_USCOREentryResponse(struct soap *soap, struct ns1__set_USCOREentryResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__set_USCOREentryResponse))
		soap_serialize_ns1__set_USCOREentryResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__set_USCOREentryResponse(struct soap *soap, struct ns1__set_USCOREentryResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__set_USCOREentryResponse);
	if (soap_out_PointerTons1__set_USCOREentryResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__set_USCOREentryResponse(struct soap *soap, const char *tag, int id, struct ns1__set_USCOREentryResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__set_USCOREentryResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__set_USCOREentryResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__set_USCOREentryResponse ** SOAP_FMAC4 soap_get_PointerTons1__set_USCOREentryResponse(struct soap *soap, struct ns1__set_USCOREentryResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__set_USCOREentryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__set_USCOREentryResponse ** SOAP_FMAC4 soap_in_PointerTons1__set_USCOREentryResponse(struct soap *soap, const char *tag, struct ns1__set_USCOREentryResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__set_USCOREentryResponse **)soap_malloc(soap, sizeof(struct ns1__set_USCOREentryResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__set_USCOREentryResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCOREentryResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__set_USCOREentryResponse, sizeof(struct ns1__set_USCOREentryResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__get_USCOREentriesResponse(struct soap *soap, struct ns1__get_USCOREentriesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__get_USCOREentriesResponse))
		soap_serialize_ns1__get_USCOREentriesResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__get_USCOREentriesResponse(struct soap *soap, struct ns1__get_USCOREentriesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__get_USCOREentriesResponse);
	if (soap_out_PointerTons1__get_USCOREentriesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__get_USCOREentriesResponse(struct soap *soap, const char *tag, int id, struct ns1__get_USCOREentriesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__get_USCOREentriesResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__get_USCOREentriesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__get_USCOREentriesResponse ** SOAP_FMAC4 soap_get_PointerTons1__get_USCOREentriesResponse(struct soap *soap, struct ns1__get_USCOREentriesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__get_USCOREentriesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREentriesResponse ** SOAP_FMAC4 soap_in_PointerTons1__get_USCOREentriesResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREentriesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__get_USCOREentriesResponse **)soap_malloc(soap, sizeof(struct ns1__get_USCOREentriesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__get_USCOREentriesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREentriesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__get_USCOREentriesResponse, sizeof(struct ns1__get_USCOREentriesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__get_USCOREentryResponse(struct soap *soap, struct ns1__get_USCOREentryResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__get_USCOREentryResponse))
		soap_serialize_ns1__get_USCOREentryResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__get_USCOREentryResponse(struct soap *soap, struct ns1__get_USCOREentryResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__get_USCOREentryResponse);
	if (soap_out_PointerTons1__get_USCOREentryResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__get_USCOREentryResponse(struct soap *soap, const char *tag, int id, struct ns1__get_USCOREentryResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__get_USCOREentryResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__get_USCOREentryResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__get_USCOREentryResponse ** SOAP_FMAC4 soap_get_PointerTons1__get_USCOREentryResponse(struct soap *soap, struct ns1__get_USCOREentryResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__get_USCOREentryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREentryResponse ** SOAP_FMAC4 soap_in_PointerTons1__get_USCOREentryResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREentryResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__get_USCOREentryResponse **)soap_malloc(soap, sizeof(struct ns1__get_USCOREentryResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__get_USCOREentryResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREentryResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__get_USCOREentryResponse, sizeof(struct ns1__get_USCOREentryResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__get_USCOREentry_USCOREresult(struct soap *soap, struct ns1__get_USCOREentry_USCOREresult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__get_USCOREentry_USCOREresult))
		soap_serialize_ns1__get_USCOREentry_USCOREresult(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__get_USCOREentry_USCOREresult(struct soap *soap, struct ns1__get_USCOREentry_USCOREresult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__get_USCOREentry_USCOREresult);
	if (soap_out_PointerTons1__get_USCOREentry_USCOREresult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__get_USCOREentry_USCOREresult(struct soap *soap, const char *tag, int id, struct ns1__get_USCOREentry_USCOREresult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__get_USCOREentry_USCOREresult);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__get_USCOREentry_USCOREresult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__get_USCOREentry_USCOREresult ** SOAP_FMAC4 soap_get_PointerTons1__get_USCOREentry_USCOREresult(struct soap *soap, struct ns1__get_USCOREentry_USCOREresult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__get_USCOREentry_USCOREresult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREentry_USCOREresult ** SOAP_FMAC4 soap_in_PointerTons1__get_USCOREentry_USCOREresult(struct soap *soap, const char *tag, struct ns1__get_USCOREentry_USCOREresult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__get_USCOREentry_USCOREresult **)soap_malloc(soap, sizeof(struct ns1__get_USCOREentry_USCOREresult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__get_USCOREentry_USCOREresult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREentry_USCOREresult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__get_USCOREentry_USCOREresult, sizeof(struct ns1__get_USCOREentry_USCOREresult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__get_USCOREentry_USCORElistResponse(struct soap *soap, struct ns1__get_USCOREentry_USCORElistResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__get_USCOREentry_USCORElistResponse))
		soap_serialize_ns1__get_USCOREentry_USCORElistResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__get_USCOREentry_USCORElistResponse(struct soap *soap, struct ns1__get_USCOREentry_USCORElistResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__get_USCOREentry_USCORElistResponse);
	if (soap_out_PointerTons1__get_USCOREentry_USCORElistResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__get_USCOREentry_USCORElistResponse(struct soap *soap, const char *tag, int id, struct ns1__get_USCOREentry_USCORElistResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__get_USCOREentry_USCORElistResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__get_USCOREentry_USCORElistResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__get_USCOREentry_USCORElistResponse ** SOAP_FMAC4 soap_get_PointerTons1__get_USCOREentry_USCORElistResponse(struct soap *soap, struct ns1__get_USCOREentry_USCORElistResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__get_USCOREentry_USCORElistResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREentry_USCORElistResponse ** SOAP_FMAC4 soap_in_PointerTons1__get_USCOREentry_USCORElistResponse(struct soap *soap, const char *tag, struct ns1__get_USCOREentry_USCORElistResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__get_USCOREentry_USCORElistResponse **)soap_malloc(soap, sizeof(struct ns1__get_USCOREentry_USCORElistResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__get_USCOREentry_USCORElistResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREentry_USCORElistResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__get_USCOREentry_USCORElistResponse, sizeof(struct ns1__get_USCOREentry_USCORElistResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__get_USCOREentry_USCORElist_USCOREresult(struct soap *soap, struct ns1__get_USCOREentry_USCORElist_USCOREresult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__get_USCOREentry_USCORElist_USCOREresult))
		soap_serialize_ns1__get_USCOREentry_USCORElist_USCOREresult(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__get_USCOREentry_USCORElist_USCOREresult(struct soap *soap, struct ns1__get_USCOREentry_USCORElist_USCOREresult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__get_USCOREentry_USCORElist_USCOREresult);
	if (soap_out_PointerTons1__get_USCOREentry_USCORElist_USCOREresult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__get_USCOREentry_USCORElist_USCOREresult(struct soap *soap, const char *tag, int id, struct ns1__get_USCOREentry_USCORElist_USCOREresult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__get_USCOREentry_USCORElist_USCOREresult);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__get_USCOREentry_USCORElist_USCOREresult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__get_USCOREentry_USCORElist_USCOREresult ** SOAP_FMAC4 soap_get_PointerTons1__get_USCOREentry_USCORElist_USCOREresult(struct soap *soap, struct ns1__get_USCOREentry_USCORElist_USCOREresult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__get_USCOREentry_USCORElist_USCOREresult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__get_USCOREentry_USCORElist_USCOREresult ** SOAP_FMAC4 soap_in_PointerTons1__get_USCOREentry_USCORElist_USCOREresult(struct soap *soap, const char *tag, struct ns1__get_USCOREentry_USCORElist_USCOREresult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__get_USCOREentry_USCORElist_USCOREresult **)soap_malloc(soap, sizeof(struct ns1__get_USCOREentry_USCORElist_USCOREresult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__get_USCOREentry_USCORElist_USCOREresult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__get_USCOREentry_USCORElist_USCOREresult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__get_USCOREentry_USCORElist_USCOREresult, sizeof(struct ns1__get_USCOREentry_USCORElist_USCOREresult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__loginResponse(struct soap *soap, struct ns1__loginResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__loginResponse))
		soap_serialize_ns1__loginResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__loginResponse(struct soap *soap, struct ns1__loginResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__loginResponse);
	if (soap_out_PointerTons1__loginResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__loginResponse(struct soap *soap, const char *tag, int id, struct ns1__loginResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__loginResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__loginResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__loginResponse ** SOAP_FMAC4 soap_get_PointerTons1__loginResponse(struct soap *soap, struct ns1__loginResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__loginResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__loginResponse ** SOAP_FMAC4 soap_in_PointerTons1__loginResponse(struct soap *soap, const char *tag, struct ns1__loginResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__loginResponse **)soap_malloc(soap, sizeof(struct ns1__loginResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__loginResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__loginResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__loginResponse, sizeof(struct ns1__loginResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__user_USCOREauth(struct soap *soap, struct ns1__user_USCOREauth *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__user_USCOREauth))
		soap_serialize_ns1__user_USCOREauth(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__user_USCOREauth(struct soap *soap, struct ns1__user_USCOREauth *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__user_USCOREauth);
	if (soap_out_PointerTons1__user_USCOREauth(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__user_USCOREauth(struct soap *soap, const char *tag, int id, struct ns1__user_USCOREauth *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__user_USCOREauth);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__user_USCOREauth(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__user_USCOREauth ** SOAP_FMAC4 soap_get_PointerTons1__user_USCOREauth(struct soap *soap, struct ns1__user_USCOREauth **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__user_USCOREauth(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__user_USCOREauth ** SOAP_FMAC4 soap_in_PointerTons1__user_USCOREauth(struct soap *soap, const char *tag, struct ns1__user_USCOREauth **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__user_USCOREauth **)soap_malloc(soap, sizeof(struct ns1__user_USCOREauth *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__user_USCOREauth(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__user_USCOREauth **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__user_USCOREauth, sizeof(struct ns1__user_USCOREauth), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__set_USCOREentry_USCOREresult(struct soap *soap, struct ns1__set_USCOREentry_USCOREresult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__set_USCOREentry_USCOREresult))
		soap_serialize_ns1__set_USCOREentry_USCOREresult(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__set_USCOREentry_USCOREresult(struct soap *soap, struct ns1__set_USCOREentry_USCOREresult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__set_USCOREentry_USCOREresult);
	if (soap_out_PointerTons1__set_USCOREentry_USCOREresult(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__set_USCOREentry_USCOREresult(struct soap *soap, const char *tag, int id, struct ns1__set_USCOREentry_USCOREresult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__set_USCOREentry_USCOREresult);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__set_USCOREentry_USCOREresult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__set_USCOREentry_USCOREresult ** SOAP_FMAC4 soap_get_PointerTons1__set_USCOREentry_USCOREresult(struct soap *soap, struct ns1__set_USCOREentry_USCOREresult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__set_USCOREentry_USCOREresult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__set_USCOREentry_USCOREresult ** SOAP_FMAC4 soap_in_PointerTons1__set_USCOREentry_USCOREresult(struct soap *soap, const char *tag, struct ns1__set_USCOREentry_USCOREresult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__set_USCOREentry_USCOREresult **)soap_malloc(soap, sizeof(struct ns1__set_USCOREentry_USCOREresult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__set_USCOREentry_USCOREresult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCOREentry_USCOREresult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__set_USCOREentry_USCOREresult, sizeof(struct ns1__set_USCOREentry_USCOREresult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__user_USCOREdetail(struct soap *soap, struct ns1__user_USCOREdetail **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__user_USCOREdetail))
		soap_serialize_PointerTons1__user_USCOREdetail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__user_USCOREdetail(struct soap *soap, struct ns1__user_USCOREdetail **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__user_USCOREdetail);
	if (soap_out_PointerToPointerTons1__user_USCOREdetail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__user_USCOREdetail(struct soap *soap, const char *tag, int id, struct ns1__user_USCOREdetail **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__user_USCOREdetail);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__user_USCOREdetail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__user_USCOREdetail *** SOAP_FMAC4 soap_get_PointerToPointerTons1__user_USCOREdetail(struct soap *soap, struct ns1__user_USCOREdetail ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__user_USCOREdetail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__user_USCOREdetail *** SOAP_FMAC4 soap_in_PointerToPointerTons1__user_USCOREdetail(struct soap *soap, const char *tag, struct ns1__user_USCOREdetail ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__user_USCOREdetail ***)soap_malloc(soap, sizeof(struct ns1__user_USCOREdetail **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__user_USCOREdetail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__user_USCOREdetail ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__user_USCOREdetail, sizeof(struct ns1__user_USCOREdetail *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__user_USCOREdetail(struct soap *soap, struct ns1__user_USCOREdetail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__user_USCOREdetail))
		soap_serialize_ns1__user_USCOREdetail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__user_USCOREdetail(struct soap *soap, struct ns1__user_USCOREdetail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__user_USCOREdetail);
	if (soap_out_PointerTons1__user_USCOREdetail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__user_USCOREdetail(struct soap *soap, const char *tag, int id, struct ns1__user_USCOREdetail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__user_USCOREdetail);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__user_USCOREdetail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__user_USCOREdetail ** SOAP_FMAC4 soap_get_PointerTons1__user_USCOREdetail(struct soap *soap, struct ns1__user_USCOREdetail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__user_USCOREdetail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__user_USCOREdetail ** SOAP_FMAC4 soap_in_PointerTons1__user_USCOREdetail(struct soap *soap, const char *tag, struct ns1__user_USCOREdetail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__user_USCOREdetail **)soap_malloc(soap, sizeof(struct ns1__user_USCOREdetail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__user_USCOREdetail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__user_USCOREdetail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__user_USCOREdetail, sizeof(struct ns1__user_USCOREdetail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__contact_USCOREdetail(struct soap *soap, struct ns1__contact_USCOREdetail **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__contact_USCOREdetail))
		soap_serialize_PointerTons1__contact_USCOREdetail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__contact_USCOREdetail(struct soap *soap, struct ns1__contact_USCOREdetail **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__contact_USCOREdetail);
	if (soap_out_PointerToPointerTons1__contact_USCOREdetail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__contact_USCOREdetail(struct soap *soap, const char *tag, int id, struct ns1__contact_USCOREdetail **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__contact_USCOREdetail);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__contact_USCOREdetail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__contact_USCOREdetail *** SOAP_FMAC4 soap_get_PointerToPointerTons1__contact_USCOREdetail(struct soap *soap, struct ns1__contact_USCOREdetail ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__contact_USCOREdetail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__contact_USCOREdetail *** SOAP_FMAC4 soap_in_PointerToPointerTons1__contact_USCOREdetail(struct soap *soap, const char *tag, struct ns1__contact_USCOREdetail ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__contact_USCOREdetail ***)soap_malloc(soap, sizeof(struct ns1__contact_USCOREdetail **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__contact_USCOREdetail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__contact_USCOREdetail ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__contact_USCOREdetail, sizeof(struct ns1__contact_USCOREdetail *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__contact_USCOREdetail(struct soap *soap, struct ns1__contact_USCOREdetail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__contact_USCOREdetail))
		soap_serialize_ns1__contact_USCOREdetail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__contact_USCOREdetail(struct soap *soap, struct ns1__contact_USCOREdetail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__contact_USCOREdetail);
	if (soap_out_PointerTons1__contact_USCOREdetail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__contact_USCOREdetail(struct soap *soap, const char *tag, int id, struct ns1__contact_USCOREdetail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__contact_USCOREdetail);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__contact_USCOREdetail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__contact_USCOREdetail ** SOAP_FMAC4 soap_get_PointerTons1__contact_USCOREdetail(struct soap *soap, struct ns1__contact_USCOREdetail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__contact_USCOREdetail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__contact_USCOREdetail ** SOAP_FMAC4 soap_in_PointerTons1__contact_USCOREdetail(struct soap *soap, const char *tag, struct ns1__contact_USCOREdetail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__contact_USCOREdetail **)soap_malloc(soap, sizeof(struct ns1__contact_USCOREdetail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__contact_USCOREdetail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__contact_USCOREdetail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__contact_USCOREdetail, sizeof(struct ns1__contact_USCOREdetail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__newsletter(struct soap *soap, struct ns1__newsletter **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__newsletter))
		soap_serialize_PointerTons1__newsletter(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__newsletter(struct soap *soap, struct ns1__newsletter **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__newsletter);
	if (soap_out_PointerToPointerTons1__newsletter(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__newsletter(struct soap *soap, const char *tag, int id, struct ns1__newsletter **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__newsletter);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__newsletter(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__newsletter *** SOAP_FMAC4 soap_get_PointerToPointerTons1__newsletter(struct soap *soap, struct ns1__newsletter ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__newsletter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__newsletter *** SOAP_FMAC4 soap_in_PointerToPointerTons1__newsletter(struct soap *soap, const char *tag, struct ns1__newsletter ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__newsletter ***)soap_malloc(soap, sizeof(struct ns1__newsletter **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__newsletter(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__newsletter ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__newsletter, sizeof(struct ns1__newsletter *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__newsletter(struct soap *soap, struct ns1__newsletter *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__newsletter))
		soap_serialize_ns1__newsletter(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__newsletter(struct soap *soap, struct ns1__newsletter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__newsletter);
	if (soap_out_PointerTons1__newsletter(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__newsletter(struct soap *soap, const char *tag, int id, struct ns1__newsletter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__newsletter);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__newsletter(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__newsletter ** SOAP_FMAC4 soap_get_PointerTons1__newsletter(struct soap *soap, struct ns1__newsletter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__newsletter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__newsletter ** SOAP_FMAC4 soap_in_PointerTons1__newsletter(struct soap *soap, const char *tag, struct ns1__newsletter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__newsletter **)soap_malloc(soap, sizeof(struct ns1__newsletter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__newsletter(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__newsletter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__newsletter, sizeof(struct ns1__newsletter), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__name_USCOREvalue_USCOREoperator(struct soap *soap, struct ns1__name_USCOREvalue_USCOREoperator **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__name_USCOREvalue_USCOREoperator))
		soap_serialize_PointerTons1__name_USCOREvalue_USCOREoperator(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__name_USCOREvalue_USCOREoperator(struct soap *soap, struct ns1__name_USCOREvalue_USCOREoperator **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__name_USCOREvalue_USCOREoperator);
	if (soap_out_PointerToPointerTons1__name_USCOREvalue_USCOREoperator(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__name_USCOREvalue_USCOREoperator(struct soap *soap, const char *tag, int id, struct ns1__name_USCOREvalue_USCOREoperator **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__name_USCOREvalue_USCOREoperator);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__name_USCOREvalue_USCOREoperator(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__name_USCOREvalue_USCOREoperator *** SOAP_FMAC4 soap_get_PointerToPointerTons1__name_USCOREvalue_USCOREoperator(struct soap *soap, struct ns1__name_USCOREvalue_USCOREoperator ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__name_USCOREvalue_USCOREoperator(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__name_USCOREvalue_USCOREoperator *** SOAP_FMAC4 soap_in_PointerToPointerTons1__name_USCOREvalue_USCOREoperator(struct soap *soap, const char *tag, struct ns1__name_USCOREvalue_USCOREoperator ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__name_USCOREvalue_USCOREoperator ***)soap_malloc(soap, sizeof(struct ns1__name_USCOREvalue_USCOREoperator **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__name_USCOREvalue_USCOREoperator(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__name_USCOREvalue_USCOREoperator ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__name_USCOREvalue_USCOREoperator, sizeof(struct ns1__name_USCOREvalue_USCOREoperator *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__name_USCOREvalue_USCOREoperator(struct soap *soap, struct ns1__name_USCOREvalue_USCOREoperator *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__name_USCOREvalue_USCOREoperator))
		soap_serialize_ns1__name_USCOREvalue_USCOREoperator(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__name_USCOREvalue_USCOREoperator(struct soap *soap, struct ns1__name_USCOREvalue_USCOREoperator *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__name_USCOREvalue_USCOREoperator);
	if (soap_out_PointerTons1__name_USCOREvalue_USCOREoperator(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__name_USCOREvalue_USCOREoperator(struct soap *soap, const char *tag, int id, struct ns1__name_USCOREvalue_USCOREoperator *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__name_USCOREvalue_USCOREoperator);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__name_USCOREvalue_USCOREoperator(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__name_USCOREvalue_USCOREoperator ** SOAP_FMAC4 soap_get_PointerTons1__name_USCOREvalue_USCOREoperator(struct soap *soap, struct ns1__name_USCOREvalue_USCOREoperator **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__name_USCOREvalue_USCOREoperator(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__name_USCOREvalue_USCOREoperator ** SOAP_FMAC4 soap_in_PointerTons1__name_USCOREvalue_USCOREoperator(struct soap *soap, const char *tag, struct ns1__name_USCOREvalue_USCOREoperator **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__name_USCOREvalue_USCOREoperator **)soap_malloc(soap, sizeof(struct ns1__name_USCOREvalue_USCOREoperator *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__name_USCOREvalue_USCOREoperator(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__name_USCOREvalue_USCOREoperator **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__name_USCOREvalue_USCOREoperator, sizeof(struct ns1__name_USCOREvalue_USCOREoperator), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToselect_USCOREfields(struct soap *soap, struct select_USCOREfields **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerToselect_USCOREfields))
		soap_serialize_PointerToselect_USCOREfields(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToselect_USCOREfields(struct soap *soap, struct select_USCOREfields **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToselect_USCOREfields);
	if (soap_out_PointerToPointerToselect_USCOREfields(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToselect_USCOREfields(struct soap *soap, const char *tag, int id, struct select_USCOREfields **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToselect_USCOREfields);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToselect_USCOREfields(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct select_USCOREfields *** SOAP_FMAC4 soap_get_PointerToPointerToselect_USCOREfields(struct soap *soap, struct select_USCOREfields ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToselect_USCOREfields(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct select_USCOREfields *** SOAP_FMAC4 soap_in_PointerToPointerToselect_USCOREfields(struct soap *soap, const char *tag, struct select_USCOREfields ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct select_USCOREfields ***)soap_malloc(soap, sizeof(struct select_USCOREfields **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToselect_USCOREfields(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct select_USCOREfields ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToselect_USCOREfields, sizeof(struct select_USCOREfields *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__set_USCORErelationship_USCOREvalue(struct soap *soap, struct ns1__set_USCORErelationship_USCOREvalue **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__set_USCORErelationship_USCOREvalue))
		soap_serialize_PointerTons1__set_USCORErelationship_USCOREvalue(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__set_USCORErelationship_USCOREvalue(struct soap *soap, struct ns1__set_USCORErelationship_USCOREvalue **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__set_USCORErelationship_USCOREvalue);
	if (soap_out_PointerToPointerTons1__set_USCORErelationship_USCOREvalue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__set_USCORErelationship_USCOREvalue(struct soap *soap, const char *tag, int id, struct ns1__set_USCORErelationship_USCOREvalue **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__set_USCORErelationship_USCOREvalue);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__set_USCORErelationship_USCOREvalue(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__set_USCORErelationship_USCOREvalue *** SOAP_FMAC4 soap_get_PointerToPointerTons1__set_USCORErelationship_USCOREvalue(struct soap *soap, struct ns1__set_USCORErelationship_USCOREvalue ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__set_USCORErelationship_USCOREvalue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__set_USCORErelationship_USCOREvalue *** SOAP_FMAC4 soap_in_PointerToPointerTons1__set_USCORErelationship_USCOREvalue(struct soap *soap, const char *tag, struct ns1__set_USCORErelationship_USCOREvalue ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__set_USCORErelationship_USCOREvalue ***)soap_malloc(soap, sizeof(struct ns1__set_USCORErelationship_USCOREvalue **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__set_USCORErelationship_USCOREvalue(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCORErelationship_USCOREvalue ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__set_USCORErelationship_USCOREvalue, sizeof(struct ns1__set_USCORErelationship_USCOREvalue *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__set_USCORErelationship_USCOREvalue(struct soap *soap, struct ns1__set_USCORErelationship_USCOREvalue *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__set_USCORErelationship_USCOREvalue))
		soap_serialize_ns1__set_USCORErelationship_USCOREvalue(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__set_USCORErelationship_USCOREvalue(struct soap *soap, struct ns1__set_USCORErelationship_USCOREvalue *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__set_USCORErelationship_USCOREvalue);
	if (soap_out_PointerTons1__set_USCORErelationship_USCOREvalue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__set_USCORErelationship_USCOREvalue(struct soap *soap, const char *tag, int id, struct ns1__set_USCORErelationship_USCOREvalue *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__set_USCORErelationship_USCOREvalue);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__set_USCORErelationship_USCOREvalue(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__set_USCORErelationship_USCOREvalue ** SOAP_FMAC4 soap_get_PointerTons1__set_USCORErelationship_USCOREvalue(struct soap *soap, struct ns1__set_USCORErelationship_USCOREvalue **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__set_USCORErelationship_USCOREvalue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__set_USCORErelationship_USCOREvalue ** SOAP_FMAC4 soap_in_PointerTons1__set_USCORErelationship_USCOREvalue(struct soap *soap, const char *tag, struct ns1__set_USCORErelationship_USCOREvalue **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__set_USCORErelationship_USCOREvalue **)soap_malloc(soap, sizeof(struct ns1__set_USCORErelationship_USCOREvalue *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__set_USCORErelationship_USCOREvalue(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__set_USCORErelationship_USCOREvalue **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__set_USCORErelationship_USCOREvalue, sizeof(struct ns1__set_USCORErelationship_USCOREvalue), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__id_USCOREmod(struct soap *soap, struct ns1__id_USCOREmod **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__id_USCOREmod))
		soap_serialize_PointerTons1__id_USCOREmod(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__id_USCOREmod(struct soap *soap, struct ns1__id_USCOREmod **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__id_USCOREmod);
	if (soap_out_PointerToPointerTons1__id_USCOREmod(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__id_USCOREmod(struct soap *soap, const char *tag, int id, struct ns1__id_USCOREmod **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__id_USCOREmod);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__id_USCOREmod(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__id_USCOREmod *** SOAP_FMAC4 soap_get_PointerToPointerTons1__id_USCOREmod(struct soap *soap, struct ns1__id_USCOREmod ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__id_USCOREmod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__id_USCOREmod *** SOAP_FMAC4 soap_in_PointerToPointerTons1__id_USCOREmod(struct soap *soap, const char *tag, struct ns1__id_USCOREmod ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__id_USCOREmod ***)soap_malloc(soap, sizeof(struct ns1__id_USCOREmod **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__id_USCOREmod(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__id_USCOREmod ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__id_USCOREmod, sizeof(struct ns1__id_USCOREmod *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__id_USCOREmod(struct soap *soap, struct ns1__id_USCOREmod *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__id_USCOREmod))
		soap_serialize_ns1__id_USCOREmod(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__id_USCOREmod(struct soap *soap, struct ns1__id_USCOREmod *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__id_USCOREmod);
	if (soap_out_PointerTons1__id_USCOREmod(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__id_USCOREmod(struct soap *soap, const char *tag, int id, struct ns1__id_USCOREmod *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__id_USCOREmod);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__id_USCOREmod(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__id_USCOREmod ** SOAP_FMAC4 soap_get_PointerTons1__id_USCOREmod(struct soap *soap, struct ns1__id_USCOREmod **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__id_USCOREmod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__id_USCOREmod ** SOAP_FMAC4 soap_in_PointerTons1__id_USCOREmod(struct soap *soap, const char *tag, struct ns1__id_USCOREmod **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__id_USCOREmod **)soap_malloc(soap, sizeof(struct ns1__id_USCOREmod *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__id_USCOREmod(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__id_USCOREmod **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__id_USCOREmod, sizeof(struct ns1__id_USCOREmod), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTolink_USCORElist(struct soap *soap, struct link_USCORElist **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTolink_USCORElist))
		soap_serialize_PointerTolink_USCORElist(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTolink_USCORElist(struct soap *soap, struct link_USCORElist **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTolink_USCORElist);
	if (soap_out_PointerToPointerTolink_USCORElist(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTolink_USCORElist(struct soap *soap, const char *tag, int id, struct link_USCORElist **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTolink_USCORElist);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTolink_USCORElist(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct link_USCORElist *** SOAP_FMAC4 soap_get_PointerToPointerTolink_USCORElist(struct soap *soap, struct link_USCORElist ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTolink_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct link_USCORElist *** SOAP_FMAC4 soap_in_PointerToPointerTolink_USCORElist(struct soap *soap, const char *tag, struct link_USCORElist ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct link_USCORElist ***)soap_malloc(soap, sizeof(struct link_USCORElist **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTolink_USCORElist(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct link_USCORElist ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTolink_USCORElist, sizeof(struct link_USCORElist *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__link_USCOREname_USCOREvalue(struct soap *soap, struct ns1__link_USCOREname_USCOREvalue **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__link_USCOREname_USCOREvalue))
		soap_serialize_PointerTons1__link_USCOREname_USCOREvalue(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__link_USCOREname_USCOREvalue(struct soap *soap, struct ns1__link_USCOREname_USCOREvalue **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__link_USCOREname_USCOREvalue);
	if (soap_out_PointerToPointerTons1__link_USCOREname_USCOREvalue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__link_USCOREname_USCOREvalue(struct soap *soap, const char *tag, int id, struct ns1__link_USCOREname_USCOREvalue **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__link_USCOREname_USCOREvalue);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__link_USCOREname_USCOREvalue(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__link_USCOREname_USCOREvalue *** SOAP_FMAC4 soap_get_PointerToPointerTons1__link_USCOREname_USCOREvalue(struct soap *soap, struct ns1__link_USCOREname_USCOREvalue ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__link_USCOREname_USCOREvalue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__link_USCOREname_USCOREvalue *** SOAP_FMAC4 soap_in_PointerToPointerTons1__link_USCOREname_USCOREvalue(struct soap *soap, const char *tag, struct ns1__link_USCOREname_USCOREvalue ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__link_USCOREname_USCOREvalue ***)soap_malloc(soap, sizeof(struct ns1__link_USCOREname_USCOREvalue **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__link_USCOREname_USCOREvalue(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__link_USCOREname_USCOREvalue ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__link_USCOREname_USCOREvalue, sizeof(struct ns1__link_USCOREname_USCOREvalue *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__link_USCOREname_USCOREvalue(struct soap *soap, struct ns1__link_USCOREname_USCOREvalue *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__link_USCOREname_USCOREvalue))
		soap_serialize_ns1__link_USCOREname_USCOREvalue(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__link_USCOREname_USCOREvalue(struct soap *soap, struct ns1__link_USCOREname_USCOREvalue *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__link_USCOREname_USCOREvalue);
	if (soap_out_PointerTons1__link_USCOREname_USCOREvalue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__link_USCOREname_USCOREvalue(struct soap *soap, const char *tag, int id, struct ns1__link_USCOREname_USCOREvalue *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__link_USCOREname_USCOREvalue);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__link_USCOREname_USCOREvalue(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__link_USCOREname_USCOREvalue ** SOAP_FMAC4 soap_get_PointerTons1__link_USCOREname_USCOREvalue(struct soap *soap, struct ns1__link_USCOREname_USCOREvalue **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__link_USCOREname_USCOREvalue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__link_USCOREname_USCOREvalue ** SOAP_FMAC4 soap_in_PointerTons1__link_USCOREname_USCOREvalue(struct soap *soap, const char *tag, struct ns1__link_USCOREname_USCOREvalue **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__link_USCOREname_USCOREvalue **)soap_malloc(soap, sizeof(struct ns1__link_USCOREname_USCOREvalue *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__link_USCOREname_USCOREvalue(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__link_USCOREname_USCOREvalue **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__link_USCOREname_USCOREvalue, sizeof(struct ns1__link_USCOREname_USCOREvalue), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTolink_USCOREvalue(struct soap *soap, struct link_USCOREvalue **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTolink_USCOREvalue))
		soap_serialize_PointerTolink_USCOREvalue(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTolink_USCOREvalue(struct soap *soap, struct link_USCOREvalue **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTolink_USCOREvalue);
	if (soap_out_PointerToPointerTolink_USCOREvalue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTolink_USCOREvalue(struct soap *soap, const char *tag, int id, struct link_USCOREvalue **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTolink_USCOREvalue);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTolink_USCOREvalue(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct link_USCOREvalue *** SOAP_FMAC4 soap_get_PointerToPointerTolink_USCOREvalue(struct soap *soap, struct link_USCOREvalue ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTolink_USCOREvalue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct link_USCOREvalue *** SOAP_FMAC4 soap_in_PointerToPointerTolink_USCOREvalue(struct soap *soap, const char *tag, struct link_USCOREvalue ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct link_USCOREvalue ***)soap_malloc(soap, sizeof(struct link_USCOREvalue **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTolink_USCOREvalue(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct link_USCOREvalue ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTolink_USCOREvalue, sizeof(struct link_USCOREvalue *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTolink_USCOREvalue(struct soap *soap, struct link_USCOREvalue *const*a)
{
	if (*a)
		soap_serialize_link_USCOREvalue(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTolink_USCOREvalue(struct soap *soap, struct link_USCOREvalue *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTolink_USCOREvalue);
	if (soap_out_PointerTolink_USCOREvalue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTolink_USCOREvalue(struct soap *soap, const char *tag, int id, struct link_USCOREvalue *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_link_USCOREvalue);
	if (id < 0)
		return soap->error;
	return soap_out_link_USCOREvalue(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct link_USCOREvalue ** SOAP_FMAC4 soap_get_PointerTolink_USCOREvalue(struct soap *soap, struct link_USCOREvalue **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTolink_USCOREvalue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct link_USCOREvalue ** SOAP_FMAC4 soap_in_PointerTolink_USCOREvalue(struct soap *soap, const char *tag, struct link_USCOREvalue **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct link_USCOREvalue **)soap_malloc(soap, sizeof(struct link_USCOREvalue *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_link_USCOREvalue(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct link_USCOREvalue **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_link_USCOREvalue, sizeof(struct link_USCOREvalue), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__entry_USCOREvalue(struct soap *soap, struct ns1__entry_USCOREvalue **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__entry_USCOREvalue))
		soap_serialize_PointerTons1__entry_USCOREvalue(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__entry_USCOREvalue(struct soap *soap, struct ns1__entry_USCOREvalue **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__entry_USCOREvalue);
	if (soap_out_PointerToPointerTons1__entry_USCOREvalue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__entry_USCOREvalue(struct soap *soap, const char *tag, int id, struct ns1__entry_USCOREvalue **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__entry_USCOREvalue);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__entry_USCOREvalue(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__entry_USCOREvalue *** SOAP_FMAC4 soap_get_PointerToPointerTons1__entry_USCOREvalue(struct soap *soap, struct ns1__entry_USCOREvalue ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__entry_USCOREvalue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__entry_USCOREvalue *** SOAP_FMAC4 soap_in_PointerToPointerTons1__entry_USCOREvalue(struct soap *soap, const char *tag, struct ns1__entry_USCOREvalue ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__entry_USCOREvalue ***)soap_malloc(soap, sizeof(struct ns1__entry_USCOREvalue **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__entry_USCOREvalue(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__entry_USCOREvalue ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__entry_USCOREvalue, sizeof(struct ns1__entry_USCOREvalue *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__entry_USCOREvalue(struct soap *soap, struct ns1__entry_USCOREvalue *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__entry_USCOREvalue))
		soap_serialize_ns1__entry_USCOREvalue(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__entry_USCOREvalue(struct soap *soap, struct ns1__entry_USCOREvalue *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__entry_USCOREvalue);
	if (soap_out_PointerTons1__entry_USCOREvalue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__entry_USCOREvalue(struct soap *soap, const char *tag, int id, struct ns1__entry_USCOREvalue *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__entry_USCOREvalue);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__entry_USCOREvalue(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__entry_USCOREvalue ** SOAP_FMAC4 soap_get_PointerTons1__entry_USCOREvalue(struct soap *soap, struct ns1__entry_USCOREvalue **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__entry_USCOREvalue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__entry_USCOREvalue ** SOAP_FMAC4 soap_in_PointerTons1__entry_USCOREvalue(struct soap *soap, const char *tag, struct ns1__entry_USCOREvalue **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__entry_USCOREvalue **)soap_malloc(soap, sizeof(struct ns1__entry_USCOREvalue *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__entry_USCOREvalue(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__entry_USCOREvalue **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__entry_USCOREvalue, sizeof(struct ns1__entry_USCOREvalue), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostring);
	if (soap_out_PointerTostring(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToname_USCOREvalue_USCORElist(struct soap *soap, struct name_USCOREvalue_USCORElist **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerToname_USCOREvalue_USCORElist))
		soap_serialize_PointerToname_USCOREvalue_USCORElist(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToname_USCOREvalue_USCORElist(struct soap *soap, struct name_USCOREvalue_USCORElist **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToname_USCOREvalue_USCORElist);
	if (soap_out_PointerToPointerToname_USCOREvalue_USCORElist(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToname_USCOREvalue_USCORElist(struct soap *soap, const char *tag, int id, struct name_USCOREvalue_USCORElist **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToname_USCOREvalue_USCORElist);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToname_USCOREvalue_USCORElist(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct name_USCOREvalue_USCORElist *** SOAP_FMAC4 soap_get_PointerToPointerToname_USCOREvalue_USCORElist(struct soap *soap, struct name_USCOREvalue_USCORElist ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToname_USCOREvalue_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct name_USCOREvalue_USCORElist *** SOAP_FMAC4 soap_in_PointerToPointerToname_USCOREvalue_USCORElist(struct soap *soap, const char *tag, struct name_USCOREvalue_USCORElist ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct name_USCOREvalue_USCORElist ***)soap_malloc(soap, sizeof(struct name_USCOREvalue_USCORElist **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToname_USCOREvalue_USCORElist(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct name_USCOREvalue_USCORElist ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToname_USCOREvalue_USCORElist, sizeof(struct name_USCOREvalue_USCORElist *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__name_USCOREvalue(struct soap *soap, struct ns1__name_USCOREvalue **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__name_USCOREvalue))
		soap_serialize_PointerTons1__name_USCOREvalue(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__name_USCOREvalue(struct soap *soap, struct ns1__name_USCOREvalue **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__name_USCOREvalue);
	if (soap_out_PointerToPointerTons1__name_USCOREvalue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__name_USCOREvalue(struct soap *soap, const char *tag, int id, struct ns1__name_USCOREvalue **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__name_USCOREvalue);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__name_USCOREvalue(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__name_USCOREvalue *** SOAP_FMAC4 soap_get_PointerToPointerTons1__name_USCOREvalue(struct soap *soap, struct ns1__name_USCOREvalue ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__name_USCOREvalue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__name_USCOREvalue *** SOAP_FMAC4 soap_in_PointerToPointerTons1__name_USCOREvalue(struct soap *soap, const char *tag, struct ns1__name_USCOREvalue ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__name_USCOREvalue ***)soap_malloc(soap, sizeof(struct ns1__name_USCOREvalue **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__name_USCOREvalue(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__name_USCOREvalue ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__name_USCOREvalue, sizeof(struct ns1__name_USCOREvalue *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__name_USCOREvalue(struct soap *soap, struct ns1__name_USCOREvalue *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__name_USCOREvalue))
		soap_serialize_ns1__name_USCOREvalue(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__name_USCOREvalue(struct soap *soap, struct ns1__name_USCOREvalue *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__name_USCOREvalue);
	if (soap_out_PointerTons1__name_USCOREvalue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__name_USCOREvalue(struct soap *soap, const char *tag, int id, struct ns1__name_USCOREvalue *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__name_USCOREvalue);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__name_USCOREvalue(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__name_USCOREvalue ** SOAP_FMAC4 soap_get_PointerTons1__name_USCOREvalue(struct soap *soap, struct ns1__name_USCOREvalue **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__name_USCOREvalue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__name_USCOREvalue ** SOAP_FMAC4 soap_in_PointerTons1__name_USCOREvalue(struct soap *soap, const char *tag, struct ns1__name_USCOREvalue **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__name_USCOREvalue **)soap_malloc(soap, sizeof(struct ns1__name_USCOREvalue *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__name_USCOREvalue(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__name_USCOREvalue **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__name_USCOREvalue, sizeof(struct ns1__name_USCOREvalue), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__link_USCOREfield(struct soap *soap, struct ns1__link_USCOREfield **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__link_USCOREfield))
		soap_serialize_PointerTons1__link_USCOREfield(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__link_USCOREfield(struct soap *soap, struct ns1__link_USCOREfield **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__link_USCOREfield);
	if (soap_out_PointerToPointerTons1__link_USCOREfield(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__link_USCOREfield(struct soap *soap, const char *tag, int id, struct ns1__link_USCOREfield **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__link_USCOREfield);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__link_USCOREfield(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__link_USCOREfield *** SOAP_FMAC4 soap_get_PointerToPointerTons1__link_USCOREfield(struct soap *soap, struct ns1__link_USCOREfield ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__link_USCOREfield(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__link_USCOREfield *** SOAP_FMAC4 soap_in_PointerToPointerTons1__link_USCOREfield(struct soap *soap, const char *tag, struct ns1__link_USCOREfield ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__link_USCOREfield ***)soap_malloc(soap, sizeof(struct ns1__link_USCOREfield **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__link_USCOREfield(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__link_USCOREfield ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__link_USCOREfield, sizeof(struct ns1__link_USCOREfield *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__link_USCOREfield(struct soap *soap, struct ns1__link_USCOREfield *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__link_USCOREfield))
		soap_serialize_ns1__link_USCOREfield(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__link_USCOREfield(struct soap *soap, struct ns1__link_USCOREfield *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__link_USCOREfield);
	if (soap_out_PointerTons1__link_USCOREfield(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__link_USCOREfield(struct soap *soap, const char *tag, int id, struct ns1__link_USCOREfield *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__link_USCOREfield);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__link_USCOREfield(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__link_USCOREfield ** SOAP_FMAC4 soap_get_PointerTons1__link_USCOREfield(struct soap *soap, struct ns1__link_USCOREfield **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__link_USCOREfield(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__link_USCOREfield ** SOAP_FMAC4 soap_in_PointerTons1__link_USCOREfield(struct soap *soap, const char *tag, struct ns1__link_USCOREfield **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__link_USCOREfield **)soap_malloc(soap, sizeof(struct ns1__link_USCOREfield *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__link_USCOREfield(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__link_USCOREfield **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__link_USCOREfield, sizeof(struct ns1__link_USCOREfield), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__field(struct soap *soap, struct ns1__field **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__field))
		soap_serialize_PointerTons1__field(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__field(struct soap *soap, struct ns1__field **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__field);
	if (soap_out_PointerToPointerTons1__field(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__field(struct soap *soap, const char *tag, int id, struct ns1__field **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__field);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__field(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__field *** SOAP_FMAC4 soap_get_PointerToPointerTons1__field(struct soap *soap, struct ns1__field ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__field(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__field *** SOAP_FMAC4 soap_in_PointerToPointerTons1__field(struct soap *soap, const char *tag, struct ns1__field ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__field ***)soap_malloc(soap, sizeof(struct ns1__field **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__field(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__field ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__field, sizeof(struct ns1__field *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__field(struct soap *soap, struct ns1__field *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__field))
		soap_serialize_ns1__field(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__field(struct soap *soap, struct ns1__field *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__field);
	if (soap_out_PointerTons1__field(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__field(struct soap *soap, const char *tag, int id, struct ns1__field *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__field);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__field(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__field ** SOAP_FMAC4 soap_get_PointerTons1__field(struct soap *soap, struct ns1__field **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__field(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__field ** SOAP_FMAC4 soap_in_PointerTons1__field(struct soap *soap, const char *tag, struct ns1__field **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__field **)soap_malloc(soap, sizeof(struct ns1__field *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__field(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__field **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__field, sizeof(struct ns1__field), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToname_USCOREvalue_USCORElists(struct soap *soap, struct name_USCOREvalue_USCORElists *const*a)
{
	if (*a)
		soap_serialize_name_USCOREvalue_USCORElists(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToname_USCOREvalue_USCORElists(struct soap *soap, struct name_USCOREvalue_USCORElists *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToname_USCOREvalue_USCORElists);
	if (soap_out_PointerToname_USCOREvalue_USCORElists(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToname_USCOREvalue_USCORElists(struct soap *soap, const char *tag, int id, struct name_USCOREvalue_USCORElists *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_name_USCOREvalue_USCORElists);
	if (id < 0)
		return soap->error;
	return soap_out_name_USCOREvalue_USCORElists(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct name_USCOREvalue_USCORElists ** SOAP_FMAC4 soap_get_PointerToname_USCOREvalue_USCORElists(struct soap *soap, struct name_USCOREvalue_USCORElists **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToname_USCOREvalue_USCORElists(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct name_USCOREvalue_USCORElists ** SOAP_FMAC4 soap_in_PointerToname_USCOREvalue_USCORElists(struct soap *soap, const char *tag, struct name_USCOREvalue_USCORElists **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct name_USCOREvalue_USCORElists **)soap_malloc(soap, sizeof(struct name_USCOREvalue_USCORElists *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_name_USCOREvalue_USCORElists(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct name_USCOREvalue_USCORElists **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_name_USCOREvalue_USCORElists, sizeof(struct name_USCOREvalue_USCORElists), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTonewsletter_USCORElist(struct soap *soap, struct newsletter_USCORElist *const*a)
{
	if (*a)
		soap_serialize_newsletter_USCORElist(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTonewsletter_USCORElist(struct soap *soap, struct newsletter_USCORElist *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTonewsletter_USCORElist);
	if (soap_out_PointerTonewsletter_USCORElist(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTonewsletter_USCORElist(struct soap *soap, const char *tag, int id, struct newsletter_USCORElist *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_newsletter_USCORElist);
	if (id < 0)
		return soap->error;
	return soap_out_newsletter_USCORElist(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct newsletter_USCORElist ** SOAP_FMAC4 soap_get_PointerTonewsletter_USCORElist(struct soap *soap, struct newsletter_USCORElist **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTonewsletter_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct newsletter_USCORElist ** SOAP_FMAC4 soap_in_PointerTonewsletter_USCORElist(struct soap *soap, const char *tag, struct newsletter_USCORElist **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct newsletter_USCORElist **)soap_malloc(soap, sizeof(struct newsletter_USCORElist *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_newsletter_USCORElist(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct newsletter_USCORElist **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_newsletter_USCORElist, sizeof(struct newsletter_USCORElist), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__document_USCORErevision(struct soap *soap, struct ns1__document_USCORErevision *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__document_USCORErevision))
		soap_serialize_ns1__document_USCORErevision(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__document_USCORErevision(struct soap *soap, struct ns1__document_USCORErevision *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__document_USCORErevision);
	if (soap_out_PointerTons1__document_USCORErevision(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__document_USCORErevision(struct soap *soap, const char *tag, int id, struct ns1__document_USCORErevision *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__document_USCORErevision);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__document_USCORErevision(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__document_USCORErevision ** SOAP_FMAC4 soap_get_PointerTons1__document_USCORErevision(struct soap *soap, struct ns1__document_USCORErevision **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__document_USCORErevision(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__document_USCORErevision ** SOAP_FMAC4 soap_in_PointerTons1__document_USCORErevision(struct soap *soap, const char *tag, struct ns1__document_USCORErevision **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__document_USCORErevision **)soap_malloc(soap, sizeof(struct ns1__document_USCORErevision *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__document_USCORErevision(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__document_USCORErevision **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__document_USCORErevision, sizeof(struct ns1__document_USCORErevision), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToids_USCOREmods(struct soap *soap, struct ids_USCOREmods *const*a)
{
	if (*a)
		soap_serialize_ids_USCOREmods(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToids_USCOREmods(struct soap *soap, struct ids_USCOREmods *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToids_USCOREmods);
	if (soap_out_PointerToids_USCOREmods(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToids_USCOREmods(struct soap *soap, const char *tag, int id, struct ids_USCOREmods *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ids_USCOREmods);
	if (id < 0)
		return soap->error;
	return soap_out_ids_USCOREmods(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ids_USCOREmods ** SOAP_FMAC4 soap_get_PointerToids_USCOREmods(struct soap *soap, struct ids_USCOREmods **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToids_USCOREmods(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ids_USCOREmods ** SOAP_FMAC4 soap_in_PointerToids_USCOREmods(struct soap *soap, const char *tag, struct ids_USCOREmods **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ids_USCOREmods **)soap_malloc(soap, sizeof(struct ids_USCOREmods *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ids_USCOREmods(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ids_USCOREmods **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ids_USCOREmods, sizeof(struct ids_USCOREmods), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTolink_USCORElist(struct soap *soap, struct link_USCORElist *const*a)
{
	if (*a)
		soap_serialize_link_USCORElist(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTolink_USCORElist(struct soap *soap, struct link_USCORElist *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTolink_USCORElist);
	if (soap_out_PointerTolink_USCORElist(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTolink_USCORElist(struct soap *soap, const char *tag, int id, struct link_USCORElist *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_link_USCORElist);
	if (id < 0)
		return soap->error;
	return soap_out_link_USCORElist(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct link_USCORElist ** SOAP_FMAC4 soap_get_PointerTolink_USCORElist(struct soap *soap, struct link_USCORElist **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTolink_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct link_USCORElist ** SOAP_FMAC4 soap_in_PointerTolink_USCORElist(struct soap *soap, const char *tag, struct link_USCORElist **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct link_USCORElist **)soap_malloc(soap, sizeof(struct link_USCORElist *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_link_USCORElist(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct link_USCORElist **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_link_USCORElist, sizeof(struct link_USCORElist), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTolink_USCORElists(struct soap *soap, struct link_USCORElists *const*a)
{
	if (*a)
		soap_serialize_link_USCORElists(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTolink_USCORElists(struct soap *soap, struct link_USCORElists *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTolink_USCORElists);
	if (soap_out_PointerTolink_USCORElists(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTolink_USCORElists(struct soap *soap, const char *tag, int id, struct link_USCORElists *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_link_USCORElists);
	if (id < 0)
		return soap->error;
	return soap_out_link_USCORElists(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct link_USCORElists ** SOAP_FMAC4 soap_get_PointerTolink_USCORElists(struct soap *soap, struct link_USCORElists **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTolink_USCORElists(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct link_USCORElists ** SOAP_FMAC4 soap_in_PointerTolink_USCORElists(struct soap *soap, const char *tag, struct link_USCORElists **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct link_USCORElists **)soap_malloc(soap, sizeof(struct link_USCORElists *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_link_USCORElists(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct link_USCORElists **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_link_USCORElists, sizeof(struct link_USCORElists), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToentry_USCORElist(struct soap *soap, struct entry_USCORElist *const*a)
{
	if (*a)
		soap_serialize_entry_USCORElist(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToentry_USCORElist(struct soap *soap, struct entry_USCORElist *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToentry_USCORElist);
	if (soap_out_PointerToentry_USCORElist(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToentry_USCORElist(struct soap *soap, const char *tag, int id, struct entry_USCORElist *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_entry_USCORElist);
	if (id < 0)
		return soap->error;
	return soap_out_entry_USCORElist(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct entry_USCORElist ** SOAP_FMAC4 soap_get_PointerToentry_USCORElist(struct soap *soap, struct entry_USCORElist **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToentry_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct entry_USCORElist ** SOAP_FMAC4 soap_in_PointerToentry_USCORElist(struct soap *soap, const char *tag, struct entry_USCORElist **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct entry_USCORElist **)soap_malloc(soap, sizeof(struct entry_USCORElist *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_entry_USCORElist(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct entry_USCORElist **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_entry_USCORElist, sizeof(struct entry_USCORElist), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTolink_USCOREarray_USCORElist(struct soap *soap, struct link_USCOREarray_USCORElist *const*a)
{
	if (*a)
		soap_serialize_link_USCOREarray_USCORElist(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTolink_USCOREarray_USCORElist(struct soap *soap, struct link_USCOREarray_USCORElist *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTolink_USCOREarray_USCORElist);
	if (soap_out_PointerTolink_USCOREarray_USCORElist(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTolink_USCOREarray_USCORElist(struct soap *soap, const char *tag, int id, struct link_USCOREarray_USCORElist *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_link_USCOREarray_USCORElist);
	if (id < 0)
		return soap->error;
	return soap_out_link_USCOREarray_USCORElist(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct link_USCOREarray_USCORElist ** SOAP_FMAC4 soap_get_PointerTolink_USCOREarray_USCORElist(struct soap *soap, struct link_USCOREarray_USCORElist **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTolink_USCOREarray_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct link_USCOREarray_USCORElist ** SOAP_FMAC4 soap_in_PointerTolink_USCOREarray_USCORElist(struct soap *soap, const char *tag, struct link_USCOREarray_USCORElist **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct link_USCOREarray_USCORElist **)soap_malloc(soap, sizeof(struct link_USCOREarray_USCORElist *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_link_USCOREarray_USCORElist(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct link_USCOREarray_USCORElist **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_link_USCOREarray_USCORElist, sizeof(struct link_USCOREarray_USCORElist), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToselect_USCOREfields(struct soap *soap, struct select_USCOREfields *const*a)
{
	if (*a)
		soap_serialize_select_USCOREfields(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToselect_USCOREfields(struct soap *soap, struct select_USCOREfields *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToselect_USCOREfields);
	if (soap_out_PointerToselect_USCOREfields(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToselect_USCOREfields(struct soap *soap, const char *tag, int id, struct select_USCOREfields *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_select_USCOREfields);
	if (id < 0)
		return soap->error;
	return soap_out_select_USCOREfields(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct select_USCOREfields ** SOAP_FMAC4 soap_get_PointerToselect_USCOREfields(struct soap *soap, struct select_USCOREfields **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToselect_USCOREfields(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct select_USCOREfields ** SOAP_FMAC4 soap_in_PointerToselect_USCOREfields(struct soap *soap, const char *tag, struct select_USCOREfields **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct select_USCOREfields **)soap_malloc(soap, sizeof(struct select_USCOREfields *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_select_USCOREfields(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct select_USCOREfields **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_select_USCOREfields, sizeof(struct select_USCOREfields), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTolink_USCOREfield_USCORElist(struct soap *soap, struct link_USCOREfield_USCORElist *const*a)
{
	if (*a)
		soap_serialize_link_USCOREfield_USCORElist(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTolink_USCOREfield_USCORElist(struct soap *soap, struct link_USCOREfield_USCORElist *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTolink_USCOREfield_USCORElist);
	if (soap_out_PointerTolink_USCOREfield_USCORElist(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTolink_USCOREfield_USCORElist(struct soap *soap, const char *tag, int id, struct link_USCOREfield_USCORElist *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_link_USCOREfield_USCORElist);
	if (id < 0)
		return soap->error;
	return soap_out_link_USCOREfield_USCORElist(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct link_USCOREfield_USCORElist ** SOAP_FMAC4 soap_get_PointerTolink_USCOREfield_USCORElist(struct soap *soap, struct link_USCOREfield_USCORElist **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTolink_USCOREfield_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct link_USCOREfield_USCORElist ** SOAP_FMAC4 soap_in_PointerTolink_USCOREfield_USCORElist(struct soap *soap, const char *tag, struct link_USCOREfield_USCORElist **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct link_USCOREfield_USCORElist **)soap_malloc(soap, sizeof(struct link_USCOREfield_USCORElist *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_link_USCOREfield_USCORElist(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct link_USCOREfield_USCORElist **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_link_USCOREfield_USCORElist, sizeof(struct link_USCOREfield_USCORElist), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofield_USCORElist(struct soap *soap, struct field_USCORElist *const*a)
{
	if (*a)
		soap_serialize_field_USCORElist(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofield_USCORElist(struct soap *soap, struct field_USCORElist *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofield_USCORElist);
	if (soap_out_PointerTofield_USCORElist(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofield_USCORElist(struct soap *soap, const char *tag, int id, struct field_USCORElist *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_field_USCORElist);
	if (id < 0)
		return soap->error;
	return soap_out_field_USCORElist(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct field_USCORElist ** SOAP_FMAC4 soap_get_PointerTofield_USCORElist(struct soap *soap, struct field_USCORElist **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofield_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct field_USCORElist ** SOAP_FMAC4 soap_in_PointerTofield_USCORElist(struct soap *soap, const char *tag, struct field_USCORElist **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct field_USCORElist **)soap_malloc(soap, sizeof(struct field_USCORElist *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_field_USCORElist(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct field_USCORElist **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_field_USCORElist, sizeof(struct field_USCORElist), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToname_USCOREvalue_USCORElist(struct soap *soap, struct name_USCOREvalue_USCORElist *const*a)
{
	if (*a)
		soap_serialize_name_USCOREvalue_USCORElist(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToname_USCOREvalue_USCORElist(struct soap *soap, struct name_USCOREvalue_USCORElist *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToname_USCOREvalue_USCORElist);
	if (soap_out_PointerToname_USCOREvalue_USCORElist(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToname_USCOREvalue_USCORElist(struct soap *soap, const char *tag, int id, struct name_USCOREvalue_USCORElist *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_name_USCOREvalue_USCORElist);
	if (id < 0)
		return soap->error;
	return soap_out_name_USCOREvalue_USCORElist(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct name_USCOREvalue_USCORElist ** SOAP_FMAC4 soap_get_PointerToname_USCOREvalue_USCORElist(struct soap *soap, struct name_USCOREvalue_USCORElist **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToname_USCOREvalue_USCORElist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct name_USCOREvalue_USCORElist ** SOAP_FMAC4 soap_in_PointerToname_USCOREvalue_USCORElist(struct soap *soap, const char *tag, struct name_USCOREvalue_USCORElist **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct name_USCOREvalue_USCORElist **)soap_malloc(soap, sizeof(struct name_USCOREvalue_USCORElist *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_name_USCOREvalue_USCORElist(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct name_USCOREvalue_USCORElist **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_name_USCOREvalue_USCORElist, sizeof(struct name_USCOREvalue_USCORElist), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__error_USCOREvalue(struct soap *soap, struct ns1__error_USCOREvalue *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__error_USCOREvalue))
		soap_serialize_ns1__error_USCOREvalue(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__error_USCOREvalue(struct soap *soap, struct ns1__error_USCOREvalue *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__error_USCOREvalue);
	if (soap_out_PointerTons1__error_USCOREvalue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__error_USCOREvalue(struct soap *soap, const char *tag, int id, struct ns1__error_USCOREvalue *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__error_USCOREvalue);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__error_USCOREvalue(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__error_USCOREvalue ** SOAP_FMAC4 soap_get_PointerTons1__error_USCOREvalue(struct soap *soap, struct ns1__error_USCOREvalue **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__error_USCOREvalue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__error_USCOREvalue ** SOAP_FMAC4 soap_in_PointerTons1__error_USCOREvalue(struct soap *soap, const char *tag, struct ns1__error_USCOREvalue **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__error_USCOREvalue **)soap_malloc(soap, sizeof(struct ns1__error_USCOREvalue *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__error_USCOREvalue(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__error_USCOREvalue **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__error_USCOREvalue, sizeof(struct ns1__error_USCOREvalue), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__note_USCOREattachment(struct soap *soap, struct ns1__note_USCOREattachment *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__note_USCOREattachment))
		soap_serialize_ns1__note_USCOREattachment(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__note_USCOREattachment(struct soap *soap, struct ns1__note_USCOREattachment *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__note_USCOREattachment);
	if (soap_out_PointerTons1__note_USCOREattachment(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__note_USCOREattachment(struct soap *soap, const char *tag, int id, struct ns1__note_USCOREattachment *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__note_USCOREattachment);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__note_USCOREattachment(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__note_USCOREattachment ** SOAP_FMAC4 soap_get_PointerTons1__note_USCOREattachment(struct soap *soap, struct ns1__note_USCOREattachment **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__note_USCOREattachment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__note_USCOREattachment ** SOAP_FMAC4 soap_in_PointerTons1__note_USCOREattachment(struct soap *soap, const char *tag, struct ns1__note_USCOREattachment **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__note_USCOREattachment **)soap_malloc(soap, sizeof(struct ns1__note_USCOREattachment *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__note_USCOREattachment(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__note_USCOREattachment **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__note_USCOREattachment, sizeof(struct ns1__note_USCOREattachment), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__new_USCOREnote_USCOREattachment(struct soap *soap, struct ns1__new_USCOREnote_USCOREattachment *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__new_USCOREnote_USCOREattachment))
		soap_serialize_ns1__new_USCOREnote_USCOREattachment(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__new_USCOREnote_USCOREattachment(struct soap *soap, struct ns1__new_USCOREnote_USCOREattachment *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__new_USCOREnote_USCOREattachment);
	if (soap_out_PointerTons1__new_USCOREnote_USCOREattachment(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__new_USCOREnote_USCOREattachment(struct soap *soap, const char *tag, int id, struct ns1__new_USCOREnote_USCOREattachment *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__new_USCOREnote_USCOREattachment);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__new_USCOREnote_USCOREattachment(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__new_USCOREnote_USCOREattachment ** SOAP_FMAC4 soap_get_PointerTons1__new_USCOREnote_USCOREattachment(struct soap *soap, struct ns1__new_USCOREnote_USCOREattachment **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__new_USCOREnote_USCOREattachment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__new_USCOREnote_USCOREattachment ** SOAP_FMAC4 soap_in_PointerTons1__new_USCOREnote_USCOREattachment(struct soap *soap, const char *tag, struct ns1__new_USCOREnote_USCOREattachment **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__new_USCOREnote_USCOREattachment **)soap_malloc(soap, sizeof(struct ns1__new_USCOREnote_USCOREattachment *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__new_USCOREnote_USCOREattachment(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__new_USCOREnote_USCOREattachment **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__new_USCOREnote_USCOREattachment, sizeof(struct ns1__new_USCOREnote_USCOREattachment), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__date(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__date(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__date(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__date);
	if (soap_out_xsd__date(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__date(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__date);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__date(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__date(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__date(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__date, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
}

#ifdef __cplusplus
}
#endif

/* End of soapC.c */
